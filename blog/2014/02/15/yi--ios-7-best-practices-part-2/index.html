
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>[译]iOS7最佳实践：一个天气App案例(二) - sjpsega's Blog</title>
  <meta name="author" content="sjpsega">

  
  <meta name="description" content="注：本文译自：raywenderlich ios-7-best-practices-part-2，去除了跟主题无关的寒暄部分。
欢迎转载，保持署名 开始 你有两个选择开始本教程：您可以使用在本教程的第1部分你已完成的项目，或者你可以在这里下载第1部分已完成的项目。 &hellip;">
  <meta name="keywords" content="iOS7, Cocoapods, ReactiveCocoa, Mantle">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--友言验证-->
  <meta name="uyan_auth" content="7d2af41cee" />

  
  <link rel="canonical" href="http://sjpsega.me/blog/2014/02/15/yi--ios-7-best-practices-part-2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="sjpsega's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/jquery.min.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts 
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->
  

  <script type="text/javascript">
  //链接新开窗口
  function addBlankTargetForLinks () {
      $('a[href^="http"]').each(function(){
          $(this).attr('target', '_blank');
      });
  }
  $(document).ready(function(event) {
      addBlankTargetForLinks();
  });
  </script>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">sjpsega's Blog</a></h1>
  
    <h2>记录我的生活与学习.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="sjpsega.me">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><a href="/blog/categories/study">学习</a></li>
  <li><a href="/blog/categories/life">生活</a></li>
  <li><a href="/blog/categories/invest">投资</a></li>
  <li><a href="http://weibo.com/sjpsega" target="_blank">我的微博</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">[译]iOS7最佳实践：一个天气App案例(二)</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-02-15T16:46:02+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>4:46 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>注：本文译自：<a href="http://www.raywenderlich.com/55385/ios-7-best-practices-part-2">raywenderlich ios-7-best-practices-part-2</a>，去除了跟主题无关的寒暄部分。
欢迎转载，保持署名</p>

<h2>开始</h2>

<p>你有两个选择开始本教程：您可以使用在本教程的第1部分你已完成的项目，或者你可以在这里下载<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/SimpleWeather-Part-1.zip">第1部分已完成的项目</a>。</p>

<p>在前面的教程中你创建了你的App的天气模型 - 现在你需要使用OpenWeatherMap API为你的App来获取一些数据。你将使用两个类抽象数据抓取、分析、存储：<code>WXClient</code>和<code>WXManager</code>。</p>

<p><code>WXClient</code>的唯一责任是创建API请求，并解析它们；别人可以不用担心用数据做什么以及如何存储它。划分类的不同工作职责的设计模式被称为关注点分离。这使你的代码更容易理解，扩展和维护。</p>

<h2>与ReactiveCocoa工作</h2>

<p>确保你使用<code>SimpleWeather.xcworkspace</code>,打开<code>WXClient.h</code>并增加imports</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@import CoreLocation;
</span><span class='line'>#import &lt;ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h&gt;</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>注意：您可能之前没有见过的@import指令，它在Xcode5中被引入，是由苹果公司看作是一个现代的，更高效的替代 #import。有一个非常好的教程，涵盖了最新的Objective-C特性-[What’s New in Objective-C and Foundation in iOS 7](http://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7)。</span></code></pre></td></tr></table></div></figure>


<p>在<code>WXClient.h</code>中添加下列四个方法到接口申明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@import Foundation;
</span><span class='line'>- (RACSignal *)fetchJSONFromURL:(NSURL *)url;
</span><span class='line'>- (RACSignal *)fetchCurrentConditionsForLocation:(CLLocationCoordinate2D)coordinate;
</span><span class='line'>- (RACSignal *)fetchHourlyForecastForLocation:(CLLocationCoordinate2D)coordinate;
</span><span class='line'>- (RACSignal *)fetchDailyForecastForLocation:(CLLocationCoordinate2D)coordinate;</span></code></pre></td></tr></table></div></figure>


<p>现在，似乎是一个很好的机会来介绍<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>！</p>

<p>ReactiveCocoa（RAC）是一个Objective-C的框架，用于函数式反应型编程，它提供了组合和转化数据流的API。代替专注于编写串行的代码 - 执行有序的代码队列 - 可以响应非确定性事件。</p>

<p>Github上提供的<a href="https://github.com/blog/1107-reactivecocoa-for-a-better-world">a great overview of the benefits</a>：</p>

<ul>
<li>对未来数据的进行组合操作的能力。</li>
<li>减少状态和可变性。</li>
<li>用声明的形式来定义行为和属性之间的关系。</li>
<li>为异步操作带来一个统一的，高层次的接口。</li>
<li>在KVO的基础上建立一个优雅的API。</li>
</ul>


<p>例如，你可以监听<code>username</code>属性的变化，用这样的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[RACAble(self.username) subscribeNext:^(NSString *newName) {
</span><span class='line'>    NSLog(@"%@", newName);
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p><code>subscribeNext</code>这个block会在<code>self.username</code>属性变化的时候执行。新的值会传递给这个block。</p>

<p>您还可以合并信号并组合数据到一个组合数据中。下面的示例取自于ReactiveCocoa的Github页面：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[RACSignal 
</span><span class='line'>    combineLatest:@[ RACAble(self.password), RACAble(self.passwordConfirmation) ] 
</span><span class='line'>           reduce:^(NSString *currentPassword, NSString *currentConfirmPassword) {
</span><span class='line'>               return [NSNumber numberWithBool:[currentConfirmPassword isEqualToString:currentPassword]];
</span><span class='line'>           }] 
</span><span class='line'>    subscribeNext:^(NSNumber *passwordsMatch) {
</span><span class='line'>        self.createEnabled = [passwordsMatch boolValue];
</span><span class='line'>    }];</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACSignal.h">RACSignal</a>对象捕捉当前和未来的值。信号可以被观察者链接，组合和反应。信号实际上不会执行，直到它被订阅。</p>

<p>这意味着调用<code>[mySignal fetchCurrentConditionsForLocation：someLocation];</code>不会做什么，但创建并返回一个信号。你将看到之后如何订阅和反应。</p>

<p>打开<code>WXClient.m</code>加入以下imports:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "WXCondition.h"
</span><span class='line'>#import "WXDailyForecast.h"</span></code></pre></td></tr></table></div></figure>


<p>在imports下，添加私有接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface WXClient ()
</span><span class='line'> 
</span><span class='line'>@property (nonatomic, strong) NSURLSession *session;
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<p>这个接口用这个属性来管理API请求的URL session。</p>

<p>添加以下<code>init</code>放到到<code>@implementation</code>和<code>@end</code>之间：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)init {
</span><span class='line'>    if (self = [super init]) {
</span><span class='line'>        NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
</span><span class='line'>        _session = [NSURLSession sessionWithConfiguration:config];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>使用<code>defaultSessionConfiguration</code>为您创建session。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>注意：如果你以前没有了解过NSURLSession，看看我们的[NSURLSession教程](http://www.raywenderlich.com/51127/nsurlsession-tutorial)，了解更多信息。</span></code></pre></td></tr></table></div></figure>


<h2>构建信号</h2>

<p>你需要一个主方法来建立一个信号从URL中取数据。你已经知道，需要三种方法来获取当前状况，逐时预报及每日预报。</p>

<p>不是写三个独立的方法，你可以遵守<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>（Don’t Repeat Yourself）的软件设计理念，使您的代码容易维护。</p>

<p>第一次看，以下的一些ReactiveCocoa部分可能看起来相当陌生。别担心，你会一块一块理解他。</p>

<p>增加下列方法到<code>WXClient.m</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (RACSignal *)fetchJSONFromURL:(NSURL *)url {
</span><span class='line'>    NSLog(@"Fetching: %@",url.absoluteString);
</span><span class='line'> 
</span><span class='line'>    // 1
</span><span class='line'>    return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
</span><span class='line'>        // 2
</span><span class='line'>        NSURLSessionDataTask *dataTask = [self.session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
</span><span class='line'>            // TODO: Handle retrieved data
</span><span class='line'>        }];
</span><span class='line'> 
</span><span class='line'>        // 3
</span><span class='line'>        [dataTask resume];
</span><span class='line'> 
</span><span class='line'>        // 4
</span><span class='line'>        return [RACDisposable disposableWithBlock:^{
</span><span class='line'>            [dataTask cancel];
</span><span class='line'>        }];
</span><span class='line'>    }] doError:^(NSError *error) {
</span><span class='line'>        // 5
</span><span class='line'>        NSLog(@"%@",error);
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过一个一个注释，你会看到代码执行以下操作：</p>

<ol>
<li>返回信号。请记住，这将不会执行，直到这个信号被订阅。 <code>- fetchJSONFromURL：</code>创建一个对象给其他方法和对象使用；这种行为有时也被称为<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassFactoryMethods/ClassFactoryMethods.html">工厂模式</a>。</li>
<li>创建一个<a href="https://developer.apple.com/library/IOS/documentation/Foundation/Reference/NSURLSessionDataTask_class/Reference/Reference.html">NSURLSessionDataTask</a>（在iOS7中加入）从URL取数据。你会在以后添加的数据解析。</li>
<li>一旦订阅了信号，启动网络请求。</li>
<li>创建并返回<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACDisposable.h">RACDisposable</a>对象，它处理当信号摧毁时的清理工作。</li>
<li>增加了一个“side effect”，以记录发生的任何错误。side effect不订阅信号，相反，他们返回被连接到方法链的信号。你只需添加一个side effect来记录错误。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>如果你觉得需要更多一些背景知识，看看由Ash Furrow编写的[这篇文章](http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/)，以便更好地了解ReactiveCocoa的核心概念。</span></code></pre></td></tr></table></div></figure>


<p>在<code>-fetchJSONFromURL:</code>中找到<code>// TODO: Handle retrieved data</code> ，替换为:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (! error) {
</span><span class='line'>    NSError *jsonError = nil;
</span><span class='line'>    id json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&jsonError];
</span><span class='line'>    if (! jsonError) {
</span><span class='line'>        // 1
</span><span class='line'>        [subscriber sendNext:json];
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        // 2
</span><span class='line'>        [subscriber sendError:jsonError];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>else {
</span><span class='line'>    // 2
</span><span class='line'>    [subscriber sendError:error];
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 3
</span><span class='line'>[subscriber sendCompleted];</span></code></pre></td></tr></table></div></figure>


<ol>
<li>当JSON数据存在并且没有错误，发送给订阅者序列化后的JSON数组或字典。</li>
<li>在任一情况下如果有一个错误，通知订阅者。</li>
<li>无论该请求成功还是失败，通知订阅者请求已经完成。</li>
</ol>


<p><code>-fetchJSONFromURL：</code>方法有点长，但它使你的特定的API请求方法变得很简单。</p>

<h2>获取当前状况</h2>

<p>还在<code>WXClient.m</code>中，添加如下方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (RACSignal *)fetchCurrentConditionsForLocation:(CLLocationCoordinate2D)coordinate {
</span><span class='line'>    // 1
</span><span class='line'>    NSString *urlString = [NSString stringWithFormat:@"http://api.openweathermap.org/data/2.5/weather?lat=%f&lon=%f&units=imperial",coordinate.latitude, coordinate.longitude];
</span><span class='line'>    NSURL *url = [NSURL URLWithString:urlString];
</span><span class='line'> 
</span><span class='line'>    // 2
</span><span class='line'>    return [[self fetchJSONFromURL:url] map:^(NSDictionary *json) {
</span><span class='line'>        // 3
</span><span class='line'>        return [MTLJSONAdapter modelOfClass:[WXCondition class] fromJSONDictionary:json error:nil];
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>使用<code>CLLocationCoordinate2D</code>对象的经纬度数据来格式化URL。</li>
<li>用你刚刚建立的创建信号的方法。由于返回值是一个信号，你可以调用其他ReactiveCocoa的方法。 在这里，您将返回值映射到一个不同的值 - 一个NSDictionary实例。</li>
<li>使用<code>MTLJSONAdapter</code>来转换JSON到<code>WXCondition</code>对象 - 使用<code>MTLJSONSerializing</code>协议创建的<code>WXCondition</code>。</li>
</ol>


<h2>获取逐时预报</h2>

<p>现在添加根据坐标获取逐时预报的方法到<code>WXClient.m</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (RACSignal *)fetchHourlyForecastForLocation:(CLLocationCoordinate2D)coordinate {
</span><span class='line'>    NSString *urlString = [NSString stringWithFormat:@"http://api.openweathermap.org/data/2.5/forecast?lat=%f&lon=%f&units=imperial&cnt=12",coordinate.latitude, coordinate.longitude];
</span><span class='line'>    NSURL *url = [NSURL URLWithString:urlString];
</span><span class='line'> 
</span><span class='line'>    // 1
</span><span class='line'>    return [[self fetchJSONFromURL:url] map:^(NSDictionary *json) {
</span><span class='line'>        // 2
</span><span class='line'>        RACSequence *list = [json[@"list"] rac_sequence];
</span><span class='line'> 
</span><span class='line'>        // 3
</span><span class='line'>        return [[list map:^(NSDictionary *item) {
</span><span class='line'>            // 4
</span><span class='line'>            return [MTLJSONAdapter modelOfClass:[WXCondition class] fromJSONDictionary:item error:nil];
</span><span class='line'>        // 5
</span><span class='line'>        }] array];
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>再次使用<code>-fetchJSONFromUR</code>方法，映射JSON。注意：重复使用该方法节省了多少代码！</li>
<li>使用JSON的"list"key创建<code>RACSequence</code>。 <code>RACSequences</code>让你对列表进行ReactiveCocoa操作。</li>
<li>映射新的对象列表。调用<code>-map：</code>方法，针对列表中的每个对象，返回新对象的列表。</li>
<li>再次使用<code>MTLJSONAdapter</code>来转换JSON到<code>WXCondition</code>对象。</li>
<li>使用<code>RACSequence</code>的<code>-map</code>方法，返回另一个<code>RACSequence</code>，所以用这个简便的方法来获得一个<code>NSArray</code>数据。</li>
</ol>


<h2>获取每日预报</h2>

<p>最后，添加如下方法到<code>WXClient.m</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (RACSignal *)fetchDailyForecastForLocation:(CLLocationCoordinate2D)coordinate {
</span><span class='line'>    NSString *urlString = [NSString stringWithFormat:@"http://api.openweathermap.org/data/2.5/forecast/daily?lat=%f&lon=%f&units=imperial&cnt=7",coordinate.latitude, coordinate.longitude];
</span><span class='line'>    NSURL *url = [NSURL URLWithString:urlString];
</span><span class='line'> 
</span><span class='line'>    // Use the generic fetch method and map results to convert into an array of Mantle objects
</span><span class='line'>    return [[self fetchJSONFromURL:url] map:^(NSDictionary *json) {
</span><span class='line'>        // Build a sequence from the list of raw JSON
</span><span class='line'>        RACSequence *list = [json[@"list"] rac_sequence];
</span><span class='line'> 
</span><span class='line'>        // Use a function to map results from JSON to Mantle objects
</span><span class='line'>        return [[list map:^(NSDictionary *item) {
</span><span class='line'>            return [MTLJSONAdapter modelOfClass:[WXDailyForecast class] fromJSONDictionary:item error:nil];
</span><span class='line'>        }] array];
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>是不是看起来很熟悉？是的，这个方法与<code>-fetchHourlyForecastForLocation:</code>方法非常像。除了它使用<code>WXDailyForecast</code>代替<code>WXCondition</code>，并获取每日预报。</p>

<p>构建并运行您的App，现在你不会看到任何新的东西，但这是一个很好机会松一口气，并确保没有任何错误或警告。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/built-layout.jpg" width="320" alt="Labels and Views" /></p>

<h2>管理并存储你的数据</h2>

<p>现在是时间来充实<code>WXManager</code>，这个类会把所有东西结合到一起。这个类实现您App的一些关键功能：</p>

<ul>
<li>它使用<a href="http://www.raywenderlich.com/46988/ios-design-patterns">单例设计模式</a>。</li>
<li>它试图找到设备的位置。</li>
<li>找到位置后，它获取相应的气象数据。</li>
</ul>


<p>打开<code>WXManager.h</code>使用以下代码来替换其内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@import Foundation;
</span><span class='line'>@import CoreLocation;
</span><span class='line'>#import &lt;ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h&gt;
</span><span class='line'>// 1
</span><span class='line'>#import "WXCondition.h"
</span><span class='line'> 
</span><span class='line'>@interface WXManager : NSObject
</span><span class='line'>&lt;CLLocationManagerDelegate&gt;
</span><span class='line'> 
</span><span class='line'>// 2
</span><span class='line'>+ (instancetype)sharedManager;
</span><span class='line'> 
</span><span class='line'>// 3
</span><span class='line'>@property (nonatomic, strong, readonly) CLLocation *currentLocation;
</span><span class='line'>@property (nonatomic, strong, readonly) WXCondition *currentCondition;
</span><span class='line'>@property (nonatomic, strong, readonly) NSArray *hourlyForecast;
</span><span class='line'>@property (nonatomic, strong, readonly) NSArray *dailyForecast;
</span><span class='line'> 
</span><span class='line'>// 4
</span><span class='line'>- (void)findCurrentLocation;
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<ol>
<li>请注意，你没有引入<code>WXDailyForecast.h</code>，你会始终使用<code>WXCondition</code>作为预报的类。 <code>WXDailyForecast</code>的存在是为了帮助Mantle转换JSON到Objective-C。</li>
<li>使用<code>instancetype</code>而不是<code>WXManager</code>，子类将返回适当的类型。</li>
<li>这些属性将存储您的数据。由于<code>WXManager</code>是一个单例，这些属性可以任意访问。设置公共属性为只读，因为只有管理者能更改这些值。</li>
<li>这个方法启动或刷新整个位置和天气的查找过程。</li>
</ol>


<p>现在打开<code>WXManager.m</code>并添加如下imports到文件顶部：</p>

<pre><code>#import "WXClient.h"
#import &lt;TSMessages/TSMessage.h&gt;
</code></pre>

<p>在imports下方，粘贴如下私有接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface WXManager ()
</span><span class='line'> 
</span><span class='line'>// 1
</span><span class='line'>@property (nonatomic, strong, readwrite) WXCondition *currentCondition;
</span><span class='line'>@property (nonatomic, strong, readwrite) CLLocation *currentLocation;
</span><span class='line'>@property (nonatomic, strong, readwrite) NSArray *hourlyForecast;
</span><span class='line'>@property (nonatomic, strong, readwrite) NSArray *dailyForecast;
</span><span class='line'> 
</span><span class='line'>// 2
</span><span class='line'>@property (nonatomic, strong) CLLocationManager *locationManager;
</span><span class='line'>@property (nonatomic, assign) BOOL isFirstUpdate;
</span><span class='line'>@property (nonatomic, strong) WXClient *client;
</span><span class='line'> 
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<ol>
<li>声明你在公共接口中添加的相同的属性，但是这一次把他们定义为<code>可读写</code>，因此您可以在后台更改他们。</li>
<li>为查找定位和数据抓取声明一些私有变量。</li>
</ol>


<p>添加如下通用的单例构造器到<code>@implementation</code>与<code>@end</code>å中间：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (instancetype)sharedManager {
</span><span class='line'>    static id _sharedManager = nil;
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        _sharedManager = [[self alloc] init];
</span><span class='line'>    });
</span><span class='line'> 
</span><span class='line'>    return _sharedManager;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>然后，你需要设置你的属性和观察者。</p>

<p>添加如下方法到<code>WXManager.m</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)init {
</span><span class='line'>    if (self = [super init]) {
</span><span class='line'>        // 1
</span><span class='line'>        _locationManager = [[CLLocationManager alloc] init];
</span><span class='line'>        _locationManager.delegate = self;
</span><span class='line'> 
</span><span class='line'>        // 2
</span><span class='line'>        _client = [[WXClient alloc] init];
</span><span class='line'> 
</span><span class='line'>        // 3
</span><span class='line'>        [[[[RACObserve(self, currentLocation)
</span><span class='line'>            // 4
</span><span class='line'>            ignore:nil]
</span><span class='line'>            // 5
</span><span class='line'>           // Flatten and subscribe to all 3 signals when currentLocation updates
</span><span class='line'>           flattenMap:^(CLLocation *newLocation) {
</span><span class='line'>               return [RACSignal merge:@[
</span><span class='line'>                                         [self updateCurrentConditions],
</span><span class='line'>                                         [self updateDailyForecast],
</span><span class='line'>                                         [self updateHourlyForecast]
</span><span class='line'>                                         ]];
</span><span class='line'>            // 6
</span><span class='line'>           }] deliverOn:RACScheduler.mainThreadScheduler]
</span><span class='line'>           // 7
</span><span class='line'>         subscribeError:^(NSError *error) {
</span><span class='line'>             [TSMessage showNotificationWithTitle:@"Error" 
</span><span class='line'>                                         subtitle:@"There was a problem fetching the latest weather."
</span><span class='line'>                                             type:TSMessageNotificationTypeError];
</span><span class='line'>         }];
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你正使用更多的ReactiveCocoa方法来观察和反应数值的变化。上面这些你做了：</p>

<ol>
<li>创建一个位置管理器，并设置它的delegate为<code>self</code>。</li>
<li>为管理器创建<code>WXClient</code>对象。这里处理所有的网络请求和数据分析，这是关注点分离的最佳实践。</li>
<li>管理器使用一个返回信号的ReactiveCocoa脚本来观察自身的<code>currentLocation</code>。这与<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">KVO</a>类似，但更为强大。</li>
<li>为了继续执行方法链，<code>currentLocation</code>必须不为<code>nil</code>。</li>
<li><code>- flattenMap：</code>非常类似于<code>-map：</code>，但不是映射每一个值，它把数据变得扁平，并返回包含三个信号中的一个对象。通过这种方式，你可以考虑将三个进程作为单个工作单元。</li>
<li>将信号传递给主线程上的观察者。</li>
<li>这不是很好的做法，在你的模型中进行UI交互，但出于演示的目的，每当发生错误时，会显示一个banner。</li>
</ol>


<p>接下来，为了显示准确的天气预报，我们需要确定设备的位置。</p>

<h2>查找你的位置</h2>

<p>下一步，你要添加当位置查找到，触发抓取天气数据的代码。</p>

<p>添加如下代码到<code>WXManager.m</code>的实现块中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)findCurrentLocation {
</span><span class='line'>    self.isFirstUpdate = YES;
</span><span class='line'>    [self.locationManager startUpdatingLocation];
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations {
</span><span class='line'>    // 1
</span><span class='line'>    if (self.isFirstUpdate) {
</span><span class='line'>        self.isFirstUpdate = NO;
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'> 
</span><span class='line'>    CLLocation *location = [locations lastObject];
</span><span class='line'> 
</span><span class='line'>    // 2
</span><span class='line'>    if (location.horizontalAccuracy &gt; 0) {
</span><span class='line'>        // 3
</span><span class='line'>        self.currentLocation = location;
</span><span class='line'>        [self.locationManager stopUpdatingLocation];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>忽略第一个位置更新，因为它一般是缓存值。</li>
<li>一旦你获得一定精度的位置，停止进一步的更新。</li>
<li>设置<code>currentLocation</code>，将触发您之前在init中设置的RACObservable。</li>
</ol>


<h2>获取气象数据</h2>

<p>最后，是时候添加在客户端上调用并保存数据的三个获取方法。将三个方法捆绑起来，被之前在<code>init</code>方法中添加的RACObservable订阅。您将返回客户端返回的，能被订阅的，相同的信号。</p>

<p>所有的属性设置发生在<code>-doNext:</code>中。</p>

<p>添加如下代码到<code>WXManager.m</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (RACSignal *)updateCurrentConditions {
</span><span class='line'>    return [[self.client fetchCurrentConditionsForLocation:self.currentLocation.coordinate] doNext:^(WXCondition *condition) {
</span><span class='line'>        self.currentCondition = condition;
</span><span class='line'>    }];
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>- (RACSignal *)updateHourlyForecast {
</span><span class='line'>    return [[self.client fetchHourlyForecastForLocation:self.currentLocation.coordinate] doNext:^(NSArray *conditions) {
</span><span class='line'>        self.hourlyForecast = conditions;
</span><span class='line'>    }];
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>- (RACSignal *)updateDailyForecast {
</span><span class='line'>    return [[self.client fetchDailyForecastForLocation:self.currentLocation.coordinate] doNext:^(NSArray *conditions) {
</span><span class='line'>        self.dailyForecast = conditions;
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>它看起来像将一切都连接起来，并蓄势待发。别急！这App实际上并没有告诉管理者做任何事情。
打开<code>WXController.m</code>并导入这管理者到文件的顶部，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import "WXManager.h"</span></code></pre></td></tr></table></div></figure>


<p>添加如下代码到<code>-viewDidLoad:</code>的最后:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[WXManager sharedManager] findCurrentLocation];</span></code></pre></td></tr></table></div></figure>


<p>这告诉管理类，开始寻找设备的当前位置。</p>

<p>构建并运行您的App，系统会提示您是否允许使用位置服务。你仍然不会看到任何UI的更新，但检查控制台日志，你会看到类似以下内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2013-11-05 08:38:48.886 WeatherTutorial[17097:70b] Fetching: http://api.openweathermap.org/data/2.5/weather?lat=37.785834&lon=-122.406417&units=imperial
</span><span class='line'>2013-11-05 08:38:48.886 WeatherTutorial[17097:70b] Fetching: http://api.openweathermap.org/data/2.5/forecast/daily?lat=37.785834&lon=-122.406417&units=imperial&cnt=7
</span><span class='line'>2013-11-05 08:38:48.886 WeatherTutorial[17097:70b] Fetching: http://api.openweathermap.org/data/2.5/forecast?lat=37.785834&lon=-122.406417&units=imperial&cnt=12</span></code></pre></td></tr></table></div></figure>


<p>这些输出代表你的代码工作正常，网络请求正常执行。</p>

<h2>连接接口</h2>

<p>这是最后一次展示所有获取，映射和存储的数据。您将使用ReactiveCocoa来观察<code>WXManager</code>单例的变化和当新数据到达时更新界面。</p>

<p>还在<code>WXController.m</code>，到<code>- viewDidLoad</code>的底部，并添加下面的代码到<code>[[WXManager sharedManager] findCurrentLocation];</code>之前：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>[[RACObserve([WXManager sharedManager], currentCondition)
</span><span class='line'>  // 2
</span><span class='line'>  deliverOn:RACScheduler.mainThreadScheduler]
</span><span class='line'> subscribeNext:^(WXCondition *newCondition) {
</span><span class='line'>     // 3
</span><span class='line'>     temperatureLabel.text = [NSString stringWithFormat:@"%.0f°",newCondition.temperature.floatValue];
</span><span class='line'>     conditionsLabel.text = [newCondition.condition capitalizedString];
</span><span class='line'>     cityLabel.text = [newCondition.locationName capitalizedString];
</span><span class='line'> 
</span><span class='line'>     // 4
</span><span class='line'>     iconView.image = [UIImage imageNamed:[newCondition imageName]];
</span><span class='line'> }];</span></code></pre></td></tr></table></div></figure>


<ol>
<li>观察<code>WXManager</code>单例的currentCondition。</li>
<li>传递在主线程上的任何变化，因为你正在更新UI。</li>
<li>使用气象数据更新文本标签；你为文本标签使用<code>newCondition</code>的数据，而不是单例。订阅者的参数保证是最新值。</li>
<li>使用映射的图像文件名来创建一个图像，并将其设置为视图的图标。</li>
</ol>


<p>构建并运行您的App，你会看到当前温度，当前状况和表示当前状况的图标。所有的数据都是实时的。但是，如果你的位置是旧金山，它似乎总是约65度。Lucky San Franciscans! :]</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/11/ui-wiring.jpg" width="320" alt="Wiring up the UI" /></p>

<h2>ReactiveCocoa的绑定</h2>

<p>ReactiveCocoa为iOS带来了自己的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html">Cocoa绑定</a>的形式。</p>

<p>不知道是什么绑定？简而言之，他们是一种提供了保持模型和视图的数据同步而无需编写大量"胶水代码"的手段，它们允许你建立一个视图和数据块之间的连接， “结合”它们，使得一方的变化反映到另一个中的技术。</p>

<p>这是一个非常强大的概念，不是吗？</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>注意：要获得更多的绑定实例代码，请查看[ReactiveCocoa Readme](https://github.com/ReactiveCocoa/ReactiveCocoa)。</span></code></pre></td></tr></table></div></figure>


<p>添加如下代码到你上一步添加的代码后面：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>RAC(hiloLabel, text) = [[RACSignal combineLatest:@[
</span><span class='line'>                        // 2
</span><span class='line'>                        RACObserve([WXManager sharedManager], currentCondition.tempHigh),
</span><span class='line'>                        RACObserve([WXManager sharedManager], currentCondition.tempLow)]
</span><span class='line'>                        // 3
</span><span class='line'>                        reduce:^(NSNumber *hi, NSNumber *low) {
</span><span class='line'>                            return [NSString  stringWithFormat:@"%.0f° / %.0f°",hi.floatValue,low.floatValue];
</span><span class='line'>                        }]
</span><span class='line'>                        // 4
</span><span class='line'>                        deliverOn:RACScheduler.mainThreadScheduler];</span></code></pre></td></tr></table></div></figure>


<p>上面的代码结合高温、低温的值到hiloLabel的text属性。看看你完成了什么：</p>

<ol>
<li>RAC（&hellip;）宏有助于保持语法整洁。从该信号的返回值将被分配给<code>hiloLabel</code>对象的<code>text</code>。</li>
<li>观察<code>currentCondition</code>的高温和低温。合并信号，并使用两者最新的值。当任一数据变化时，信号就会触发。</li>
<li>从合并的信号中，减少数值，转换成一个单一的数据，注意参数的顺序与信号的顺序相匹配。</li>
<li>同样，因为你正在处理UI界面，所以把所有东西都传递到主线程。</li>
</ol>


<p>构建并运行你的App。你应该看到在左下方的高/低温度label更新了：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/11/ui-wiring-hilo.jpg" width="320" alt="UI Wiring with Bindings" /></p>

<h2>在Table View中显示数据</h2>

<p>现在，你已经获取所有的数据，你可以在table view中整齐地显示出来。你会在分页的table view中显示最近6小时的每时播报和每日预报。该App会显示三个页面：一个是当前状况，一个是逐时预报，以及一个每日预报。</p>

<p>之前，你可以添加单元格到table view，你需要初始化和配置一些日期格式化。</p>

<p>到<code>WXController.m</code>最顶端的私有接口处，添加下列两个属性</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property (nonatomic, strong) NSDateFormatter *hourlyFormatter;
</span><span class='line'>@property (nonatomic, strong) NSDateFormatter *dailyFormatter;</span></code></pre></td></tr></table></div></figure>


<p>由于创建日期格式化非常昂贵，我们将在init方法中实例化他们，并使用这些变量去存储他们的引用。</p>

<p>还在<code>WXController.m</code>中，添加如下代码到<code>@implementation</code>中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (id)init {
</span><span class='line'>    if (self = [super init]) {
</span><span class='line'>        _hourlyFormatter = [[NSDateFormatter alloc] init];
</span><span class='line'>        _hourlyFormatter.dateFormat = @"h a";
</span><span class='line'> 
</span><span class='line'>        _dailyFormatter = [[NSDateFormatter alloc] init];
</span><span class='line'>        _dailyFormatter.dateFormat = @"EEEE";
</span><span class='line'>    }
</span><span class='line'>    return self;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>你可能想知道为什么在<code>-init</code>中初始化这些日期格式化，而不是在<code>-viewDidLoad</code>中初始化他们。好问题！</p>

<p>实际上<code>-viewDidLoad</code>可以在一个视图控制器的生命周期中多次调用。 <a href="http://www.rsaunders.co.uk/2012/02/nsdateformatter-are-expensive.html">NSDateFormatter对象的初始化是昂贵的</a>，而将它们放置在你的<code>-init</code>，会确保被你的视图控制器初始化一次。</p>

<p>在<code>WXController.m</code>中，寻找<code>tableView:numberOfRowsInSection：</code>,并用如下代码更换<code>TODO</code>到<code>return</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>if (section == 0) {
</span><span class='line'>    return MIN([[WXManager sharedManager].hourlyForecast count], 6) + 1;
</span><span class='line'>}
</span><span class='line'>// 2
</span><span class='line'>return MIN([[WXManager sharedManager].dailyForecast count], 6) + 1;</span></code></pre></td></tr></table></div></figure>


<ol>
<li>第一部分是对的逐时预报。使用最近6小时的预预报，并添加了一个作为页眉的单元格。</li>
<li>接下来的部分是每日预报。使用最近6天的每日预报，并添加了一个作为页眉的单元格。</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>注意：您使用表格单元格作为标题，而不是内置的、具有粘性的滚动行为的标题。这个table view设置了分页，粘性滚动行为看起来会很奇怪。</span></code></pre></td></tr></table></div></figure>


<p>在<code>WXController.m</code>找到<code>tableView:cellForRowAtIndexPath:</code>,并用如下代码更换<code>TODO</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (indexPath.section == 0) {
</span><span class='line'>    // 1
</span><span class='line'>    if (indexPath.row == 0) {
</span><span class='line'>        [self configureHeaderCell:cell title:@"Hourly Forecast"];
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        // 2
</span><span class='line'>        WXCondition *weather = [WXManager sharedManager].hourlyForecast[indexPath.row - 1];
</span><span class='line'>        [self configureHourlyCell:cell weather:weather];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>else if (indexPath.section == 1) {
</span><span class='line'>    // 1
</span><span class='line'>    if (indexPath.row == 0) {
</span><span class='line'>        [self configureHeaderCell:cell title:@"Daily Forecast"];
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        // 3
</span><span class='line'>        WXCondition *weather = [WXManager sharedManager].dailyForecast[indexPath.row - 1];
</span><span class='line'>        [self configureDailyCell:cell weather:weather];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>每个部分的第一行是标题单元格。</li>
<li>获取每小时的天气和使用自定义配置方法配置cell。</li>
<li>获取每天的天气，并使用另一个自定义配置方法配置cell。</li>
</ol>


<p>最后，添加如下代码到<code>WXController.m</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 1
</span><span class='line'>- (void)configureHeaderCell:(UITableViewCell *)cell title:(NSString *)title {
</span><span class='line'>    cell.textLabel.font = [UIFont fontWithName:@"HelveticaNeue-Medium" size:18];
</span><span class='line'>    cell.textLabel.text = title;
</span><span class='line'>    cell.detailTextLabel.text = @"";
</span><span class='line'>    cell.imageView.image = nil;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 2
</span><span class='line'>- (void)configureHourlyCell:(UITableViewCell *)cell weather:(WXCondition *)weather {
</span><span class='line'>    cell.textLabel.font = [UIFont fontWithName:@"HelveticaNeue-Light" size:18];
</span><span class='line'>    cell.detailTextLabel.font = [UIFont fontWithName:@"HelveticaNeue-Medium" size:18];
</span><span class='line'>    cell.textLabel.text = [self.hourlyFormatter stringFromDate:weather.date];
</span><span class='line'>    cell.detailTextLabel.text = [NSString stringWithFormat:@"%.0f°",weather.temperature.floatValue];
</span><span class='line'>    cell.imageView.image = [UIImage imageNamed:[weather imageName]];
</span><span class='line'>    cell.imageView.contentMode = UIViewContentModeScaleAspectFit;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>// 3
</span><span class='line'>- (void)configureDailyCell:(UITableViewCell *)cell weather:(WXCondition *)weather {
</span><span class='line'>    cell.textLabel.font = [UIFont fontWithName:@"HelveticaNeue-Light" size:18];
</span><span class='line'>    cell.detailTextLabel.font = [UIFont fontWithName:@"HelveticaNeue-Medium" size:18];
</span><span class='line'>    cell.textLabel.text = [self.dailyFormatter stringFromDate:weather.date];
</span><span class='line'>    cell.detailTextLabel.text = [NSString stringWithFormat:@"%.0f° / %.0f°",
</span><span class='line'>                                  weather.tempHigh.floatValue,
</span><span class='line'>                                  weather.tempLow.floatValue];
</span><span class='line'>    cell.imageView.image = [UIImage imageNamed:[weather imageName]];
</span><span class='line'>    cell.imageView.contentMode = UIViewContentModeScaleAspectFit;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>配置和添加文本到作为section页眉单元格。你会重用此为每日每时的预测部分。</li>
<li>格式化逐时预报的单元格。</li>
<li>格式化每日预报的单元格。</li>
</ol>


<p>构建并运行您的App，尝试滚动你的table view，并&hellip;等一下。什么都没显示！怎么办？</p>

<p>如果你已经使用过的<code>UITableView</code>，可能你之前遇到过问题。这个table没有重新加载！</p>

<p>为了解决这个问题，你需要添加另一个针对每时预报和每日预报属性的ReactiveCocoa观察。</p>

<p>在<code>WXController.m</code>的<code>-viewDidLoad</code>中，添加下列代码到其他ReactiveCocoa观察代码中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[RACObserve([WXManager sharedManager], hourlyForecast)
</span><span class='line'>       deliverOn:RACScheduler.mainThreadScheduler]
</span><span class='line'>   subscribeNext:^(NSArray *newForecast) {
</span><span class='line'>       [self.tableView reloadData];
</span><span class='line'>   }];
</span><span class='line'> 
</span><span class='line'>[[RACObserve([WXManager sharedManager], dailyForecast)
</span><span class='line'>       deliverOn:RACScheduler.mainThreadScheduler]
</span><span class='line'>   subscribeNext:^(NSArray *newForecast) {
</span><span class='line'>       [self.tableView reloadData];
</span><span class='line'>   }];</span></code></pre></td></tr></table></div></figure>


<p>构建并运行App；滚动table view，你将看到填充的所有预报数据。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/unaligned-heights.jpg" width="320" alt="Forecast with Odd Heights" /></p>

<h2>给你的App添加效果</h2>

<p>本页面为每时和每日预报不会占满整个屏幕。幸运的是，有一个非常简单的修复办法。在本教程前期，您在<code>-viewDidLoad</code>中获得屏幕高度。</p>

<p>在<code>WXController.m</code>中，查找table view的委托方法<code>-tableView:heightForRowAtIndexPath:</code>，并且替换<code>TODO</code>到<code>return</code>的代码:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSInteger cellCount = [self tableView:tableView numberOfRowsInSection:indexPath.section];
</span><span class='line'>return self.screenHeight / (CGFloat)cellCount;</span></code></pre></td></tr></table></div></figure>


<p>屏幕高度由一定数量的cell所分割，所以所有cell的总高度等于屏幕的高度。</p>

<p>构建并运行你的App；table view填满了整个屏幕，如下所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/11/aligned-heights.jpg" width="320" alt="Forecast with Full Height" /></p>

<p>最后要做的是把我在本教程的第一部分开头提到的模糊效果引入。当你滚动预报页面，模糊效果应该动态显示。</p>

<p>添加下列scroll delegate到<code>WXController.m</code>最底部：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#pragma mark - UIScrollViewDelegate
</span><span class='line'> 
</span><span class='line'>- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
</span><span class='line'>    // 1
</span><span class='line'>    CGFloat height = scrollView.bounds.size.height;
</span><span class='line'>    CGFloat position = MAX(scrollView.contentOffset.y, 0.0);
</span><span class='line'>    // 2
</span><span class='line'>    CGFloat percent = MIN(position / height, 1.0);
</span><span class='line'>    // 3
</span><span class='line'>    self.blurredImageView.alpha = percent;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ol>
<li>获取滚动视图的高度和内容偏移量。与0偏移量做比较，因此试图滚动table低于初始位置将不会影响模糊效果。</li>
<li>偏移量除以高度，并且最大值为1，所以alpha上限为1。</li>
<li>当你滚动的时候，把结果值赋给模糊图像的alpha属性，来更改模糊图像。</li>
</ol>


<p>构建并运行App，滚动你的table view，并查看这令人惊异的模糊效果：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/11/with-blur.jpg" width="320" alt="Finished Product" /></p>

<h2>何去何从？</h2>

<p>在本教程中你已经完成了很多内容：您使用CocoaPods创建了一个项目，完全用代码书写了一个视图结构，创建数据模型和管理类，并使用函数式编程将他们连接到一起！</p>

<p>您可以从<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/11/SimpleWeather-Part-2.zip">这里下载</a>该项目的完成版本。</p>

<p>这个App还有很多酷的东西可以去做。一个好的开始是使用<a href="http://www.flickr.com/services/api/">Flickr API</a>来查找基于设备位置的背景图像。</p>

<p>还有，你的应用程序只处理温度和状态;有什么其他的天气信息能融入你的App？</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">sjpsega</span></span>

      




<time class='entry-date' datetime='2014-02-15T16:46:02+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>4:46 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/study/'>study</a>
  
</span>


    </p>
    <p class="meta">
      版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">CC BY-NC-ND 3.0</a>
    </p>
    
      <div class="sharing">
  
  
  
  
      <!--jiathis与友言-->
<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=1891960" charset="utf-8"></script>
<!-- JiaThis Button END -->
<!-- UY BEGIN -->
<script type="text/javascript">
var uyan_config = {
   'du':'sjpsega.com'
};
</script>
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1891960"></script>
<!-- UY END -->
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/02/11/yi--ios-7-best-practices-part-1/" title="Previous Post: [译]iOS7最佳实践：一个天气App案例(一)">&laquo; [译]iOS7最佳实践：一个天气App案例(一)</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/03/08/js-communicate-with-native-in-iOS/" title="Next Post: iOS js与native相互通信">iOS js与native相互通信 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2020/07/04/2020midyear-invest-summary/">2020 年中投资总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2020/02/15/2019summary/">2019 年终总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2020/02/09/soho/">SOHO 工作一周的感受</a>
      </li>
    
      <li class="post">
        <a href="/blog/2020/01/10/putitdown/">放下</a>
      </li>
    
      <li class="post">
        <a href="/blog/2020/01/01/2020-invest-summary/">2019 年投资总结</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>About Me</h1>
  <p>程序员</p>
  <p>技术经历：As -> Js -> iOS</p>
  <p>新浪微博：<a href="http://weibo.com/sjpsega">IORI_YAGAMI_7</a></p>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2020 - sjpsega -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  









<!--cnzz统计-->
<script src="http://s13.cnzz.com/stat.php?id=5808684&web_id=5808684" language="JavaScript"></script>

</body>
</html>
