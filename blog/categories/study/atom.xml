<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | sjpsega's Blog]]></title>
  <link href="http://sjpsega.com/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://sjpsega.com/"/>
  <updated>2014-07-05T22:08:17+08:00</updated>
  <id>http://sjpsega.com/</id>
  <author>
    <name><![CDATA[sjpsega]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARC学习笔记]]></title>
    <link href="http://sjpsega.com/blog/2014/06/25/arc-note/"/>
    <updated>2014-06-25T00:50:28+08:00</updated>
    <id>http://sjpsega.com/blog/2014/06/25/arc-note</id>
    <content type="html"><![CDATA[<h2>ARC执行新规则</h2>

<ul>
<li>开发者不能显示调用 <code>dealloc</code>；不能实现和调用 retain、release、retainCount 和 autorelease。</li>
<li>不能使用 NSAllocateObject 或者 NSDeallocateObject 。开发者创建对象使用alloc，运行时环境负责销毁对象。</li>
<li>在 C 数据结构中，不能使用对象指针。可以使用 OC 类来代替 C 的 struct。</li>
<li>id 和 void * 没有自动转换。</li>
<li>开发者不能使用 NSAutoreleasePool 对象。ARC 下使用 @autoreleasepool，它比 NSAtuoreleasePool 更有效率。</li>
<li>开发者不能使用内存zones。不用再使用 NSZone 了。</li>
</ul>


<p>为了配合手动引用计数，ARC 的方法命名有限制：
* 访问器方法不能以 new 开头，开发者不能声明一个以 new 开头的属性，除非你给你指定一个getter：</p>

<p>```objc
// Won&rsquo;t work:
@property NSString *newTitle;</p>

<p>// Works:
@property (getter=theNewTitle) NSString *newTitle;
```</p>

<h2>ARC引入新的生命周期修饰符</h2>

<h3>变量修饰符</h3>

<ul>
<li><code>__strong</code> 是默认的，只要对象还有强引用，他就一直存在。</li>
<li><code>__weak</code> 指向一个不会保持被引用对象一直存在的引用。当没有强引用指向它，弱引用将被设置为 nil。</li>
<li><code>__unsafe_unretained</code> 指向一个不会保持被引用对象一直存在的引用，它<code>不会</code>被设置为 nil，当没有强引用指向它。如果它引用的对象被释放，指针会变成野指针。</li>
<li><code>__autoreleasing</code> 用于标识id *的引用参数，并且在返回的时候自动释放。</li>
</ul>


<h3>使用生命周期修饰符，避免循环引用</h3>

<p>在MRC下，<code>__block id x;</code>这样的写法，不会对x进行retain。</p>

<p>在ARC下，<code>__block id x;</code>默认retain x（就像其他变量一样）。</p>

<p>如果想在ARC模式下，得到手动引用计数的效果，开发者可以使用<code>__unsafe_unretained __block id x;</code>。顾名思义，<code>__unsafe_unretained是危险的</code>(因为他可能导致野指针)，因此也不建议使用。<code>好的解决方案是：使用__weak或者将__block的值设置为nil，来打断retain循环</code>。</p>

<ul>
<li><p>使用 <code>__block</code> ，然后设置为 <code>nil</code>：
<code>objc
MyViewController * __block myController = [[MyViewController alloc] init…];
// ...
myController.completionHandler =  ^(NSInteger result) {
  [myController dismissViewControllerAnimated:YES completion:nil];
  myController = nil;
};
</code></p></li>
<li><p>使用 <code>__weak</code> 修饰符 ：
<code>objc
MyViewController *myController = [[MyViewController alloc] init…];
// ...
MyViewController * __weak weakMyViewController = myController;
myController.completionHandler =  ^(NSInteger result) {
  [weakMyViewController dismissViewControllerAnimated:YES completion:nil];
};
</code></p></li>
<li><p>对于复杂场景：
<code>objc
MyViewController *myController = [[MyViewController alloc] init…];
// ...
MyViewController * __weak weakMyController = myController;
myController.completionHandler =  ^(NSInteger result) {
  MyViewController *strongMyController = weakMyController;
  if (strongMyController) {
      // ...
      [strongMyController dismissViewControllerAnimated:YES completion:nil];
      // ...
  }
  else {
      // Probably nothing...
  }
};
</code></p></li>
</ul>


<h2>相关资料</h2>

<p><a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes</a></p>

<p><a href="http://www.cocoachina.com/applenews/devnews/2013/1209/7497.html">转向ARC的说明</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《#2 并发编程》 学习笔记]]></title>
    <link href="http://sjpsega.com/blog/2014/06/12/concurrent-programming-note/"/>
    <updated>2014-06-12T12:49:46+08:00</updated>
    <id>http://sjpsega.com/blog/2014/06/12/concurrent-programming-note</id>
    <content type="html"><![CDATA[<p>文章地址：<a href="http://objccn.io/issue-2/">objc第二章</a></p>

<h2>并发编程：API 及挑战</h2>

<h3>OS X 和 iOS 中的并发编程</h3>

<h4>Grand Central Dispatch(GCD)</h4>

<p>GCD 在后端管理着一个线程池，可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。在日常开发中，最好使用 GCD 来做线程方面的工作。</p>

<p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）</p>

<p>使用不同优先级的若干个队列乍听起来非常直接，不过，我们强烈建议，<code>在绝大多数情况下使用默认的优先级队列就可以了</code>。</p>

<p><img src="http://img.objccn.io/issue-2/gcd-queues.png" alt="http://img.objccn.io/issue-2/gcd-queues.png" /></p>

<h4>Operation Queues</h4>

<p>操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。GCD 提供了更加底层的控制，而操作队列则在 GCD 之上实现了一些方便的功能，这些功能对于 app 的开发者来说通常是最好最安全的选择。</p>

<p><code>NSOperationQueue</code> 有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 <code>NSOperation</code> 的子类来表述。</p>

<h4>Run Loops</h4>

<p>Run loop并不像 GCD 或者操作队列那样是一种并发机制，因为它并不能并行执行任务。不过在主 dispatch/operation 队列中， run loop 将直接配合任务的执行，它提供了一种异步执行代码的机制。</p>

<p>Run loop 比起操作队列或者 GCD 来说容易使用得多，因为通过 run loop ，你不必处理并发中的复杂情况，就能异步地执行任务。</p>

<h3>并发编程中面临的挑战</h3>

<h4>资源共享</h4>

<p>并发编程中许多问题的根源就是在多线程中访问共享资源。</p>

<p>在多线程中任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计以防止这种冲突的发生。</p>

<p>为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。</p>

<h4>互斥锁</h4>

<p>互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。</p>

<p>从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。</p>

<h4>死锁</h4>

<p>互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。</p>

<h4>资源饥饿（Starvation）</h4>

<p>大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致资源饥饿的发生。</p>

<h4>优先级反转</h4>

<p>优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。</p>

<p>解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。<code>当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）</code>。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。</p>

<h3>总结</h3>

<p>建议采纳的安全模式：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。</p>

<h2>常见的后台实践</h2>

<h3>操作队列 (Operation Queues) 还是 GCD ?</h3>

<p><code>GCD 是基于 C 的底层的 API ，而操作队列则是 GCD 实现的 Objective-C API。</code></p>

<p><code>操作队列可以取消在任务处理队列中的任务</code>，而在 GCD 中不容易实现。</p>

<h4>后台的 Core Data</h4>

<p><code>Core Data</code>不熟悉</p>

<h3>后台 UI 代码</h3>

<p><code>UIKit 只能在主线程上运行。</code>而那部分不与 UIKit 直接相关，却会消耗大量时间的 UI 代码可以被移动到后台去处理。</p>

<h3>异步网络请求处理</h3>

<ul>
<li>所有网络请求都应该采取异步的方式完成。</li>
<li>可以使用 <code>NSURLConnection</code> 的异步方法，并且把所有操作转化为 operation 来执行。通过这种方法，我们可以从操作队列的强大功能和便利中获益良多：我们能轻易地控制并发操作的数量，添加依赖，以及取消操作。</li>
<li>使用像 <a href="http://afnetworking.com/">AFNetworking</a> 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。但是并不推荐你自己去实现这些事情。</li>
</ul>


<h3>进阶：后台文件 I/O</h3>

<p>大体上逐行读取一个文件的模式是这样的：</p>

<ol>
<li>建立一个中间缓冲层以提供，当没有找到换行符号的时候可以向其中添加数据</li>
<li>从 stream 中读取一块数据</li>
<li>对于这块数据中发现的每一个换行符，取中间缓冲层，向其中添加数据，直到（并包括）这个换行符，并将其输出</li>
<li>将剩余的字节添加到中间缓冲层去</li>
<li>回到 2，直到 stream 关闭</li>
</ol>


<h3>总结</h3>

<p>在主队列中接收事件或者数据，然后用后台操作队列来执行实际操作，然后回到主队列去传递结果，遵循这样的原则来编写尽量简单的并行代码，将是保证高效正确的不二法则。</p>

<h2>底层并发 API</h2>

<h3>dispatch_once</h3>

<p>```objc
+ (UIColor *)boringColor;
{</p>

<pre><code>static UIColor *color;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f];
});
return color;
</code></pre>

<p>}
<code>``
上面的 block 只会运行一次。并且在连续的调用中，这种检查是很高效的。你能使用它来初始化全局数据比如单例。要注意的是，使用</code>dispatch_once_t` 会使得测试变得非常困难（单例和测试不是很好配合）。</p>

<p><code>要确保 onceToken 被声明为 static ，或者有全局作用域。任何其他的情况都会导致无法预知的行为。</code></p>

<h3>dispatch_after</h3>

<p>它使工作延后执行。它是很强大的，但是要注意：你很容易就陷入到一堆麻烦中。
```objc
&ndash; (void)foo
{</p>

<pre><code>double delayInSeconds = 2.0;
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));
dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
    [self bar];
});
</code></pre>

<p>}
<code>``
这里存在一些缺点。我们</code>不能（直接）取消我们已经提交到 dispatch_after 的代码，它将会运行`。</p>

<p>如果你需要一些事情在某个特定的时刻运行，那么 <code>dispatch_after</code> 或许会是个好的选择。确保同时考虑了 <code>NSTimer</code>，这个API虽然有点笨重，但是它<code>允许你取消定时器的触发</code>。</p>

<h3>队列</h3>

<p>GCD 中一个基本的代码块就是队列。</p>

<p>```objc
&ndash; (id)init
{</p>

<pre><code>self = [super init];
if (self != nil) {
    NSString *label = [NSString stringWithFormat:@"%@.isolation.%p", [self class], self];
    self.isolationQueue = dispatch_queue_create([label UTF8String], 0);

    label = [NSString stringWithFormat:@"%@.work.%p", [self class], self];
    self.workQueue = dispatch_queue_create([label UTF8String], 0);
}
return self;
</code></pre>

<p>}
```</p>

<p>队列可以是并行也可以是串行的，也可以是并行的。默认情况下，是串行的。</p>

<p>GCD 队列的内部使用的是线程。</p>

<h4>目标队列</h4>

<p>你能够为你创建的任何一个队列设置一个目标队列。</p>

<p>为一个类创建它自己的队列而不是使用全局的队列被普遍认为是一种好的风格。这种方式下，你可以设置队列的名字，这让调试变得轻松许多—— Xcode 可以让你在 Debug Navigator 中看到所有的队列名字，如果你直接使用 lldb。(lldb) thread list 命令将会在控制台打印出所有队列的名字。一旦你使用大量的异步内容，这会是非常有用的帮助。</p>

<h3>隔离</h3>

<h4>资源保护</h4>

<p>多线程编程中，最常见的情形是你有一个资源，每次只有一个线程被允许访问这个资源。</p>

<h4>全都使用异步分发</h4>

<h4>如何写出好的异步 API</h4>

<p>如果你的方法或函数有一个返回值，异步地将其传递给一个回调处理程序。这个 API 应该是这样的，你的方法或函数同时持有一个结果 block 和一个将结果传递过去的队列。
```objc
&ndash; (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;
{</p>

<pre><code>dispatch_async(self.isolationQueue, ^(void){
    // do actual processing here
    dispatch_async(self.resultQueue, ^(void){
        handler(YES);
    });
});
</code></pre>

<p>}
```</p>

<h3>迭代执行</h3>

<p>dispatch_apply
```objc
for (size_t y = 0; y &lt; height; ++y) {</p>

<pre><code>for (size_t x = 0; x &lt; width; ++x) {
    // Do something with x and y here
}
</code></pre>

<p>}
```</p>

<p>小小的改动或许就可以让它运行的更快：
```objc
dispatch_apply(height, dispatch_get_global_queue(0, 0), ^(size_t y) {</p>

<pre><code>for (size_t x = 0; x &lt; width; x += 2) {
    // Do something with x and y here
}
</code></pre>

<p>});
```</p>

<h3>组</h3>

<p>```objc
dispatch_group_t group = dispatch_group_create();</p>

<p>dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
dispatch_group_async(group, queue, ^(){</p>

<pre><code>// Do something that takes a while
[self doSomeFoo];
dispatch_group_async(group, dispatch_get_main_queue(), ^(){
    self.foo = 42;
});
</code></pre>

<p>});
dispatch_group_async(group, queue, ^(){</p>

<pre><code>// Do something else that takes a while
[self doSomeBar];
dispatch_group_async(group, dispatch_get_main_queue(), ^(){
    self.bar = 1;
});
</code></pre>

<p>});</p>

<p>// This block will run once everything above is done:
dispatch_group_notify(group, dispatch_get_main_queue(), ^(){</p>

<pre><code>NSLog(@"foo: %d", self.foo);
NSLog(@"bar: %d", self.bar);
</code></pre>

<p>});
```</p>

<h4>对现有API使用 dispatch_group_t</h4>

<p>```objc
+ (void)withGroup:(dispatch_group_t)group</p>

<pre><code>    sendAsynchronousRequest:(NSURLRequest *)request 
    queue:(NSOperationQueue *)queue 
    completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler
</code></pre>

<p>{</p>

<pre><code>if (group == NULL) {
    [self sendAsynchronousRequest:request 
                            queue:queue 
                completionHandler:handler];
} else {
    dispatch_group_enter(group);
    [self sendAsynchronousRequest:request 
                            queue:queue 
                completionHandler:^(NSURLResponse *response, NSData *data, NSError *error){
        handler(response, data, error);
        dispatch_group_leave(group);
    }];
}
</code></pre>

<p>}
```
为了能正常工作，你需要确保:
* dispatch_group_enter() 必须要在 dispatch_group_leave()之前运行。
* dispatch_group_enter() 和 dispatch_group_leave() 一直是成对出现的。</p>

<h3>事件源</h3>

<p>GCD 有一个较少人知道的特性：事件源 <code>dispatch_source_t</code>。</p>

<p>当你需要用到它时，它会变得极其有用。它的一些使用是秘传招数，我们将会接触到一部分的使用。但是大部分事件源在 iOS 平台不是很有用，因为在 iOS 平台有诸多限制，你无法启动进程（因此就没有必要监视进程），也不能在你的 app bundle 之外写数据（因此也就没有必要去监视文件）等等。</p>

<p>GCD 事件源是以极其资源高效的方式实现的。</p>

<h4>监视进程</h4>

<h4>监视文件</h4>

<h4>定时器</h4>

<h4>取消</h4>

<h3>输入输出</h3>

<p>写出能够在繁重的 I/O 处理情况下运行良好的代码是一件非常棘手的事情。</p>

<h4>GCD 和缓冲区</h4>

<p>最直接了当的方法是使用数据缓冲区。GCD 有一个 <code>dispatch_data_t</code> 类型，在某种程度上和 Objective-C 的 NSData 类型很相似。但是它能做别的事情，而且更通用。</p>

<h4>读和写</h4>

<p>在 GCD 的核心里，调度 I/O（译注：原文为 Dispatch I/O） 与所谓的通道有关。调度 I/O 通道提供了一种与从文件描述符中读写不同的方式。</p>

<h3>基准测试</h3>

<p>能够测量给定的代码执行的平均的纳秒数。
<code>objc
uint64_t dispatch_benchmark(size_t count, void (^block)(void));
</code></p>

<h3>原子操作</h3>

<p>头文件 <code>libkern/OSAtomic.h</code> 里有许多强大的函数，专门用来底层多线程编程。尽管它是内核头文件的一部分，它也能够在内核之外来帮助编程。</p>

<h4>计数器</h4>

<h4>原子队列</h4>

<h4>自旋锁</h4>

<p>OSAtomic.h 头文件定义了使用自旋锁的函数：OSSpinLock。</p>

<h2>线程安全类的设计</h2>

<h3>线程安全</h3>

<h4>Apple 的框架</h4>

<p>一般来说除非特别声明，大多数的类默认都<code>不是</code>线程安全的。</p>

<p>Apple没有把 UIKit 设计为线程安全的类是有意为之的，将其打造为线程安全的话会使很多操作变慢。而事实上 UIKit 是和主线程绑定的，这一特点使得编写并发程序以及使用 UIKit 十分容易的，你唯一需要确保的就是对于 UIKit 的调用总是在主线程中来进行。</p>

<h4>为什么 UIKit 不是线程安全的？</h4>

<p>对于一个像 UIKit 这样的大型框架，确保它的线程安全将会带来巨大的工作量和成本。</p>

<h4>内存回收 (deallocation) 问题</h4>

<p>另一个在后台使用 UIKit 对象的的危险之处在于“内存回收问题”。</p>

<h4>Collection 类</h4>

<p>总的来说，比如 <code>NSArry 这样不可变类是线程安全的</code>。然而它们的可变版本，比如 <code>NSMutableArray 是线程不安全的</code>。</p>

<p>一个好习惯是写类似于 <code>return [array copy]</code> 这样的代码来确保返回的对象事实上是不可变对象。</p>

<h4>原子属性 (Atomic Properties)</h4>

<h5>为何不用 @synchronized ？</h5>

<p><code>@synchonized(self)</code> 更适合使用在你 需要确保在发生错误时代码不会死锁，而是抛出异常的时候。</p>

<h4>你自己的类</h4>

<p>单独使用原子属性并不会使你的类变成线程安全。它不能保护你应用的逻辑，只能保护你免于在 setter 中遭遇到竞态条件的困扰。</p>

<p>一个简单的解决办法是使用 <code>@synchronize</code>。其他的方式都非常非常可能使你误入歧途，已经有太多聪明人在这种尝试上一次又一次地以失败告终。</p>

<h5>可行的线程安全设计</h5>

<h3>GCD 的陷阱</h3>

<p><a href="http://www.cnblogs.com/yjg2014/p/yjg.html">http://www.cnblogs.com/yjg2014/p/yjg.html</a></p>

<p><a href="http://m.blog.csdn.net/blog/againbike/11870459">http://m.blog.csdn.net/blog/againbike/11870459</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《#1 更轻量的 View Controllers》 学习笔记]]></title>
    <link href="http://sjpsega.com/blog/2014/06/11/lighter-view-controllers-note/"/>
    <updated>2014-06-11T12:01:53+08:00</updated>
    <id>http://sjpsega.com/blog/2014/06/11/lighter-view-controllers-note</id>
    <content type="html"><![CDATA[<p>文章地址：<a href="http://objccn.io/issue-1/">objc第一章</a></p>

<h2>更轻量的 View Controllers</h2>

<ul>
<li>针对<code>UITableViewController</code>等VC，可以把对应的<code>UITableViewDataSource</code>、<code>UITableViewDelegate</code>等<code>Protocol</code>代码，写成单独的类，再设置给VC的dataSource或deletege</li>
<li>将业务逻辑、网络请求逻辑移到 Model 中</li>
</ul>


<h2>整洁的 Table View 代码</h2>

<h3>添加Child View Controllers的步骤</h3>

<p><code>objc
ChildViewController *childVC = [[ChildViewController alloc] init];
[self addChildViewController:childVC];
CGRect frame = self.view.bounds;
childVC.view.frame = frame;
[self.view addSubview:childVC.view];
[childVC didMoveToParentViewController:self];
</code></p>

<h3>移除Child View Controllers的步骤</h3>

<p><code>objc
[childVC willMoveToParentViewController:nil];
[childVC.view removeFromSuperview];
[childVC removeFromParentViewController];
</code>
源自：<a href="http://geeklu.com/2014/05/custom-container-view-controller/">Custom Container View Controller</a></p>

<h3>分离关注点（Separating Concerns）</h3>

<p>这块最好对照看下文章的代码实践：<a href="http://objccn.io/issue-1-2/">http://objccn.io/issue-1-2/</a></p>

<h2>测试 View Controllers</h2>

<h2>View Controller 容器</h2>

<h3>过场动画 &ndash; 新老VC替换</h3>

<p>```objc
toController.view.frame = fromController.view.bounds;                         <br/>
[self addChildViewController:toController];                                   <br/>
[fromController willMoveToParentViewController:nil]; <br/>
[self transitionFromViewController:fromController</p>

<pre><code>              toViewController:toController
                      duration:0.2
                       options:direction | UIViewAnimationOptionCurveEaseIn
                    animations:nil
                    completion:^(BOOL finished) {
                        [toController didMoveToParentViewController:self];  
                        [fromController removeFromParentViewController];    
                    }];
</code></pre>

<p>```</p>

<h2>代码学习：</h2>

<p>代码地址：<a href="https://github.com/objcio/issue-1-lighter-view-controllers">https://github.com/objcio/issue-1-lighter-view-controllers</a></p>

<h3>反序列化</h3>

<p><code>objc
NSData *data = [NSData dataWithContentsOfURL:archiveURL options:0 error:NULL];
NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
_users = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@"users"];
_photos = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@"photos"];
[unarchiver finishDecoding];
</code></p>

<p><a href="http://stackoverflow.com/questions/17301769/when-to-use-nssecurecoding">When to use NSSecureCoding</a></p>

<p><a href="http://nshipster.com/nssecurecoding/">NSSecure​Coding</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS版PhoneGap原理分析]]></title>
    <link href="http://sjpsega.com/blog/2014/06/01/phonegap-ios/"/>
    <updated>2014-06-01T00:59:15+08:00</updated>
    <id>http://sjpsega.com/blog/2014/06/01/phonegap-ios</id>
    <content type="html"><![CDATA[<p>PhoneGap，著名的跨平台Hybrid框架，旨在让开发者使用HTML、Javascript、CSS开发跨平台的App。</p>

<p>最近的工作，就是做Hybrid方面的，很自然，方案就从PhoneGap入手。</p>

<p>下面就切入正题，分析下PhoneGap的原理，需要说明的是，我只针对iOS版本的PhoneGap做分析，android版本的原理大同小异。</p>

<h2>安装PhoneGap</h2>

<p>现在使用PhoneGap非常方便，只需要安装node，用简单的命令就能完成安装和使用的工作。</p>

<p>安装PhoneGap:
<code>objc
sudo npm install -g phonegap
</code></p>

<p>创建phoneGap应用:
<code>objc
phonegap create my-app
cd my-app
phonegap run ios
</code></p>

<p>具体可看<a href="http://phonegap.com/">phonegap官网</a>进行学习。</p>

<h2>PhoneGap与Cordova的关系</h2>

<p>Cordova是PhoneGap贡献给Apache后的开源项目，是从PhoneGap中抽离出的核心代码，是驱动PhoneGap的核心引擎。有点类似Webkit和Google Chrome的关系。</p>

<p>渊源就是：早在2011年10月，Adobe收购了Nitobi Software和它的PhoneGap产品，然后宣布这个移动Web开发框架将会继续开源，并把它提交到Apache Incubator，以便完全接受ASF的管治。当然，由于Adobe拥有了PhoneGap商标，所以开源组织的这个PhoneGap v2.0版产品就更名为Apache Cordova。</p>

<p>为什么说这个？因为下面的文章中，会出现<code>Cordova</code>这个命令，大家不要觉得奇怪。</p>

<h2>js与native通信的原理</h2>

<p>但在切入正题前，需要先了解下iOS js与native通信的原理。了解这个原理，是理解PhoneGap代码的<code>关键</code>。</p>

<p>具体可以看我之前写的<a href="http://sjpsega.com/blog/2014/03/08/js-communicate-with-native-in-iOS/">iOS Js与native相互通信</a>，这里做简单说明。</p>

<h3>js &ndash;> native</h3>

<p>在iOS中，js调用native并没有提供原生的实现，只能通过UIWebView相关的UIWebViewDelegate协议的</p>

<p><code>objc
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
</code>
方法来做拦截，并在这个方法中，根据url的协议或特征字符串来做调用方法或触发事件等工作，如</p>

<p>```objc
/<em>
* 方法的返回值是BOOL值。
* 返回YES：表示让浏览器执行默认操作，比如某个a链接跳转
* 返回NO：表示不执行浏览器的默认操作，这里因为通过url协议来判断js执行native的操作，肯定不是浏览器默认操作，故返回NO
* /
&ndash; (BOOL)webView:(UIWebView </em>)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<pre><code>NSURL *url = [request URL];
if ([[url scheme] isEqualToString:@"callFunction") {
    //调用原生方法

    return NO;
} else if (([[url scheme] isEqualToString:@"sendEvent") {
    //触发事件

    return NO;
} else {
    return YES;
}
</code></pre>

<p>}
<code>``
值得注意的是，通过这个方式，js调用native是</code>异步`的。</p>

<h3>native &ndash;> js</h3>

<p>native调用js非常简洁方便，只需要
<code>objc
[webView stringByEvaluatingJavaScriptFromString:@"alert('hello world!')"];
</code>
并且该方法是<code>同步</code>的。</p>

<p>native调用js非常简单直接，所以PhoneGap解决的主要是js调用native的问题。</p>

<h2>PhoneGap js &ndash;> native</h2>

<p>我们通过一个js调用native的Dialog的例子做说明。</p>

<p>Dialog是一个PhoneGap的插件，可以看<a href="https://github.com/apache/cordova-plugin-dialogs/blob/master/doc/index.md">dialog 插件文档</a>，学习下载并使用该插件。</p>

<p><code>
这里有个很重要的事需要说明一下：
目前PhoneGap的文档更新非常不及时，特别是插件的使用方面，比如Dialog插件的使用，文档中写的是使用navigator.notification.alert，但是经过我的摸索，因为现在PhoneGap使用AMD的方式来管理插件，所以应该是使用cordova.require("cordova/plugin/notification").alert的方式来调用。
插件的合并方面，也有很多坑，主要是文档不全 - -|||
</code></p>

<h3>js部分</h3>

<p>在html上添加一个button，然后通过下列代码调用：
```javascript
function alertDismissed() {</p>

<pre><code>// do something
</code></pre>

<p>}</p>

<p>function showAlert() {</p>

<pre><code>cordova.require("cordova/plugin/notification").alert(
    'You are the winner!',  // message
    alertDismissed,         // callback
    'Game Over',            // title
    'Done'                  // buttonName
);
</code></pre>

<p>}
```</p>

<p>再看下对应的<code>cordova/plugin/notification</code>的代码：
```javascript
var exec = cordova.require(&lsquo;cordova/exec&rsquo;);
var platform = cordova.require(&lsquo;cordova/platform&rsquo;);</p>

<p>module.exports = {</p>

<pre><code>/**
 * Open a native alert dialog, with a customizable title and button text.
 *
 * @param {String} message              Message to print in the body of the alert
 * @param {Function} completeCallback   The callback that is called when user clicks on a button.
 * @param {String} title                Title of the alert dialog (default: Alert)
 * @param {String} buttonLabel          Label of the close button (default: OK)
 */
alert: function(message, completeCallback, title, buttonLabel) {
    var _title = (title || "Alert");
    var _buttonLabel = (buttonLabel || "OK");
    exec(completeCallback, null, "Notification", "alert", [message, _title, _buttonLabel]);
}
</code></pre>

<p>}</p>

<p>&hellip;.
```</p>

<p>可以看到alert最终其实是调用了<code>exec</code>方法来调用native代码的，<code>exec</code>方法非常关键，是PhoneGap js调用native的核心代码。</p>

<p>然后在源码中搜索<code>exec对应的cordova/exec</code>，查看exec方法的源码。</p>

<p>因为对应的<code>cordova/exec</code>源码非常长，我只能截取最关键的代码并做说明：
```javascript
define(&ldquo;cordova/exec&rdquo;, function(require, exports, module) {</p>

<pre><code>...

function iOSExec() {
    ...

    var successCallback, failCallback, service, action, actionArgs, splitCommand;
    var callbackId = null;

    ...

    // 格式化传入参数
    successCallback = arguments[0]; //成功的回调函数
    failCallback = arguments[1];    //失败的回调函数
    service = arguments[2];         //表示调用native类的类名
    action = arguments[3];          //表示调用native类的一个方法
    actionArgs = arguments[4];      //参数

    //默认callbackId为'INVALID'，表示不需要回调
    callbackId = 'INVALID';

    ...

    //如果传入参数有successCallback或failCallback，说明需要回调，就设置callbackId，并存储对应的回调函数
    if (successCallback || failCallback) {
        callbackId = service + cordova.callbackId++;
        cordova.callbacks[callbackId] =
            {success:successCallback, fail:failCallback};
    }

    //格式化传入的service、action、actionArgs，并存储，准备native代码来调用
    actionArgs = massageArgsJsToNative(actionArgs);

    var command = [callbackId, service, action, actionArgs];

    commandQueue.push(JSON.stringify(command));

    ...

    //通过创建一个iframe并设置src，给native代码一个指令，开始执行js调用native的过程
    execIframe = execIframe || createExecIframe();
    if (!execIframe.contentWindow) {
        execIframe = createExecIframe();
    }
    execIframe.src = "gap://ready";

    ...
}

module.exports = iOSExec;
</code></pre>

<p>});
```</p>

<p>为了调用native方法，exec方法做了大量初始化的工作，这么做的原因，还是因为<code>iOS没有提供直接的方法来执行js调用native，不能把参数直接传递给native，所以只能通过js端存储对应操作的所有参数，然后通过指令来让native代码来回调的方式间接完成。</code></p>

<h3>native部分</h3>

<p>之后，就走到了native代码的部分。</p>

<h4>CDVViewController</h4>

<p>前面js通过创建一个iframe并发送<code>gap://ready</code>这个指令来告诉native开始执行操作。native中对应的操作在<code>CDVViewController.m</code>文件中的<code>webView:shouldStartLoadWithRequest:navigationType:</code>方法：</p>

<p>```objc
&ndash; (BOOL)webView:(UIWebView<em>)theWebView shouldStartLoadWithRequest:(NSURLRequest</em>)request navigationType:(UIWebViewNavigationType)navigationType
{</p>

<pre><code>NSURL* url = [request URL];

/*
 * 判断url的协议以"gap"开头
 * 执行在js端调用cordova.exec()的command队列
 * 注：这里的command表示js调用native
 */
if ([[url scheme] isElaqualToString:@"gap"]) {
   //_commandQueue即CDVCommandQueue类
    //从js端拉取command，即存储在js端commandQueue数组中的数据
    [_commandQueue fetchCommandsFromJs];
    //开始执行command
    [_commandQueue executePending];
    return NO;
}
</code></pre>

<p>&hellip;
}
```</p>

<p>到这里，其实已经走完js调用native的主要过程了。</p>

<p>之后，让我们再看下<code>CDVCommandQueue</code>中的fetchCommandsFromJs方法与executePending方法中做的事。</p>

<h4>CDVCommandQueue</h4>

<p>```objc
&ndash; (void)fetchCommandsFromJs
{</p>

<pre><code>// 获取js端存储的command，并在native暂存
NSString* queuedCommandsJSON = [_viewController.webView stringByEvaluatingJavaScriptFromString:
    @"cordova.require('cordova/exec').nativeFetchMessages()"];
[self enqueueCommandBatch:queuedCommandsJSON];
</code></pre>

<p>}
```
fetchCommandsFromJs方法非常简单，不细说了。</p>

<p>executePending方法稍微复杂些，因为js是单线程的，而iOS是典型的多线程，所以executePending方法做的工作主要是让command一个一个执行，防止线程问题。</p>

<p>executePending方法其实与之后的execute方法紧密相连，这里一起列出，只保留关键代码：</p>

<p>```objc
&ndash; (void)executePending
{</p>

<pre><code>...
//_queue即command队列，依次执行
while ([_queue count] &gt; 0) {
    ...
    //取出从js中获取的command字符串，解析为native端的CDVInvokedUrlCommand类
    CDVInvokedUrlCommand* command = [CDVInvokedUrlCommand commandFromJson:jsonEntry];
    ...
    //执行command
    [self execute:command])
    ...
}
</code></pre>

<p>}</p>

<ul>
<li>(BOOL)execute:(CDVInvokedUrlCommand<em>)command
{
  &hellip;
  BOOL retVal = YES;
  //获取plugin对应的实例
  CDVPlugin</em> obj = [_viewController.commandDelegate getCommandInstance:command.className];
  //调用plugin实例的方法名
  NSString* methodName = [NSString stringWithFormat:@&ldquo;%@:&rdquo;, command.methodName];
  SEL normalSelector = NSSelectorFromString(methodName);
  if ([obj respondsToSelector:normalSelector]) {
      //消息发送，执行plugin实例对应的方法，并传递参数
      objc_msgSend(obj, normalSelector, command);
  } else {
      // There&rsquo;s no method to call, so throw an error.
      NSLog(@&ldquo;ERROR: Method &lsquo;%@&rsquo; not defined in Plugin &lsquo;%@&rsquo;&rdquo;, methodName, command.className);
      retVal = NO;
  }
  &hellip;
  return retVal;
}
```</li>
</ul>


<p>可以看到js调用native plugin最终执行的是<code>objc_msgSend(obj, normalSelector, command);</code>这块代码，这里我们再拿js端的代码来进行理解。</p>

<p>之前js中的showAlert方法中我们书写了
<code>exec(completeCallback, null, "Notification", "alert", [message, _title, _buttonLabel]);</code></p>

<p>故，这里的对应关系：</p>

<ul>
<li>obj:&ldquo;Notification&rdquo;</li>
<li>normalSelector:&ldquo;alert&rdquo;</li>
<li>command:[message, <em>title, </em>buttonLabel]</li>
</ul>


<h4>CDVNotification</h4>

<p>&ldquo;Notification"真正对应的iOS类是CDVNotification。js端调用的插件名字"Notification"与真正的native类名并非完全对应，因为native因为平台的不同，有不同的命名规范。</p>

<p>看下CDVNotification的代码：</p>

<p>```objc
&ndash; (void)alert:(CDVInvokedUrlCommand*)command
{</p>

<pre><code>NSString* callbackId = command.callbackId;
NSString* message = [command argumentAtIndex:0];
NSString* title = [command argumentAtIndex:1];
NSString* buttons = [command argumentAtIndex:2];

[self showDialogWithMessage:message title:title buttons:@[buttons] defaultText:nil callbackId:callbackId dialogType:DIALOG_TYPE_ALERT];
</code></pre>

<p>}
```</p>

<p>前面用<code>objc_msgSend(obj, normalSelector, command);</code>做消息发送，执行的便是这块代码，代码很好理解，就是对command再做解析，并显示。</p>

<p>最终效果：</p>

<p><img src="/images/2014-06-01-phonegap-ios/alert.png" alt="alert" /></p>

<p>点击"Done"，native会再回调执行js端的成功回调，这里对应的就是js里设置的alertDismissed方法。</p>

<p>到此为止，我们已经走完从js端调用native alert的全部过程了。</p>

<p>列下过程的核心代码：</p>

<ul>
<li>js部分：

<ul>
<li>cordova.js中的iOSExec()方法，指定js调用native的初始化工作，并发送开始执行的指令</li>
</ul>
</li>
<li>native部分：

<ul>
<li>CDVViewController：拦截js调用native的url协议，执行调用</li>
<li>CDVCommandQueue：执行js调用native的队列，调用对应的plugin</li>
</ul>
</li>
</ul>


<h2>时序图</h2>

<p>以上Dialog例子中，PhoneGap js调用native的时序图：
<img src="/images/2014-06-01-phonegap-ios/PhoneGap.jpg" alt="PhoneGap" /></p>

<h2>结语</h2>

<p>PhoneGap还是很给力的，能做到主流平台全兼容着实不容易。</p>

<p>iOS端因为没有提供js调用native的直接方法，做的处理也算合理到位。</p>

<p>特别是插件化的支持做的很好，但是文档着实不够给力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的单例模式]]></title>
    <link href="http://sjpsega.com/blog/2014/05/25/singleton-in-ios/"/>
    <updated>2014-05-25T12:25:10+08:00</updated>
    <id>http://sjpsega.com/blog/2014/05/25/singleton-in-ios</id>
    <content type="html"><![CDATA[<p>单例模式是指在一个系统中，类有且只有一个实例对象，可以通过全局的一个入口对这个实例对象进行访问。</p>

<p>在iOS开发中，单例模式是非常常用的一种设计模式。</p>

<h2>ARC下的实现</h2>

<p>iOS5.0以后就开始可以使用ARC（Automatic Reference Counting：自动引用计数）来代替之前的MRC（Manual Reference Counting：人工引用计数）。</p>

<p>使用ARC会减少很多代码和忘了释放对象的苦恼。</p>

<p>慢慢ARC会成为主流，我入门iOS也是学ARC的，所以这里只写ARC的单例实现。</p>

<p><code>Singleton.h:</code>
```objc
//
//  Singleton.h
//  Singleton</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface Singleton : NSObject</p>

<ul>
<li>(Singleton *)sharedInstance;</li>
</ul>


<p>@end</p>

<p>```</p>

<p><code>Singleton.m:</code>
```objc</p>

<p>//
//  Singleton.m
//  Singleton</p>

<h1>import &ldquo;Singleton.h&rdquo;</h1>

<p>@implementation Singleton</p>

<ul>
<li><p>(Singleton <em>)sharedInstance{
  static Singleton </em>singleton;
  static dispatch_once_t token;
  dispatch_once(&amp;token,^{
      singleton = [[Singleton alloc]init];
  });
  return singleton;
}</p></li>
<li><p>(id)init{
  self = [super init];
  if(self){
      //在这里可以进行类的初始化工作
  }
  return self;
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>在这个实现中，核心是使用了GCD（Grand Central Dispatch）的<code>dispatch_once</code>方法，该方法可以保证Singleton只被实例化一次，并且该方法<code>线程安全</code>。</p>

<h2>纰漏</h2>

<p>以上实现有一个纰漏，Singleton继承于<code>NSObject</code>，<code>NSObject</code>有一个公开的初始化方法<code>-(id)init</code>，所以若使用者不小心，他完全可以使用<code>[[Singleton alloc]init]</code>来创建多个实例对象，这样轻易就破坏了单例的实现。</p>

<p>例如：
<code>objc
Singleton *single1 = [[Singleton alloc]init];
Singleton *single2 = [[Singleton alloc]init];
//结果为0，即NO，两者不是同一个实例
NSLog(@"%d",single1 == single2);
</code></p>

<h2>更好的实现</h2>

<p>其实是要对<code>Singleton.m</code>做一点改变，就能封住这个纰漏：</p>

<p>```objc
//
//  Singleton.m
//  Singleton</p>

<h1>import &ldquo;Singleton.h&rdquo;</h1>

<p>@implementation Singleton</p>

<ul>
<li>(Singleton <em>)sharedInstance{
  static Singleton </em>singleton;
  static dispatch_once_t token;
  dispatch_once(&amp;token,^{
      //这里调用私有的initSingle方法
      singleton = [[Singleton alloc]initSingle];
  });
  return singleton;
}</li>
</ul>


<p>//只是把原来在init方法中的代码，全都搬到initSingle
&ndash; (id)initSingle{</p>

<pre><code>self = [super init];
if(self){
    //在这里可以进行类的初始化工作
}
return self;
</code></pre>

<p>}</p>

<ul>
<li>(id)init{
  //改为调用[Singleton sharedInstance]
  return [Singleton sharedInstance];
}</li>
</ul>


<p>@end
```</p>

<ul>
<li>新建私有的initSingle方法，将原来init中的实现，全部搬入</li>
<li>sharedInstance中的singleton初始化，调用initSingle方法</li>
<li>init方法中，调用[Singleton sharedInstance]</li>
</ul>


<p>该实现，我是自己在实践中，觉得更好的单例实现，如有问题，请及时反馈。</p>
]]></content>
  </entry>
  
</feed>
