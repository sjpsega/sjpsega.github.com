<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | sjpsega's Blog]]></title>
  <link href="http://sjpsega.me/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://sjpsega.me/"/>
  <updated>2016-02-07T23:51:08+08:00</updated>
  <id>http://sjpsega.me/</id>
  <author>
    <name><![CDATA[sjpsega]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cordova WKWebView 学习笔记（一）]]></title>
    <link href="http://sjpsega.me/blog/2016/02/06/cordova-wkwebview-study-1/"/>
    <updated>2016-02-06T13:43:47+08:00</updated>
    <id>http://sjpsega.me/blog/2016/02/06/cordova-wkwebview-study-1</id>
    <content type="html"><![CDATA[<h2>WKWebView</h2>

<p>Apple 从 iOS 8 开始，引入了新的 WebView 类 <code>WKWebView</code>，试图替换已经老迈的 UIWebView。</p>

<h3>优点</h3>

<p>通过官方的描述，和自己实际测试，WKWebView功能相当强大，对比 UIWebView 的优点很多：</p>

<ul>
<li>更少的内存使用，渲染相同页面，占用内存基本只有 UIWebView 的 1/3 ~ 1/4，并且大大减少了内存泄露的情况</li>
<li>使用与 Safari 一样的性能强大的 Nirtro JS 引擎</li>
<li>异常强大的 app 与 web 的内容传递

<ul>
<li>可以使用 <code>WKUserContentController</code> 在 Native 端注入用户自定义脚本 JS</li>
<li>web 端可以使用 <code>window.webkit.messageHandlers.{NAME}.postMessage()</code>，直接向 Native 端发送消息。UIWebView 只能使用 iframe 等方案 hack</li>
</ul>
</li>
</ul>


<h3>限制</h3>

<p>官方的描述基本是溢美之词，他不会告诉你 WKWebView 的一些问题，但是这些问题，在做 Hybrid 应用的时候，影响很大，纯 wap 无影响。
估计是切换底层实现的关系，这些问题在 UIWebView 上不存在：</p>

<ul>
<li>无能加载本地文件，只能通过内建一个 WebServer 实现功能。（直到 iOS 9 才新开了一个loadFileURL:allowingReadAccessToURL: 接口，原生实现该功能）</li>
<li>不能注册自定义 NSURLProtocol，导致大量 URL 拦截功能难以实现，比如页面展示本地图片</li>
<li>不能使用 NSHTTPCookieStorage 设置 WebView 的 Cookie</li>
</ul>


<p>还有其他在实际开发中，可能爆出的 bug。</p>

<h2>Cordova WKWebview 现状</h2>

<p>Cordova 开发了<a href="https://github.com/apache/cordova-plugin-wkwebview-engine">一个插件</a>来支持 WKWebview，用户可以自行在 WKWebview 与 UIWebView 中选择。</p>

<p>但因为 WKWebView 存在的种种问题，WKWebView 还不是 Cordova 的默认选择。</p>

<p><a href="https://shazronatadobe.wordpress.com/2015/03/03/wkwebview-and-apache-cordova/">cordova 关于 WKWebView 的一些说明</a></p>

<h2>结论</h2>

<ul>
<li>纯 wap 页面，WKWebView 毫无问题，会有很好的表现</li>
<li>Hybrid 应用，因为现在存在的一些问题，以及会导致实现 Camera、PhotoList 等 JSBridge 的功能上会有较大限制，选择 WKWebView 需要慎重</li>
</ul>


<h2>相关代码</h2>

<p><a href="https://github.com/apache/cordova-plugin-wkwebview-engine">cordova-plugin-wkwebview-engine</a></p>

<p><a href="https://github.com/crosswalk-project/ios-extensions-crosswalk">CrossWalk Cordova Plugin Support</a></p>

<h2>相关资料</h2>

<p><a href="http://docs.telerik.com/platform/appbuilder/cordova/configuring-your-app/configure-web-views">Telerik Platform Documentation - Configure the Web Views</a></p>

<p><a href="http://plugins.telerik.com/cordova/plugin/wkwebview">Cordova Plugins - WKWebView</a></p>

<p><a href="https://crosswalk-project.org/documentation/ios/cordova_plugin_support.html">CrossWalk - Cordova Plugin Support</a></p>

<p><a href="http://stackoverflow.com/questions/29268433/is-there-support-in-cordova-to-wkwebview">Is there support in Cordova to WKWebView?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[isEqual 与 Hash]]></title>
    <link href="http://sjpsega.me/blog/2016/01/14/isequalandhash/"/>
    <updated>2016-01-14T01:17:56+08:00</updated>
    <id>http://sjpsega.me/blog/2016/01/14/isequalandhash</id>
    <content type="html"><![CDATA[<h2>最佳实践</h2>

<ul>
<li>实现 <code>isEqualTo__ClassName__</code></li>
<li>重写 isEqual 方法，同时重写 hash 方法。</li>
</ul>


<h2>关系</h2>

<ul>
<li>两个对象 isEqual 相等，hash 必须也相等</li>
<li>两个对象 hash 相同，isEqual 则不一定相等</li>
</ul>


<h2>碰撞</h2>

<p>当对象存入集合对象时（Array，Set，HashTable等），内部会使用对象的 hash 值来作为 key 来存入。
当两个不相等的对象，有相同的 hash 值，存入集合对象，就会发生<code>碰撞</code>现象。
发生碰撞现象，对使得存取数据变慢，所以需要尽量避免这个现象，但不可能完全避免。</p>

<h2>作为集合对象 key 的注意点</h2>

<ul>
<li>实现 isEqual 和 hash 方法，遵守两者关系，尽量避免 hash 碰撞的情况发生</li>
<li>实现 NSCopying 协议，接口：<code>- (void)setObject:(ObjectType)anObject forKey:(KeyType &lt;NSCopying&gt;)aKey;</code></li>
</ul>


<h2>测试 Demo</h2>

<p><a href="https://github.com/sjpsega/EqualAndHashTest">测试 Demo</a></p>

<h2>参考资料</h2>

<p><a href="http://nshipster.com/equality/">Equality</a></p>

<p><a href="https://mikeash.com/pyblog/friday-qa-2010-06-18-implementing-equality-and-hashing.html">Implementing Equality and Hashing</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD 学习]]></title>
    <link href="http://sjpsega.me/blog/2015/08/31/gcd-study/"/>
    <updated>2015-08-31T00:08:49+08:00</updated>
    <id>http://sjpsega.me/blog/2015/08/31/gcd-study</id>
    <content type="html"><![CDATA[<p>Grand Central Dispatch （GCD）是 Apple 开发的一个多核编程的解决方法。</p>

<p>底层、轻量，是 iOS 上常用的多线程解决方案。</p>

<h2>基本操作</h2>

<h3>sync、async</h3>

<p>dispatch_sync （同步）添加任务到一个队列并等待，直到任务完成，再执行原有队列上的任务。</p>

<p>dispatch_async （异步）添加任务到一个队列，但继续执行原有队列上的任务，在队列中按照 FIFO 的规则执行。</p>

<pre><code class="objc">dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"log 1");
    });
NSLog(@"log 2");
/* 输出:
 * log 1
 * log 2
 * /
</code></pre>

<pre><code class="objc">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"log 1");
    });
NSLog(@"log 2");
/* 输出绝大多数情况为:
 * log 2
 * log 1
 * /
</code></pre>

<p><code>注：不能在串行（主线程是一种串行队列）线程队列的任务中，再使用 dispatch_sync 添加任务到同一个串行队列中，否则必定发生死锁。</code></p>

<pre><code class="objc">dispatch_async(dispatch_get_main_queue(), ^{
    //必定发生死锁
    dispatch_sync(dispatch_get_main_queue(), ^{
    });
});
</code></pre>

<h3>dispatch_once</h3>

<p>dispatch_once 线程安全的方式执行任务且仅执行其代码块一次。</p>

<p>在单例模式中普遍使用。</p>

<pre><code class="objc">static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    NSLog(@"log 1");
});
dispatch_once(&amp;onceToken, ^{
    NSLog(@"log 2");
});
/* 输出:
 * log 1
 * /
</code></pre>

<h3>dispatch_after</h3>

<p>dispatch_after 延后一定时间，异步执行任务</p>

<pre><code class="objc">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"log 1");
    });
NSLog(@"log 2");
/* 输出:
 * log 2
 * log 1
 * /
</code></pre>

<h2>group</h2>

<p>通常使用分组来关联一组相关的任务，任务全部完成后，再做相关操作。</p>

<h3>group_enter、group_leave</h3>

<p>使用 dispatch_group_enter、dispatch_group_leave 来手动设置一个组任务的开始和结束，用来控制复杂情况下的任务完成情况。</p>

<p>必须保证 dispatch_group_enter 和 dispatch_group_leave <code>成对出现</code>，否则会遇到崩溃问题。</p>

<p>实例：</p>

<p>a）不使用 dispatch_group_enter、dispatch_group_leave 的情况
<code>objc
- (void)testGCDWithGroup{
    __block int count = 0;
    __block BOOL isDone = NO;
    // 1
    dispatch_group_t group = dispatch_group_create();
    // 2
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"CGD 1 .");
        // 3
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSLog(@"CGD 1 after.");
            count++;
        });
    });
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"done !!!");
        // 4
        isDone = YES;
        expect(count).to.equal(1);
    });
    // 5
    expect(isDone).will.beTruthy();
}
</code>
该测试用例执行步骤为:</p>

<ol>
<li>生成一个自定义组</li>
<li>在自定义组上，添加任务到子线程上执行</li>
<li>子线程上的任务为执行一个延时任务，使得 count + 1</li>
<li>当一个组内的任务全部完成，设置 isDone 为 YES，并期望 count 为 1</li>
<li>异步执行，期望 isDone 为 YES</li>
</ol>


<p>期望4、5处的测试均能通过，但测试结果为：</p>

<ol>
<li>5 的测试 case 为通过</li>
<li>4 的测试 case <code>不通过</code>，count 不为 1</li>
</ol>


<p>因为在这个例子中，执行完毕 dispatch_group_async 中的任务，就算任务完成了；而不是等到 dispatch_group_async 中的 dispatch_after 任务完成，才算任务完成。</p>

<p>b）使用 dispatch_group_enter、dispatch_group_leave 的情况
<code>objc
- (void)testGCDWithGroupEnterAndLeave{
    __block int count = 0;
    __block BOOL isDone = NO;
    dispatch_group_t group = dispatch_group_create();
    dispatch_group_enter(group);
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"CGD 1 .");
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSLog(@"CGD 1 after.");
            dispatch_group_leave(group);
            count++;
        });
    });
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"done !!!");
        isDone = YES;
        expect(count).to.equal(1);
    });
    expect(isDone).will.beTruthy();
}
</code>
这个测试用例的全部通过，使用手动控制组任务的开始和结束，完美解决了例子 a 中碰到的问题。</p>

<p>使用 dispatch_group_enter、dispatch_group_leave，用来处理复杂的异步任务非常有效。</p>

<h2>queue</h2>

<h3>串行、并发</h3>

<p>串行队列每次只有一个任务被执行，并发队列在同一时间可以有多个任务被执行。</p>

<p>主线程是系统提供的一个特殊的队列，是一个<code>串行</code>队列，是唯一可用与更新 UI 的线程。</p>

<p>除了主线程，其他均为子线程，通常用来执行与 UI 无关的操作。
实际编码中，通常使用 <code>dispatch_get_global_queue(long identifier, unsigned long flags)</code> 来获取子线程队列。通过该方法获取的是<code>并发</code>的全局调度队列，并且可以设置四个不同优先级的队列：high、default、low、background，若没有特殊原因，只使用 default 级别的队列。</p>

<p>用户还可以使用 <code>dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)</code> 来创建自定义的串行或并发队列。
主线程是系统提供的<code>串行</code>队列。</p>

<pre><code class="objc">//创建自定义并发队列
dispatch_queue_t concurrentQueue = dispatch_queue_create("com.sjpsega", DISPATCH_QUEUE_CONCURRENT);
//创建自定义创兴队列
dispatch_queue_t serialQueue = dispatch_queue_create("com.sjpsega", DISPATCH_QUEUE_SERIAL);
</code></pre>

<h2>dispatch_barrier</h2>

<p>barrier 意为“障碍”。dispatch_barrier 在并发队列上工作时扮演一个串行式的瓶颈。当提交的任务开始执行时，该 API 保障这个时刻队列里只执行当前任务，不会执行其他任务。</p>

<p><img src="/images/2015-08-31-gcd-study/dispatch_barrier.png" alt="dispatch_barrier" /></p>

<p>使用 dispatch_barrier API 最佳的方式是使用<code>自定义并发队列</code>执行。</p>

<p>下面以使用 dispatch_barrier 保证类类变量线程安全为例：</p>

<pre><code class="objc">- (void)addStudents:(Student *)student{
    dispatch_barrier_async(_concurrentQueue, ^{
        [_students addObject:student];
    });
}

- (NSArray *)students{
    __block NSArray *copyObj;
    dispatch_sync(_concurrentQueue, ^{
        copyObj =  [_students copy];
    });
    return copyObj;
}
</code></pre>

<p>但是，通常保证类变量线程安全，若不是高并发的情况下，比较简单的方式是使用 <code>synchronized</code> 关键字：</p>

<pre><code class="objc">- (void)addStudents:(Student *)student{
    @synchronized(_students){
        [_students addObject:student];
    }
}

- (NSArray *)students{
    @synchronized(_students){
        return [_students copy];
    }
}
</code></pre>

<h2>测试 Demo</h2>

<p><a href="https://github.com/sjpsega/GCDTest">测试 Demo</a></p>

<h2>参考资料</h2>

<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">GCD 深入理解：第一部分</a></p>

<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md">GCD 深入理解：第二部分</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UIWebView 自定义协议文件加载缓存问题]]></title>
    <link href="http://sjpsega.me/blog/2015/06/15/uiwebview-cache-bug-by-custom-protocol/"/>
    <updated>2015-06-15T22:56:31+08:00</updated>
    <id>http://sjpsega.me/blog/2015/06/15/uiwebview-cache-bug-by-custom-protocol</id>
    <content type="html"><![CDATA[<h2>起因</h2>

<p>一个简单的需求：为了减少网络请求，一些前端资源会做本地缓存；使用 WebView 访问页面的时候，拦截特定请求，使得特定请求直接加载本地资源。</p>

<p>但是做的过程中发现，当请求的资源为自定义协议的时候，比如加载的 url 为 <code>abc://xxx.com/xx.js</code> 的时候，系统会强制对该资源做缓存，并且调用系统提供的清除缓存接口，如 <code>[[NSURLCache sharedURLCache] removeAllCachedResponses]</code>， 都无法清除该缓存，除非重启 App。</p>

<p>这就导致该资源内容发生变化的时候，无法立即生效，这在业务中，显然是不能接受的。</p>

<p><code>注</code>：该方案主要针对 <code>UIWebView</code> 有效；<code>WKWebView</code> 因为不能使用自定义 NSURLProtocol 拦截资源，方法二就不起作用。</p>

<h2>解决</h2>

<h3>方法一：html 模板上，资源 url 加上随机字符串</h3>

<p>在 html 页面上修改 url 字符串，如 <code>abc://xxx.com/xx.js</code>，需要改成 <code>abc://xxx.com/xx.js?t=123</code>，这样系统就不会缓存该资源。</p>

<p>该方法简单直接。</p>

<h3>方法二：创建自定义 NSURLProtocol，拦截请求，并且在创建 response 时，修改自定义协议为 http 或 https</h3>

<p>伪代码如下：
<code>objc
//原请求
NSString *requestURLString = @"abc://xxx.com/xx.js";
//根据原请求获得的 data 数据
NSData *abcData = ...
//将原请求的自定义协议改成 http
NSString *changeURLString = @"http://xxx.com/xx.js";
//创建 response
NSURL *url = [NSURL URLWithString:changeURLString];
NSURLResponse* response =
[[NSURLResponse alloc] initWithURL:url
                          MIMEType:@"application/x-javascript"
             expectedContentLength:abcData.length
                  textEncodingName:@"UTF-8"];
[[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
[[self client] URLProtocol:self didLoadData:abcData];
[[self client] URLProtocolDidFinishLoading:self];
</code></p>

<p>本来结合方法一的解决方式，创建 response 的时候，在 url 后加上随机字符串，但是经过试验，该方案<code>无效</code>，缓存始终存在。</p>

<p>使用该解决方法解决缓存问题，据个人猜测是因为，iOS 系统默认缓存数据，但针对 http 或 https 协议会根据 Cache-Control 等字段判断是否缓存。</p>

<p>具体可见 <a href="https://github.com/sjpsega/CustomProtocolCacheTest">测试demo</a>，并注意 log 信息。</p>

<h2>讨论</h2>

<p>解决这个缓存问题，其实我还是有些疑惑，因为试了所有 iOS 给出的数据缓存 API，都不起作用。这些包括：</p>

<ul>
<li>使用 [[NSURLCache sharedURLCache] removeAllCachedResponses] 清理缓存</li>
<li>重写了 NSURLCache 的 - (NSCachedURLResponse <em>)cachedResponseForRequest:(NSURLRequest </em>)request 方法，不返回 response 对象</li>
<li>自定义 NSURLProtocol 中，使用 NSURLConnection 加载数据，实现 NSURLConnectionDelegate 的 - (NSCachedURLResponse <em>)connection:(NSURLConnection </em>)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse 方法，返回 nil，不做对应 url 数据的缓存。</li>
</ul>


<p>然后，方法一与方法二中，我都试验了 url 加随机字符串的方式，但是为什么 html 模板上的资源 url 加上随机字符串有效，创建 response 时候，url 加上随机字符串无效，我也感到无解。</p>

<p>感觉在 webView 资源缓存的问题上，Apple 官方还是有些接口没开放，或者是我不知道&hellip;</p>

<h2>参考资料</h2>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">URL Loading System</a></p>

<p><a href="http://nshipster.cn/nsurlcache/">NSURLCache</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重置 iOS UIWebView 的缩放]]></title>
    <link href="http://sjpsega.me/blog/2015/03/25/reset-webview-zoom-with-ios/"/>
    <updated>2015-03-25T14:01:19+08:00</updated>
    <id>http://sjpsega.me/blog/2015/03/25/reset-webview-zoom-with-ios</id>
    <content type="html"><![CDATA[<h2>需求</h2>

<p>遇到一个需求，iOS webView设置了可缩放，用户缩放webView后，做某个操作，需要将webView的缩放重置。</p>

<h2>经过</h2>

<p>在网上找了下，看到很多很多解决方案，不论是国内的，还是国外的解决方案，但是实际使用都没有效果……</p>

<h2>解决</h2>

<p>经过不断尝试，发现以下方式是有效果的：</p>

<pre><code class="objc">//重置 webView 的 html viewport 属性，变成不可缩放，并且缩放比例为1.0，并执行javaScript
#define QUOTE(...) #__VA_ARGS__
const char *webViewHeightJSString = QUOTE(
var viewportmeta = document.querySelector('meta[name="viewport"]');
if (viewportmeta) {
viewportmeta.content = 'width=device-width, initial-scale=1.0,      minimum-scale=1.0, maximum-scale=1.0, user-scalable=no';
}
);
#undef QUOTE
[webView stringByEvaluatingJavaScriptFromString:[NSString stringWithUTF8String:webViewHeightJSString]];
//设置 webView zoomScale 为 1.0，且必须设置animated为YES
[webView.scrollView setZoomScale:1.0 animated:YES];
</code></pre>

<p>此方法在iOS7、8上的 UIWebView 上测试通过，WKWebView 没有测试。</p>
]]></content>
  </entry>
  
</feed>
