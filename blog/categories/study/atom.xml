<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | sjpsega's Blog]]></title>
  <link href="http://sjpsega.com/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://sjpsega.com/"/>
  <updated>2014-06-05T10:31:04+08:00</updated>
  <id>http://sjpsega.com/</id>
  <author>
    <name><![CDATA[sjpsega]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS版PhoneGap原理分析]]></title>
    <link href="http://sjpsega.com/blog/2014/06/01/phonegap-ios/"/>
    <updated>2014-06-01T00:59:15+08:00</updated>
    <id>http://sjpsega.com/blog/2014/06/01/phonegap-ios</id>
    <content type="html"><![CDATA[<p>PhoneGap，著名的跨平台Hybrid框架，旨在让开发者使用HTML、Javascript、CSS开发跨平台的App。</p>

<p>最近的工作，就是做Hybrid方面的，很自然，方案就从PhoneGap入手。</p>

<p>下面就切入正题，分析下PhoneGap的原理，需要说明的是，我只针对iOS版本的PhoneGap做分析，android版本的原理大同小异。</p>

<h2>安装PhoneGap</h2>

<p>现在使用PhoneGap非常方便，只需要安装node，用简单的命令就能完成安装和使用的工作。</p>

<p>安装PhoneGap:
<code>objc
sudo npm install -g phonegap
</code></p>

<p>创建phoneGap应用:
<code>objc
phonegap create my-app
cd my-app
phonegap run ios
</code></p>

<p>具体可看<a href="http://phonegap.com/">phonegap官网</a>进行学习。</p>

<h2>PhoneGap与Cordova的关系</h2>

<p>Cordova是PhoneGap贡献给Apache后的开源项目，是从PhoneGap中抽离出的核心代码，是驱动PhoneGap的核心引擎。有点类似Webkit和Google Chrome的关系。</p>

<p>渊源就是：早在2011年10月，Adobe收购了Nitobi Software和它的PhoneGap产品，然后宣布这个移动Web开发框架将会继续开源，并把它提交到Apache Incubator，以便完全接受ASF的管治。当然，由于Adobe拥有了PhoneGap商标，所以开源组织的这个PhoneGap v2.0版产品就更名为Apache Cordova。</p>

<p>为什么说这个？因为下面的文章中，会出现<code>Cordova</code>这个命令，大家不要觉得奇怪。</p>

<h2>js与native通信的原理</h2>

<p>但在切入正题前，需要先了解下iOS js与native通信的原理。了解这个原理，是理解PhoneGap代码的<code>关键</code>。</p>

<p>具体可以看我之前写的<a href="http://sjpsega.com/blog/2014/03/08/js-communicate-with-native-in-iOS/">iOS Js与native相互通信</a>，这里做简单说明。</p>

<h3>js &ndash;> native</h3>

<p>在iOS中，js调用native并没有提供原生的实现，只能通过UIWebView相关的UIWebViewDelegate协议的</p>

<p><code>objc
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
</code>
方法来做拦截，并在这个方法中，根据url的协议或特征字符串来做调用方法或触发事件等工作，如</p>

<p>```objc
/<em>
* 方法的返回值是BOOL值。
* 返回YES：表示让浏览器执行默认操作，比如某个a链接跳转
* 返回NO：表示不执行浏览器的默认操作，这里因为通过url协议来判断js执行native的操作，肯定不是浏览器默认操作，故返回NO
* /
&ndash; (BOOL)webView:(UIWebView </em>)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<pre><code>NSURL *url = [request URL];
if ([[url scheme] isEqualToString:@"callFunction") {
    //调用原生方法

    return NO;
} else if (([[url scheme] isEqualToString:@"sendEvent") {
    //触发事件

    return NO;
} else {
    return YES;
}
</code></pre>

<p>}
<code>``
值得注意的是，通过这个方式，js调用native是</code>异步`的。</p>

<h3>native &ndash;> js</h3>

<p>native调用js非常简洁方便，只需要
<code>objc
[webView stringByEvaluatingJavaScriptFromString:@"alert('hello world!')"];
</code>
并且该方法是<code>同步</code>的。</p>

<p>native调用js非常简单直接，所以PhoneGap解决的主要是js调用native的问题。</p>

<h2>PhoneGap js &ndash;> native</h2>

<p>我们通过一个js调用native的Dialog的例子做说明。</p>

<p>Dialog是一个PhoneGap的插件，可以看<a href="https://github.com/apache/cordova-plugin-dialogs/blob/master/doc/index.md">dialog 插件文档</a>，学习下载并使用该插件。</p>

<p><code>
这里有个很重要的事需要说明一下：
目前PhoneGap的文档更新非常不及时，特别是插件的使用方面，比如Dialog插件的使用，文档中写的是使用navigator.notification.alert，但是经过我的摸索，因为现在PhoneGap使用AMD的方式来管理插件，所以应该是使用cordova.require("cordova/plugin/notification").alert的方式来调用。
插件的合并方面，也有很多坑，主要是文档不全 - -|||
</code></p>

<h3>js部分</h3>

<p>在html上添加一个button，然后通过下列代码调用：
```javascript
function alertDismissed() {</p>

<pre><code>// do something
</code></pre>

<p>}</p>

<p>function showAlert() {</p>

<pre><code>cordova.require("cordova/plugin/notification").alert(
    'You are the winner!',  // message
    alertDismissed,         // callback
    'Game Over',            // title
    'Done'                  // buttonName
);
</code></pre>

<p>}
```</p>

<p>再看下对应的<code>cordova/plugin/notification</code>的代码：
```javascript
var exec = cordova.require(&lsquo;cordova/exec&rsquo;);
var platform = cordova.require(&lsquo;cordova/platform&rsquo;);</p>

<p>module.exports = {</p>

<pre><code>/**
 * Open a native alert dialog, with a customizable title and button text.
 *
 * @param {String} message              Message to print in the body of the alert
 * @param {Function} completeCallback   The callback that is called when user clicks on a button.
 * @param {String} title                Title of the alert dialog (default: Alert)
 * @param {String} buttonLabel          Label of the close button (default: OK)
 */
alert: function(message, completeCallback, title, buttonLabel) {
    var _title = (title || "Alert");
    var _buttonLabel = (buttonLabel || "OK");
    exec(completeCallback, null, "Notification", "alert", [message, _title, _buttonLabel]);
}
</code></pre>

<p>}</p>

<p>&hellip;.
```</p>

<p>可以看到alert最终其实是调用了<code>exec</code>方法来调用native代码的，<code>exec</code>方法非常关键，是PhoneGap js调用native的核心代码。</p>

<p>然后在源码中搜索<code>exec对应的cordova/exec</code>，查看exec方法的源码。</p>

<p>因为对应的<code>cordova/exec</code>源码非常长，我只能截取最关键的代码并做说明：
```javascript
define(&ldquo;cordova/exec&rdquo;, function(require, exports, module) {</p>

<pre><code>...

function iOSExec() {
    ...

    var successCallback, failCallback, service, action, actionArgs, splitCommand;
    var callbackId = null;

    ...

    // 格式化传入参数
    successCallback = arguments[0]; //成功的回调函数
    failCallback = arguments[1];    //失败的回调函数
    service = arguments[2];         //表示调用native类的类名
    action = arguments[3];          //表示调用native类的一个方法
    actionArgs = arguments[4];      //参数

    //默认callbackId为'INVALID'，表示不需要回调
    callbackId = 'INVALID';

    ...

    //如果传入参数有successCallback或failCallback，说明需要回调，就设置callbackId，并存储对应的回调函数
    if (successCallback || failCallback) {
        callbackId = service + cordova.callbackId++;
        cordova.callbacks[callbackId] =
            {success:successCallback, fail:failCallback};
    }

    //格式化传入的service、action、actionArgs，并存储，准备native代码来调用
    actionArgs = massageArgsJsToNative(actionArgs);

    var command = [callbackId, service, action, actionArgs];

    commandQueue.push(JSON.stringify(command));

    ...

    //通过创建一个iframe并设置src，给native代码一个指令，开始执行js调用native的过程
    execIframe = execIframe || createExecIframe();
    if (!execIframe.contentWindow) {
        execIframe = createExecIframe();
    }
    execIframe.src = "gap://ready";

    ...
}

module.exports = iOSExec;
</code></pre>

<p>});
```</p>

<p>为了调用native方法，exec方法做了大量初始化的工作，这么做的原因，还是因为<code>iOS没有提供直接的方法来执行js调用native，不能把参数直接传递给native，所以只能通过js端存储对应操作的所有参数，然后通过指令来让native代码来回调的方式间接完成。</code></p>

<h3>native部分</h3>

<p>之后，就走到了native代码的部分。</p>

<h4>CDVViewController</h4>

<p>前面js通过创建一个iframe并发送<code>gap://ready</code>这个指令来告诉native开始执行操作。native中对应的操作在<code>CDVViewController.m</code>文件中的<code>webView:shouldStartLoadWithRequest:navigationType:</code>方法：</p>

<p>```objc
&ndash; (BOOL)webView:(UIWebView<em>)theWebView shouldStartLoadWithRequest:(NSURLRequest</em>)request navigationType:(UIWebViewNavigationType)navigationType
{</p>

<pre><code>NSURL* url = [request URL];

/*
 * 判断url的协议以"gap"开头
 * 执行在js端调用cordova.exec()的command队列
 * 注：这里的command表示js调用native
 */
if ([[url scheme] isElaqualToString:@"gap"]) {
   //_commandQueue即CDVCommandQueue类
    //从js端拉取command，即存储在js端commandQueue数组中的数据
    [_commandQueue fetchCommandsFromJs];
    //开始执行command
    [_commandQueue executePending];
    return NO;
}
</code></pre>

<p>&hellip;
}
```</p>

<p>到这里，其实已经走完js调用native的主要过程了。</p>

<p>之后，让我们再看下<code>CDVCommandQueue</code>中的fetchCommandsFromJs方法与executePending方法中做的事。</p>

<h4>CDVCommandQueue</h4>

<p>```objc
&ndash; (void)fetchCommandsFromJs
{</p>

<pre><code>// 获取js端存储的command，并在native暂存
NSString* queuedCommandsJSON = [_viewController.webView stringByEvaluatingJavaScriptFromString:
    @"cordova.require('cordova/exec').nativeFetchMessages()"];
[self enqueueCommandBatch:queuedCommandsJSON];
</code></pre>

<p>}
```
fetchCommandsFromJs方法非常简单，不细说了。</p>

<p>executePending方法稍微复杂些，因为js是单线程的，而iOS是典型的多线程，所以executePending方法做的工作主要是让command一个一个执行，防止线程问题。</p>

<p>executePending方法其实与之后的execute方法紧密相连，这里一起列出，只保留关键代码：</p>

<p>```objc
&ndash; (void)executePending
{</p>

<pre><code>...
//_queue即command队列，依次执行
while ([_queue count] &gt; 0) {
    ...
    //取出从js中获取的command字符串，解析为native端的CDVInvokedUrlCommand类
    CDVInvokedUrlCommand* command = [CDVInvokedUrlCommand commandFromJson:jsonEntry];
    ...
    //执行command
    [self execute:command])
    ...
}
</code></pre>

<p>}</p>

<ul>
<li>(BOOL)execute:(CDVInvokedUrlCommand<em>)command
{
  &hellip;
  BOOL retVal = YES;
  //获取plugin对应的实例
  CDVPlugin</em> obj = [_viewController.commandDelegate getCommandInstance:command.className];
  //调用plugin实例的方法名
  NSString* methodName = [NSString stringWithFormat:@&ldquo;%@:&rdquo;, command.methodName];
  SEL normalSelector = NSSelectorFromString(methodName);
  if ([obj respondsToSelector:normalSelector]) {
      //消息发送，执行plugin实例对应的方法，并传递参数
      objc_msgSend(obj, normalSelector, command);
  } else {
      // There&rsquo;s no method to call, so throw an error.
      NSLog(@&ldquo;ERROR: Method &lsquo;%@&rsquo; not defined in Plugin &lsquo;%@&rsquo;&rdquo;, methodName, command.className);
      retVal = NO;
  }
  &hellip;
  return retVal;
}
```</li>
</ul>


<p>可以看到js调用native plugin最终执行的是<code>objc_msgSend(obj, normalSelector, command);</code>这块代码，这里我们再拿js端的代码来进行理解。</p>

<p>之前js中的showAlert方法中我们书写了
<code>exec(completeCallback, null, "Notification", "alert", [message, _title, _buttonLabel]);</code></p>

<p>故，这里的对应关系：</p>

<ul>
<li>obj:&ldquo;Notification&rdquo;</li>
<li>normalSelector:&ldquo;alert&rdquo;</li>
<li>command:[message, <em>title, </em>buttonLabel]</li>
</ul>


<h4>CDVNotification</h4>

<p>&ldquo;Notification"真正对应的iOS类是CDVNotification。js端调用的插件名字"Notification"与真正的native类名并非完全对应，因为native因为平台的不同，有不同的命名规范。</p>

<p>看下CDVNotification的代码：</p>

<p>```objc
&ndash; (void)alert:(CDVInvokedUrlCommand*)command
{</p>

<pre><code>NSString* callbackId = command.callbackId;
NSString* message = [command argumentAtIndex:0];
NSString* title = [command argumentAtIndex:1];
NSString* buttons = [command argumentAtIndex:2];

[self showDialogWithMessage:message title:title buttons:@[buttons] defaultText:nil callbackId:callbackId dialogType:DIALOG_TYPE_ALERT];
</code></pre>

<p>}
```</p>

<p>前面用<code>objc_msgSend(obj, normalSelector, command);</code>做消息发送，执行的便是这块代码，代码很好理解，就是对command再做解析，并显示。</p>

<p>最终效果：</p>

<p><img src="/images/2014-06-01-phonegap-ios/alert.png" alt="alert" /></p>

<p>点击"Done"，native会再回调执行js端的成功回调，这里对应的就是js里设置的alertDismissed方法。</p>

<p>到此为止，我们已经走完从js端调用native alert的全部过程了。</p>

<p>列下过程的核心代码：</p>

<ul>
<li>js部分：

<ul>
<li>cordova.js中的iOSExec()方法，指定js调用native的初始化工作，并发送开始执行的指令</li>
</ul>
</li>
<li>native部分：

<ul>
<li>CDVViewController：拦截js调用native的url协议，执行调用</li>
<li>CDVCommandQueue：执行js调用native的队列，调用对应的plugin</li>
</ul>
</li>
</ul>


<h2>时序图</h2>

<p>以上Dialog例子中，PhoneGap js调用native的时序图：
<img src="/images/2014-06-01-phonegap-ios/PhoneGap.jpg" alt="PhoneGap" /></p>

<h2>结语</h2>

<p>PhoneGap还是很给力的，能做到主流平台全兼容着实不容易。</p>

<p>iOS端因为没有提供js调用native的直接方法，做的处理也算合理到位。</p>

<p>特别是插件化的支持做的很好，但是文档着实不够给力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的单例模式]]></title>
    <link href="http://sjpsega.com/blog/2014/05/25/singleton-in-ios/"/>
    <updated>2014-05-25T12:25:10+08:00</updated>
    <id>http://sjpsega.com/blog/2014/05/25/singleton-in-ios</id>
    <content type="html"><![CDATA[<p>单例模式是指在一个系统中，类有且只有一个实例对象，可以通过全局的一个入口对这个实例对象进行访问。</p>

<p>在iOS开发中，单例模式是非常常用的一种设计模式。</p>

<h2>ARC下的实现</h2>

<p>iOS5.0以后就开始可以使用ARC（Automatic Reference Counting：自动引用计数）来代替之前的MRC（Manual Reference Counting：人工引用计数）。</p>

<p>使用ARC会减少很多代码和忘了释放对象的苦恼。</p>

<p>慢慢ARC会成为主流，我入门iOS也是学ARC的，所以这里只写ARC的单例实现。</p>

<p><code>Singleton.h:</code>
```objc
//
//  Singleton.h
//  Singleton</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface Singleton : NSObject</p>

<ul>
<li>(Singleton *)sharedInstance;</li>
</ul>


<p>@end</p>

<p>```</p>

<p><code>Singleton.m:</code>
```objc</p>

<p>//
//  Singleton.m
//  Singleton</p>

<h1>import &ldquo;Singleton.h&rdquo;</h1>

<p>@implementation Singleton</p>

<ul>
<li><p>(Singleton <em>)sharedInstance{
  static Singleton </em>singleton;
  static dispatch_once_t token;
  dispatch_once(&amp;token,^{
      singleton = [[Singleton alloc]init];
  });
  return singleton;
}</p></li>
<li><p>(id)init{
  self = [super init];
  if(self){
      //在这里可以进行类的初始化工作
  }
  return self;
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<p>在这个实现中，核心是使用了GCD（Grand Central Dispatch）的<code>dispatch_once</code>方法，该方法可以保证Singleton只被实例化一次，并且该方法<code>线程安全</code>。</p>

<h2>纰漏</h2>

<p>以上实现有一个纰漏，Singleton继承于<code>NSObject</code>，<code>NSObject</code>有一个公开的初始化方法<code>-(id)init</code>，所以若使用者不小心，他完全可以使用<code>[[Singleton alloc]init]</code>来创建多个实例对象，这样轻易就破坏了单例的实现。</p>

<p>例如：
<code>objc
Singleton *single1 = [[Singleton alloc]init];
Singleton *single2 = [[Singleton alloc]init];
//结果为0，即NO，两者不是同一个实例
NSLog(@"%d",single1 == single2);
</code></p>

<h2>更好的实现</h2>

<p>其实是要对<code>Singleton.m</code>做一点改变，就能封住这个纰漏：</p>

<p>```objc
//
//  Singleton.m
//  Singleton</p>

<h1>import &ldquo;Singleton.h&rdquo;</h1>

<p>@implementation Singleton</p>

<ul>
<li>(Singleton <em>)sharedInstance{
  static Singleton </em>singleton;
  static dispatch_once_t token;
  dispatch_once(&amp;token,^{
      //这里调用私有的initSingle方法
      singleton = [[Singleton alloc]initSingle];
  });
  return singleton;
}</li>
</ul>


<p>//只是把原来在init方法中的代码，全都搬到initSingle
&ndash; (id)initSingle{</p>

<pre><code>self = [super init];
if(self){
    //在这里可以进行类的初始化工作
}
return self;
</code></pre>

<p>}</p>

<ul>
<li>(id)init{
  //改为调用[Singleton sharedInstance]
  return [Singleton sharedInstance];
}</li>
</ul>


<p>@end
```</p>

<ul>
<li>新建私有的initSingle方法，将原来init中的实现，全部搬入</li>
<li>sharedInstance中的singleton初始化，调用initSingle方法</li>
<li>init方法中，调用[Singleton sharedInstance]</li>
</ul>


<p>该实现，我是自己在实践中，觉得更好的单例实现，如有问题，请及时反馈。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Category添加实例变量的故事]]></title>
    <link href="http://sjpsega.com/blog/2014/04/07/category-with-instance-variables/"/>
    <updated>2014-04-07T20:55:16+08:00</updated>
    <id>http://sjpsega.com/blog/2014/04/07/category-with-instance-variables</id>
    <content type="html"><![CDATA[<h2>起因</h2>

<p>有一个需求，针对 url 字符串，需要根据传入的key获取对应参数键值对的value。例如：</p>

<p><code>objc
NSString *urlString = @"http://www.1688.com?key1=val1&amp;key2=val2";
NSURL *url = [NSURL URLWithString:urlString];
NSString *val = [url paramWithKey:@"key1"];
</code></p>

<p>NSURL 类虽然自带方法很多，但是却没有这个有用的方法。故需要做类扩展（Category）。</p>

<p>实现的时候，需要一个 NSDictionary 类型的实例变量来存储 url 字符串的参数键值对，便于多次调用 -paramWithKey 的时候，提高性能。</p>

<h2>经过</h2>

<p>写的时候，闹了几个笑话，走了弯路，记录下来。</p>

<h3>在头文件中添加变量</h3>

<p><code>objc
@interface NSURL (WingQueryDictionary)
@property (nonatomic, copy) NSDictionary *queryDictionary;
@end
</code></p>

<p>结果：编译不报错，但是实际执行中，实例中，找不到 self.queryDictionary 这个变量。</p>

<h3>直接在 Category 中添加实例变量</h3>

<p>```objc
@implementation NSURL (QueryDictionary){</p>

<pre><code>NSDictionary *queryDictionary;
</code></pre>

<p>}
@end
```</p>

<p>结果：编译直接报错，因为<code>Category不允许为已有的类添加新的属性或者实例变量，只能添加新方法</code>。</p>

<h3>在匿名 Category 中添加实例变量</h3>

<p>```objc
@interface NSURL(){</p>

<pre><code>NSDictionary *queryDictionary;
</code></pre>

<p>}
@end</p>

<p>@implementation NSURL (QueryDictionary){</p>

<pre><code>NSDictionary *queryDictionary;
</code></pre>

<p>}</p>

<ul>
<li>(NSString <em>)paramWithKey:(NSString </em>)key{
  return self.queryDictionary[key];
}
@end
```</li>
</ul>


<p>结果：编译直接报错，原因同上。</p>

<h3>添加一个类变量</h3>

<p>```objc
static NSDictionary *queryDictionary;</p>

<p>@implementation NSURL (WingQueryDictionary)
@end
```</p>

<p>结果：能够完成需求，但是若新建多个 NSURL 并调用 -paramWithKey 方法，参数获取会有bug。</p>

<h3>利用 runtime.h 来实现添加实例变量</h3>

<p>最后，实在没辙了，只能 google 找方法。</p>

<p>发现可以<code>利用 runtime.h 中 objc_getAssociatedObject / objc_setAssociatedObject 方法来模拟生成实例变量</code>。</p>

<p>关键代码：
```objc</p>

<h1>import &lt;objc/runtime.h></h1>

<p>static const char *varKey = &ldquo;queryDictionary&rdquo;;</p>

<ul>
<li><p>(NSDictionary <em>)queryDictionary {
  return (NSDictionary </em>)objc_getAssociatedObject(self, &amp;varKey);
}</p></li>
<li><p>(void)setQueryDictionary:(NSDictionary *)queryDictionary {
  objc_setAssociatedObject(self, &amp;varKey, queryDictionary, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
```</p></li>
</ul>


<h3>API 解析</h3>

<p>设置实例对象：
<code>objc
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)
</code>
用该方法来完成实例变量的 setter 实现。</p>

<ul>
<li>参数 id：设置实例对象相关的实例，通常为self</li>
<li>参数 key：设置实例对象的key，即name</li>
<li>参数 value：设置实例对象的值</li>
<li>参数 policy：设置实例对象的内存对策，可选值如下：

<ul>
<li>(weak) / (assign) OBJC_ASSOCIATION_ASSIGN</li>
<li>(strong) / (retain) OBJC_ASSOCIATION_RETAIN</li>
<li>(copy) OBJC_ASSOCIATION_COPY</li>
<li>(nonatomic,strong) OBJC_ASSOCIATION_RETAIN_NONATOMIC</li>
<li>(nonatomic,copy) OBJC_ASSOCIATION_COPY_NONATOMIC</li>
</ul>
</li>
</ul>


<p>获得实例对象：
<code>objc
id objc_getAssociatedObject(id object, void *key)
</code>
完成实例变量的 getter实现。看了 setter 实现，这个方法的参数就很容易理解了。</p>

<h2>参考资料</h2>

<p><a href="http://www.cnblogs.com/wupher/archive/2013/01/05/2845338.html">让Category支持添加属性与成员变量</a></p>

<p><a href="http://kaspermunck.github.io/2012/11/adding-properties-to-objective-c-categories/">Adding Properties to Objective-C Categories</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Js与native相互通信]]></title>
    <link href="http://sjpsega.com/blog/2014/03/08/js-communicate-with-native-in-iOS/"/>
    <updated>2014-03-08T21:53:16+08:00</updated>
    <id>http://sjpsega.com/blog/2014/03/08/js-communicate-with-native-in-iOS</id>
    <content type="html"><![CDATA[<h2>js与navive相互通信的机制</h2>

<h3>js &ndash;> native</h3>

<p>目前，截止至iOS7，iOS原生并没有提供js直接调用native的方式，只能通过UIWebView相关的UIWebViewDelegate协议的</p>

<p><code>objc
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
</code></p>

<p>方法来做拦截，并在这个方法中，根据url的协议或特征字符串来做调用方法或触发事件等工作，如</p>

<p>```objc
/<em>
* 方法的返回值是BOOL值。
* 返回YES：表示让浏览器执行默认操作，比如某个a链接跳转
* 返回NO：表示不执行浏览器的默认操作，这里因为通过url协议来判断js执行native的操作，肯定不是浏览器默认操作，故返回NO
* /
&ndash; (BOOL)webView:(UIWebView </em>)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<pre><code>NSURL *url = [request URL];
if ([[url scheme] isEqualToString:@"callFunction") {
    //调用原生方法

    return NO;
} else if (([[url scheme] isEqualToString:@"sendEvent") {    
    //触发事件

    return NO;
} else {
    return YES;
}
</code></pre>

<p>}
<code>``
虽然通过这个方式，js调用native是</code>异步`的，但是效率还是很高，我通过在js调用端，把time传入navive然后相减的方式计算，平均只有5ms的时间间隔。</p>

<h4>如何触发这个方法拦截</h4>

<p>最最简单且实用的方法莫过于用js创建一个隐藏的iframe设置src了，代码：</p>

<p>```js
function js2native(){</p>

<pre><code>var iframe = document.createElement("iframe");
iframe.src="callFunction://";
iframe.style.display = 'none';
document.body.appendChild(iframe);
iframe.parentNode.removeChild(iFrame);
iframe = null;
</code></pre>

<p>}
```</p>

<p>通过查看phoneGap源码的iOSExec方法，还有使用XMLHttpRequest或修改hash的方式来触发方法拦截，但是因为有bug或其他原因，不推荐。</p>

<h3>native &ndash;> js</h3>

<p>native调用js非常简洁方便，只需要</p>

<p><code>objc
[webView stringByEvaluatingJavaScriptFromString:@"alert('hello world!')"];
</code>
并且该方法是<code>同步</code>的。</p>

<h2>调试</h2>

<p><del>虽然现在能直接用Safari的开发模式直接查看模拟器中的webView页面，但是经过亲自尝试，最想要的也是最重要的js调试，还是不支持，不能进行js断点调试，还是要依赖console来弄……当然css样式调试支持的不错。</del></p>

<p>2014-04-09 update: 昨天发现Safari是可以对模拟器中的webView页面进行js断点调试的，之前是因为我没有设置<code>启用所有断点</code>……</p>

<p>可以在模拟器进入webView页面后，打开Safari，然后在 开发->iPhone simulator 菜单下进行页面选择，进入调试。</p>

<h3>相关资料</h3>

<p><a href="http://blog.devtang.com/blog/2012/03/24/talk-about-uiwebview-and-phonegap/">唐巧-关于UIWebView和PhoneGap的总结</a></p>

<p><a href="https://github.com/marcuswestin/WebViewJavascriptBridge">Github上的WebViewJavascriptBridge项目</a></p>

<p><a href="http://phonegap.com/">大名鼎鼎的phonegap</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]iOS7最佳实践：一个天气App案例(二)]]></title>
    <link href="http://sjpsega.com/blog/2014/02/15/yi--ios-7-best-practices-part-2/"/>
    <updated>2014-02-15T16:46:02+08:00</updated>
    <id>http://sjpsega.com/blog/2014/02/15/yi--ios-7-best-practices-part-2</id>
    <content type="html"><![CDATA[<p>注：本文译自：<a href="http://www.raywenderlich.com/55385/ios-7-best-practices-part-2">raywenderlich ios-7-best-practices-part-2</a>，去除了跟主题无关的寒暄部分。
欢迎转载，保持署名</p>

<h2>开始</h2>

<p>你有两个选择开始本教程：您可以使用在本教程的第1部分你已完成的项目，或者你可以在这里下载<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/SimpleWeather-Part-1.zip">第1部分已完成的项目</a>。</p>

<p>在前面的教程中你创建了你的App的天气模型 &ndash; 现在你需要使用OpenWeatherMap API为你的App来获取一些数据。你将使用两个类抽象数据抓取、分析、存储：<code>WXClient</code>和<code>WXManager</code>。</p>

<p><code>WXClient</code>的唯一责任是创建API请求，并解析它们；别人可以不用担心用数据做什么以及如何存储它。划分类的不同工作职责的设计模式被称为关注点分离。这使你的代码更容易理解，扩展和维护。</p>

<h2>与ReactiveCocoa工作</h2>

<p>确保你使用<code>SimpleWeather.xcworkspace</code>,打开<code>WXClient.h</code>并增加imports</p>

<p>```objc
@import CoreLocation;</p>

<h1>import &lt;ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h></h1>

<p>```</p>

<p><code>
注意：您可能之前没有见过的@import指令，它在Xcode5中被引入，是由苹果公司看作是一个现代的，更高效的替代 #import。有一个非常好的教程，涵盖了最新的Objective-C特性-[What’s New in Objective-C and Foundation in iOS 7](http://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7)。
</code></p>

<p>在<code>WXClient.h</code>中添加下列四个方法到接口申明：</p>

<p><code>objc
@import Foundation;
- (RACSignal *)fetchJSONFromURL:(NSURL *)url;
- (RACSignal *)fetchCurrentConditionsForLocation:(CLLocationCoordinate2D)coordinate;
- (RACSignal *)fetchHourlyForecastForLocation:(CLLocationCoordinate2D)coordinate;
- (RACSignal *)fetchDailyForecastForLocation:(CLLocationCoordinate2D)coordinate;
</code></p>

<p>现在，似乎是一个很好的机会来介绍<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>！</p>

<p>ReactiveCocoa（RAC）是一个Objective-C的框架，用于函数式反应型编程，它提供了组合和转化数据流的API。代替专注于编写串行的代码 &ndash; 执行有序的代码队列 &ndash; 可以响应非确定性事件。</p>

<p>Github上提供的<a href="https://github.com/blog/1107-reactivecocoa-for-a-better-world">a great overview of the benefits</a>：</p>

<ul>
<li>对未来数据的进行组合操作的能力。</li>
<li>减少状态和可变性。</li>
<li>用声明的形式来定义行为和属性之间的关系。</li>
<li>为异步操作带来一个统一的，高层次的接口。</li>
<li>在KVO的基础上建立一个优雅的API。</li>
</ul>


<p>例如，你可以监听<code>username</code>属性的变化，用这样的代码:</p>

<p>```objc
[RACAble(self.username) subscribeNext:^(NSString *newName) {</p>

<pre><code>NSLog(@"%@", newName);
</code></pre>

<p>}];
```</p>

<p><code>subscribeNext</code>这个block会在<code>self.username</code>属性变化的时候执行。新的值会传递给这个block。</p>

<p>您还可以合并信号并组合数据到一个组合数据中。下面的示例取自于ReactiveCocoa的Github页面：</p>

<p>```objc
[[RACSignal</p>

<pre><code>combineLatest:@[ RACAble(self.password), RACAble(self.passwordConfirmation) ] 
       reduce:^(NSString *currentPassword, NSString *currentConfirmPassword) {
           return [NSNumber numberWithBool:[currentConfirmPassword isEqualToString:currentPassword]];
       }] 
subscribeNext:^(NSNumber *passwordsMatch) {
    self.createEnabled = [passwordsMatch boolValue];
}];
</code></pre>

<p>```</p>

<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACSignal.h">RACSignal</a>对象捕捉当前和未来的值。信号可以被观察者链接，组合和反应。信号实际上不会执行，直到它被订阅。</p>

<p>这意味着调用<code>[mySignal fetchCurrentConditionsForLocation：someLocation];</code>不会做什么，但创建并返回一个信号。你将看到之后如何订阅和反应。</p>

<p>打开<code>WXClient.m</code>加入以下imports:</p>

<p>```objc</p>

<h1>import &ldquo;WXCondition.h&rdquo;</h1>

<h1>import &ldquo;WXDailyForecast.h&rdquo;</h1>

<p>```</p>

<p>在imports下，添加私有接口：</p>

<p>```objc
@interface WXClient ()</p>

<p>@property (nonatomic, strong) NSURLSession *session;</p>

<p>@end
```</p>

<p>这个接口用这个属性来管理API请求的URL session。</p>

<p>添加以下<code>init</code>放到到<code>@implementation</code>和<code>@end</code>之间：</p>

<p>```objc
&ndash; (id)init {</p>

<pre><code>if (self = [super init]) {
    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
    _session = [NSURLSession sessionWithConfiguration:config];
}
return self;
</code></pre>

<p>}
```</p>

<p>使用<code>defaultSessionConfiguration</code>为您创建session。</p>

<p><code>
注意：如果你以前没有了解过NSURLSession，看看我们的[NSURLSession教程](http://www.raywenderlich.com/51127/nsurlsession-tutorial)，了解更多信息。
</code></p>

<h2>构建信号</h2>

<p>你需要一个主方法来建立一个信号从URL中取数据。你已经知道，需要三种方法来获取当前状况，逐时预报及每日预报。</p>

<p>不是写三个独立的方法，你可以遵守<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>（Don’t Repeat Yourself）的软件设计理念，使您的代码容易维护。</p>

<p>第一次看，以下的一些ReactiveCocoa部分可能看起来相当陌生。别担心，你会一块一块理解他。</p>

<p>增加下列方法到<code>WXClient.m</code>:</p>

<p>```objc
&ndash; (RACSignal <em>)fetchJSONFromURL:(NSURL </em>)url {</p>

<pre><code>NSLog(@"Fetching: %@",url.absoluteString);

// 1
return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    // 2
    NSURLSessionDataTask *dataTask = [self.session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        // TODO: Handle retrieved data
    }];

    // 3
    [dataTask resume];

    // 4
    return [RACDisposable disposableWithBlock:^{
        [dataTask cancel];
    }];
}] doError:^(NSError *error) {
    // 5
    NSLog(@"%@",error);
}];
</code></pre>

<p>}
```</p>

<p>通过一个一个注释，你会看到代码执行以下操作：</p>

<ol>
<li>返回信号。请记住，这将不会执行，直到这个信号被订阅。 <code>- fetchJSONFromURL：</code>创建一个对象给其他方法和对象使用；这种行为有时也被称为<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassFactoryMethods/ClassFactoryMethods.html">工厂模式</a>。</li>
<li>创建一个<a href="https://developer.apple.com/library/IOS/documentation/Foundation/Reference/NSURLSessionDataTask_class/Reference/Reference.html">NSURLSessionDataTask</a>（在iOS7中加入）从URL取数据。你会在以后添加的数据解析。</li>
<li>一旦订阅了信号，启动网络请求。</li>
<li>创建并返回<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACDisposable.h">RACDisposable</a>对象，它处理当信号摧毁时的清理工作。</li>
<li>增加了一个“side effect”，以记录发生的任何错误。side effect不订阅信号，相反，他们返回被连接到方法链的信号。你只需添加一个side effect来记录错误。</li>
</ol>


<p><code>
如果你觉得需要更多一些背景知识，看看由Ash Furrow编写的[这篇文章](http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/)，以便更好地了解ReactiveCocoa的核心概念。
</code></p>

<p>在<code>-fetchJSONFromURL:</code>中找到<code>// TODO: Handle retrieved data</code> ，替换为:</p>

<p>```objc
if (! error) {</p>

<pre><code>NSError *jsonError = nil;
id json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;jsonError];
if (! jsonError) {
    // 1
    [subscriber sendNext:json];
}
else {
    // 2
    [subscriber sendError:jsonError];
}
</code></pre>

<p>}
else {</p>

<pre><code>// 2
[subscriber sendError:error];
</code></pre>

<p>}</p>

<p>// 3
[subscriber sendCompleted];
```</p>

<ol>
<li>当JSON数据存在并且没有错误，发送给订阅者序列化后的JSON数组或字典。</li>
<li>在任一情况下如果有一个错误，通知订阅者。</li>
<li>无论该请求成功还是失败，通知订阅者请求已经完成。</li>
</ol>


<p><code>-fetchJSONFromURL：</code>方法有点长，但它使你的特定的API请求方法变得很简单。</p>

<h2>获取当前状况</h2>

<p>还在<code>WXClient.m</code>中，添加如下方法：</p>

<p>```objc
&ndash; (RACSignal *)fetchCurrentConditionsForLocation:(CLLocationCoordinate2D)coordinate {</p>

<pre><code>// 1
NSString *urlString = [NSString stringWithFormat:@"http://api.openweathermap.org/data/2.5/weather?lat=%f&amp;lon=%f&amp;units=imperial",coordinate.latitude, coordinate.longitude];
NSURL *url = [NSURL URLWithString:urlString];

// 2
return [[self fetchJSONFromURL:url] map:^(NSDictionary *json) {
    // 3
    return [MTLJSONAdapter modelOfClass:[WXCondition class] fromJSONDictionary:json error:nil];
}];
</code></pre>

<p>}
```</p>

<ol>
<li>使用<code>CLLocationCoordinate2D</code>对象的经纬度数据来格式化URL。</li>
<li>用你刚刚建立的创建信号的方法。由于返回值是一个信号，你可以调用其他ReactiveCocoa的方法。 在这里，您将返回值映射到一个不同的值 &ndash; 一个NSDictionary实例。</li>
<li>使用<code>MTLJSONAdapter</code>来转换JSON到<code>WXCondition</code>对象 &ndash; 使用<code>MTLJSONSerializing</code>协议创建的<code>WXCondition</code>。</li>
</ol>


<h2>获取逐时预报</h2>

<p>现在添加根据坐标获取逐时预报的方法到<code>WXClient.m</code>:</p>

<p>```objc
&ndash; (RACSignal *)fetchHourlyForecastForLocation:(CLLocationCoordinate2D)coordinate {</p>

<pre><code>NSString *urlString = [NSString stringWithFormat:@"http://api.openweathermap.org/data/2.5/forecast?lat=%f&amp;lon=%f&amp;units=imperial&amp;cnt=12",coordinate.latitude, coordinate.longitude];
NSURL *url = [NSURL URLWithString:urlString];

// 1
return [[self fetchJSONFromURL:url] map:^(NSDictionary *json) {
    // 2
    RACSequence *list = [json[@"list"] rac_sequence];

    // 3
    return [[list map:^(NSDictionary *item) {
        // 4
        return [MTLJSONAdapter modelOfClass:[WXCondition class] fromJSONDictionary:item error:nil];
    // 5
    }] array];
}];
</code></pre>

<p>}
```</p>

<ol>
<li>再次使用<code>-fetchJSONFromUR</code>方法，映射JSON。注意：重复使用该方法节省了多少代码！</li>
<li>使用JSON的"list"key创建<code>RACSequence</code>。 <code>RACSequences</code>让你对列表进行ReactiveCocoa操作。</li>
<li>映射新的对象列表。调用<code>-map：</code>方法，针对列表中的每个对象，返回新对象的列表。</li>
<li>再次使用<code>MTLJSONAdapter</code>来转换JSON到<code>WXCondition</code>对象。</li>
<li>使用<code>RACSequence</code>的<code>-map</code>方法，返回另一个<code>RACSequence</code>，所以用这个简便的方法来获得一个<code>NSArray</code>数据。</li>
</ol>


<h2>获取每日预报</h2>

<p>最后，添加如下方法到<code>WXClient.m</code>:</p>

<p>```objc
&ndash; (RACSignal *)fetchDailyForecastForLocation:(CLLocationCoordinate2D)coordinate {</p>

<pre><code>NSString *urlString = [NSString stringWithFormat:@"http://api.openweathermap.org/data/2.5/forecast/daily?lat=%f&amp;lon=%f&amp;units=imperial&amp;cnt=7",coordinate.latitude, coordinate.longitude];
NSURL *url = [NSURL URLWithString:urlString];

// Use the generic fetch method and map results to convert into an array of Mantle objects
return [[self fetchJSONFromURL:url] map:^(NSDictionary *json) {
    // Build a sequence from the list of raw JSON
    RACSequence *list = [json[@"list"] rac_sequence];

    // Use a function to map results from JSON to Mantle objects
    return [[list map:^(NSDictionary *item) {
        return [MTLJSONAdapter modelOfClass:[WXDailyForecast class] fromJSONDictionary:item error:nil];
    }] array];
}];
</code></pre>

<p>}
```</p>

<p>是不是看起来很熟悉？是的，这个方法与<code>-fetchHourlyForecastForLocation:</code>方法非常像。除了它使用<code>WXDailyForecast</code>代替<code>WXCondition</code>，并获取每日预报。</p>

<p>构建并运行您的App，现在你不会看到任何新的东西，但这是一个很好机会松一口气，并确保没有任何错误或警告。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/built-layout.jpg" width="320" alt="Labels and Views" /></p>

<h2>管理并存储你的数据</h2>

<p>现在是时间来充实<code>WXManager</code>，这个类会把所有东西结合到一起。这个类实现您App的一些关键功能：</p>

<ul>
<li>它使用<a href="http://www.raywenderlich.com/46988/ios-design-patterns">单例设计模式</a>。</li>
<li>它试图找到设备的位置。</li>
<li>找到位置后，它获取相应的气象数据。</li>
</ul>


<p>打开<code>WXManager.h</code>使用以下代码来替换其内容：</p>

<p>```objc
@import Foundation;
@import CoreLocation;</p>

<h1>import &lt;ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h></h1>

<p>// 1</p>

<h1>import &ldquo;WXCondition.h&rdquo;</h1>

<p>@interface WXManager : NSObject
<CLLocationManagerDelegate></p>

<p>// 2
+ (instancetype)sharedManager;</p>

<p>// 3
@property (nonatomic, strong, readonly) CLLocation <em>currentLocation;
@property (nonatomic, strong, readonly) WXCondition </em>currentCondition;
@property (nonatomic, strong, readonly) NSArray <em>hourlyForecast;
@property (nonatomic, strong, readonly) NSArray </em>dailyForecast;</p>

<p>// 4
&ndash; (void)findCurrentLocation;</p>

<p>@end
```</p>

<ol>
<li>请注意，你没有引入<code>WXDailyForecast.h</code>，你会始终使用<code>WXCondition</code>作为预报的类。 <code>WXDailyForecast</code>的存在是为了帮助Mantle转换JSON到Objective-C。</li>
<li>使用<code>instancetype</code>而不是<code>WXManager</code>，子类将返回适当的类型。</li>
<li>这些属性将存储您的数据。由于<code>WXManager</code>是一个单例，这些属性可以任意访问。设置公共属性为只读，因为只有管理者能更改这些值。</li>
<li>这个方法启动或刷新整个位置和天气的查找过程。</li>
</ol>


<p>现在打开<code>WXManager.m</code>并添加如下imports到文件顶部：</p>

<pre><code>#import "WXClient.h"
#import &lt;TSMessages/TSMessage.h&gt;
</code></pre>

<p>在imports下方，粘贴如下私有接口：</p>

<p>```objc
@interface WXManager ()</p>

<p>// 1
@property (nonatomic, strong, readwrite) WXCondition <em>currentCondition;
@property (nonatomic, strong, readwrite) CLLocation </em>currentLocation;
@property (nonatomic, strong, readwrite) NSArray <em>hourlyForecast;
@property (nonatomic, strong, readwrite) NSArray </em>dailyForecast;</p>

<p>// 2
@property (nonatomic, strong) CLLocationManager <em>locationManager;
@property (nonatomic, assign) BOOL isFirstUpdate;
@property (nonatomic, strong) WXClient </em>client;</p>

<p>@end
```</p>

<ol>
<li>声明你在公共接口中添加的相同的属性，但是这一次把他们定义为<code>可读写</code>，因此您可以在后台更改他们。</li>
<li>为查找定位和数据抓取声明一些私有变量。</li>
</ol>


<p>添加如下通用的单例构造器到<code>@implementation</code>与<code>@end</code>å中间：</p>

<p>```objc
+ (instancetype)sharedManager {</p>

<pre><code>static id _sharedManager = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    _sharedManager = [[self alloc] init];
});

return _sharedManager;
</code></pre>

<p>}
```</p>

<p>然后，你需要设置你的属性和观察者。</p>

<p>添加如下方法到<code>WXManager.m</code>:</p>

<p>```objc
&ndash; (id)init {</p>

<pre><code>if (self = [super init]) {
    // 1
    _locationManager = [[CLLocationManager alloc] init];
    _locationManager.delegate = self;

    // 2
    _client = [[WXClient alloc] init];

    // 3
    [[[[RACObserve(self, currentLocation)
        // 4
        ignore:nil]
        // 5
       // Flatten and subscribe to all 3 signals when currentLocation updates
       flattenMap:^(CLLocation *newLocation) {
           return [RACSignal merge:@[
                                     [self updateCurrentConditions],
                                     [self updateDailyForecast],
                                     [self updateHourlyForecast]
                                     ]];
        // 6
       }] deliverOn:RACScheduler.mainThreadScheduler]
       // 7
     subscribeError:^(NSError *error) {
         [TSMessage showNotificationWithTitle:@"Error" 
                                     subtitle:@"There was a problem fetching the latest weather."
                                         type:TSMessageNotificationTypeError];
     }];
}
return self;
</code></pre>

<p>}
```</p>

<p>你正使用更多的ReactiveCocoa方法来观察和反应数值的变化。上面这些你做了：</p>

<ol>
<li>创建一个位置管理器，并设置它的delegate为<code>self</code>。</li>
<li>为管理器创建<code>WXClient</code>对象。这里处理所有的网络请求和数据分析，这是关注点分离的最佳实践。</li>
<li>管理器使用一个返回信号的ReactiveCocoa脚本来观察自身的<code>currentLocation</code>。这与<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">KVO</a>类似，但更为强大。</li>
<li>为了继续执行方法链，<code>currentLocation</code>必须不为<code>nil</code>。</li>
<li><code>- flattenMap：</code>非常类似于<code>-map：</code>，但不是映射每一个值，它把数据变得扁平，并返回包含三个信号中的一个对象。通过这种方式，你可以考虑将三个进程作为单个工作单元。</li>
<li>将信号传递给主线程上的观察者。</li>
<li>这不是很好的做法，在你的模型中进行UI交互，但出于演示的目的，每当发生错误时，会显示一个banner。</li>
</ol>


<p>接下来，为了显示准确的天气预报，我们需要确定设备的位置。</p>

<h2>查找你的位置</h2>

<p>下一步，你要添加当位置查找到，触发抓取天气数据的代码。</p>

<p>添加如下代码到<code>WXManager.m</code>的实现块中:</p>

<p>```objc
&ndash; (void)findCurrentLocation {</p>

<pre><code>self.isFirstUpdate = YES;
[self.locationManager startUpdatingLocation];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations {
  // 1
  if (self.isFirstUpdate) {
      self.isFirstUpdate = NO;
      return;
  }</p>

<p>  CLLocation *location = [locations lastObject];</p>

<p>  // 2
  if (location.horizontalAccuracy > 0) {
      // 3
      self.currentLocation = location;
      [self.locationManager stopUpdatingLocation];
  }
}
```</p></li>
<li><p>忽略第一个位置更新，因为它一般是缓存值。</p></li>
<li>一旦你获得一定精度的位置，停止进一步的更新。</li>
<li>设置<code>currentLocation</code>，将触发您之前在init中设置的RACObservable。</li>
</ul>


<h2>获取气象数据</h2>

<p>最后，是时候添加在客户端上调用并保存数据的三个获取方法。将三个方法捆绑起来，被之前在<code>init</code>方法中添加的RACObservable订阅。您将返回客户端返回的，能被订阅的，相同的信号。</p>

<p>所有的属性设置发生在<code>-doNext:</code>中。</p>

<p>添加如下代码到<code>WXManager.m</code>:</p>

<p>```objc
&ndash; (RACSignal *)updateCurrentConditions {</p>

<pre><code>return [[self.client fetchCurrentConditionsForLocation:self.currentLocation.coordinate] doNext:^(WXCondition *condition) {
    self.currentCondition = condition;
}];
</code></pre>

<p>}</p>

<ul>
<li><p>(RACSignal <em>)updateHourlyForecast {
  return [[self.client fetchHourlyForecastForLocation:self.currentLocation.coordinate] doNext:^(NSArray </em>conditions) {
      self.hourlyForecast = conditions;
  }];
}</p></li>
<li><p>(RACSignal <em>)updateDailyForecast {
  return [[self.client fetchDailyForecastForLocation:self.currentLocation.coordinate] doNext:^(NSArray </em>conditions) {
      self.dailyForecast = conditions;
  }];
}
```</p></li>
</ul>


<p>它看起来像将一切都连接起来，并蓄势待发。别急！这App实际上并没有告诉管理者做任何事情。
打开<code>WXController.m</code>并导入这管理者到文件的顶部，如下所示：</p>

<p>```objc</p>

<h1>import &ldquo;WXManager.h&rdquo;</h1>

<p>```</p>

<p>添加如下代码到<code>-viewDidLoad:</code>的最后:</p>

<p><code>objc
[[WXManager sharedManager] findCurrentLocation];
</code></p>

<p>这告诉管理类，开始寻找设备的当前位置。</p>

<p>构建并运行您的App，系统会提示您是否允许使用位置服务。你仍然不会看到任何UI的更新，但检查控制台日志，你会看到类似以下内容：</p>

<p><code>
2013-11-05 08:38:48.886 WeatherTutorial[17097:70b] Fetching: http://api.openweathermap.org/data/2.5/weather?lat=37.785834&amp;lon=-122.406417&amp;units=imperial
2013-11-05 08:38:48.886 WeatherTutorial[17097:70b] Fetching: http://api.openweathermap.org/data/2.5/forecast/daily?lat=37.785834&amp;lon=-122.406417&amp;units=imperial&amp;cnt=7
2013-11-05 08:38:48.886 WeatherTutorial[17097:70b] Fetching: http://api.openweathermap.org/data/2.5/forecast?lat=37.785834&amp;lon=-122.406417&amp;units=imperial&amp;cnt=12
</code></p>

<p>这些输出代表你的代码工作正常，网络请求正常执行。</p>

<h2>连接接口</h2>

<p>这是最后一次展示所有获取，映射和存储的数据。您将使用ReactiveCocoa来观察<code>WXManager</code>单例的变化和当新数据到达时更新界面。</p>

<p>还在<code>WXController.m</code>，到<code>- viewDidLoad</code>的底部，并添加下面的代码到<code>[[WXManager sharedManager] findCurrentLocation];</code>之前：</p>

<p>```objc
// 1
[[RACObserve([WXManager sharedManager], currentCondition)
  // 2
  deliverOn:RACScheduler.mainThreadScheduler]
 subscribeNext:^(WXCondition *newCondition) {</p>

<pre><code> // 3
 temperatureLabel.text = [NSString stringWithFormat:@"%.0f°",newCondition.temperature.floatValue];
 conditionsLabel.text = [newCondition.condition capitalizedString];
 cityLabel.text = [newCondition.locationName capitalizedString];

 // 4
 iconView.image = [UIImage imageNamed:[newCondition imageName]];
</code></pre>

<p> }];
```</p>

<ol>
<li>观察<code>WXManager</code>单例的currentCondition。</li>
<li>传递在主线程上的任何变化，因为你正在更新UI。</li>
<li>使用气象数据更新文本标签；你为文本标签使用<code>newCondition</code>的数据，而不是单例。订阅者的参数保证是最新值。</li>
<li>使用映射的图像文件名来创建一个图像，并将其设置为视图的图标。</li>
</ol>


<p>构建并运行您的App，你会看到当前温度，当前状况和表示当前状况的图标。所有的数据都是实时的。但是，如果你的位置是旧金山，它似乎总是约65度。Lucky San Franciscans! :]</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/11/ui-wiring.jpg" width="320" alt="Wiring up the UI" /></p>

<h2>ReactiveCocoa的绑定</h2>

<p>ReactiveCocoa为iOS带来了自己的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html">Cocoa绑定</a>的形式。</p>

<p>不知道是什么绑定？简而言之，他们是一种提供了保持模型和视图的数据同步而无需编写大量"胶水代码"的手段，它们允许你建立一个视图和数据块之间的连接， “结合”它们，使得一方的变化反映到另一个中的技术。</p>

<p>这是一个非常强大的概念，不是吗？</p>

<p><code>
注意：要获得更多的绑定实例代码，请查看[ReactiveCocoa Readme](https://github.com/ReactiveCocoa/ReactiveCocoa)。
</code></p>

<p>添加如下代码到你上一步添加的代码后面：</p>

<p>```objc
// 1
RAC(hiloLabel, text) = [[RACSignal combineLatest:@[</p>

<pre><code>                    // 2
                    RACObserve([WXManager sharedManager], currentCondition.tempHigh),
                    RACObserve([WXManager sharedManager], currentCondition.tempLow)]
                    // 3
                    reduce:^(NSNumber *hi, NSNumber *low) {
                        return [NSString  stringWithFormat:@"%.0f° / %.0f°",hi.floatValue,low.floatValue];
                    }]
                    // 4
                    deliverOn:RACScheduler.mainThreadScheduler];
</code></pre>

<p>```</p>

<p>上面的代码结合高温、低温的值到hiloLabel的text属性。看看你完成了什么：</p>

<ol>
<li>RAC（&hellip;）宏有助于保持语法整洁。从该信号的返回值将被分配给<code>hiloLabel</code>对象的<code>text</code>。</li>
<li>观察<code>currentCondition</code>的高温和低温。合并信号，并使用两者最新的值。当任一数据变化时，信号就会触发。</li>
<li>从合并的信号中，减少数值，转换成一个单一的数据，注意参数的顺序与信号的顺序相匹配。</li>
<li>同样，因为你正在处理UI界面，所以把所有东西都传递到主线程。</li>
</ol>


<p>构建并运行你的App。你应该看到在左下方的高/低温度label更新了：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/11/ui-wiring-hilo.jpg" width="320" alt="UI Wiring with Bindings" /></p>

<h2>在Table View中显示数据</h2>

<p>现在，你已经获取所有的数据，你可以在table view中整齐地显示出来。你会在分页的table view中显示最近6小时的每时播报和每日预报。该App会显示三个页面：一个是当前状况，一个是逐时预报，以及一个每日预报。</p>

<p>之前，你可以添加单元格到table view，你需要初始化和配置一些日期格式化。</p>

<p>到<code>WXController.m</code>最顶端的私有接口处，添加下列两个属性</p>

<p><code>objc
@property (nonatomic, strong) NSDateFormatter *hourlyFormatter;
@property (nonatomic, strong) NSDateFormatter *dailyFormatter;
</code></p>

<p>由于创建日期格式化非常昂贵，我们将在init方法中实例化他们，并使用这些变量去存储他们的引用。</p>

<p>还在<code>WXController.m</code>中，添加如下代码到<code>@implementation</code>中：</p>

<p>```objc
&ndash; (id)init {</p>

<pre><code>if (self = [super init]) {
    _hourlyFormatter = [[NSDateFormatter alloc] init];
    _hourlyFormatter.dateFormat = @"h a";

    _dailyFormatter = [[NSDateFormatter alloc] init];
    _dailyFormatter.dateFormat = @"EEEE";
}
return self;
</code></pre>

<p>}
```</p>

<p>你可能想知道为什么在<code>-init</code>中初始化这些日期格式化，而不是在<code>-viewDidLoad</code>中初始化他们。好问题！</p>

<p>实际上<code>-viewDidLoad</code>可以在一个视图控制器的生命周期中多次调用。 <a href="http://www.rsaunders.co.uk/2012/02/nsdateformatter-are-expensive.html">NSDateFormatter对象的初始化是昂贵的</a>，而将它们放置在你的<code>-init</code>，会确保被你的视图控制器初始化一次。</p>

<p>在<code>WXController.m</code>中，寻找<code>tableView:numberOfRowsInSection：</code>,并用如下代码更换<code>TODO</code>到<code>return</code>：</p>

<p>```objc
// 1
if (section == 0) {</p>

<pre><code>return MIN([[WXManager sharedManager].hourlyForecast count], 6) + 1;
</code></pre>

<p>}
// 2
return MIN([[WXManager sharedManager].dailyForecast count], 6) + 1;
```</p>

<ol>
<li>第一部分是对的逐时预报。使用最近6小时的预预报，并添加了一个作为页眉的单元格。</li>
<li>接下来的部分是每日预报。使用最近6天的每日预报，并添加了一个作为页眉的单元格。</li>
</ol>


<p><code>
注意：您使用表格单元格作为标题，而不是内置的、具有粘性的滚动行为的标题。这个table view设置了分页，粘性滚动行为看起来会很奇怪。
</code></p>

<p>在<code>WXController.m</code>找到<code>tableView:cellForRowAtIndexPath:</code>,并用如下代码更换<code>TODO</code>：</p>

<p>```objc
if (indexPath.section == 0) {</p>

<pre><code>// 1
if (indexPath.row == 0) {
    [self configureHeaderCell:cell title:@"Hourly Forecast"];
}
else {
    // 2
    WXCondition *weather = [WXManager sharedManager].hourlyForecast[indexPath.row - 1];
    [self configureHourlyCell:cell weather:weather];
}
</code></pre>

<p>}
else if (indexPath.section == 1) {</p>

<pre><code>// 1
if (indexPath.row == 0) {
    [self configureHeaderCell:cell title:@"Daily Forecast"];
}
else {
    // 3
    WXCondition *weather = [WXManager sharedManager].dailyForecast[indexPath.row - 1];
    [self configureDailyCell:cell weather:weather];
}
</code></pre>

<p>}
```</p>

<ol>
<li>每个部分的第一行是标题单元格。</li>
<li>获取每小时的天气和使用自定义配置方法配置cell。</li>
<li>获取每天的天气，并使用另一个自定义配置方法配置cell。</li>
</ol>


<p>最后，添加如下代码到<code>WXController.m</code>:</p>

<p>```objc
// 1
&ndash; (void)configureHeaderCell:(UITableViewCell <em>)cell title:(NSString </em>)title {</p>

<pre><code>cell.textLabel.font = [UIFont fontWithName:@"HelveticaNeue-Medium" size:18];
cell.textLabel.text = title;
cell.detailTextLabel.text = @"";
cell.imageView.image = nil;
</code></pre>

<p>}</p>

<p>// 2
&ndash; (void)configureHourlyCell:(UITableViewCell <em>)cell weather:(WXCondition </em>)weather {</p>

<pre><code>cell.textLabel.font = [UIFont fontWithName:@"HelveticaNeue-Light" size:18];
cell.detailTextLabel.font = [UIFont fontWithName:@"HelveticaNeue-Medium" size:18];
cell.textLabel.text = [self.hourlyFormatter stringFromDate:weather.date];
cell.detailTextLabel.text = [NSString stringWithFormat:@"%.0f°",weather.temperature.floatValue];
cell.imageView.image = [UIImage imageNamed:[weather imageName]];
cell.imageView.contentMode = UIViewContentModeScaleAspectFit;
</code></pre>

<p>}</p>

<p>// 3
&ndash; (void)configureDailyCell:(UITableViewCell <em>)cell weather:(WXCondition </em>)weather {</p>

<pre><code>cell.textLabel.font = [UIFont fontWithName:@"HelveticaNeue-Light" size:18];
cell.detailTextLabel.font = [UIFont fontWithName:@"HelveticaNeue-Medium" size:18];
cell.textLabel.text = [self.dailyFormatter stringFromDate:weather.date];
cell.detailTextLabel.text = [NSString stringWithFormat:@"%.0f° / %.0f°",
                              weather.tempHigh.floatValue,
                              weather.tempLow.floatValue];
cell.imageView.image = [UIImage imageNamed:[weather imageName]];
cell.imageView.contentMode = UIViewContentModeScaleAspectFit;
</code></pre>

<p>}
```</p>

<ol>
<li>配置和添加文本到作为section页眉单元格。你会重用此为每日每时的预测部分。</li>
<li>格式化逐时预报的单元格。</li>
<li>格式化每日预报的单元格。</li>
</ol>


<p>构建并运行您的App，尝试滚动你的table view，并&hellip;等一下。什么都没显示！怎么办？</p>

<p>如果你已经使用过的<code>UITableView</code>，可能你之前遇到过问题。这个table没有重新加载！</p>

<p>为了解决这个问题，你需要添加另一个针对每时预报和每日预报属性的ReactiveCocoa观察。</p>

<p>在<code>WXController.m</code>的<code>-viewDidLoad</code>中，添加下列代码到其他ReactiveCocoa观察代码中：</p>

<p>```objc
[[RACObserve([WXManager sharedManager], hourlyForecast)</p>

<pre><code>   deliverOn:RACScheduler.mainThreadScheduler]
</code></pre>

<p>   subscribeNext:^(NSArray *newForecast) {</p>

<pre><code>   [self.tableView reloadData];
</code></pre>

<p>   }];</p>

<p>[[RACObserve([WXManager sharedManager], dailyForecast)</p>

<pre><code>   deliverOn:RACScheduler.mainThreadScheduler]
</code></pre>

<p>   subscribeNext:^(NSArray *newForecast) {</p>

<pre><code>   [self.tableView reloadData];
</code></pre>

<p>   }];
```</p>

<p>构建并运行App；滚动table view，你将看到填充的所有预报数据。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/unaligned-heights.jpg" width="320" alt="Forecast with Odd Heights" /></p>

<h2>给你的App添加效果</h2>

<p>本页面为每时和每日预报不会占满整个屏幕。幸运的是，有一个非常简单的修复办法。在本教程前期，您在<code>-viewDidLoad</code>中获得屏幕高度。</p>

<p>在<code>WXController.m</code>中，查找table view的委托方法<code>-tableView:heightForRowAtIndexPath:</code>，并且替换<code>TODO</code>到<code>return</code>的代码:</p>

<p><code>objc
NSInteger cellCount = [self tableView:tableView numberOfRowsInSection:indexPath.section];
return self.screenHeight / (CGFloat)cellCount;
</code></p>

<p>屏幕高度由一定数量的cell所分割，所以所有cell的总高度等于屏幕的高度。</p>

<p>构建并运行你的App；table view填满了整个屏幕，如下所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/11/aligned-heights.jpg" width="320" alt="Forecast with Full Height" /></p>

<p>最后要做的是把我在本教程的第一部分开头提到的模糊效果引入。当你滚动预报页面，模糊效果应该动态显示。</p>

<p>添加下列scroll delegate到<code>WXController.m</code>最底部：</p>

<p>```objc</p>

<h1>pragma mark &ndash; UIScrollViewDelegate</h1>

<ul>
<li><p>(void)scrollViewDidScroll:(UIScrollView *)scrollView {
  // 1
  CGFloat height = scrollView.bounds.size.height;
  CGFloat position = MAX(scrollView.contentOffset.y, 0.0);
  // 2
  CGFloat percent = MIN(position / height, 1.0);
  // 3
  self.blurredImageView.alpha = percent;
}
```</p></li>
<li><p>获取滚动视图的高度和内容偏移量。与0偏移量做比较，因此试图滚动table低于初始位置将不会影响模糊效果。</p></li>
<li>偏移量除以高度，并且最大值为1，所以alpha上限为1。</li>
<li>当你滚动的时候，把结果值赋给模糊图像的alpha属性，来更改模糊图像。</li>
</ul>


<p>构建并运行App，滚动你的table view，并查看这令人惊异的模糊效果：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/11/with-blur.jpg" width="320" alt="Finished Product" /></p>

<h2>何去何从？</h2>

<p>在本教程中你已经完成了很多内容：您使用CocoaPods创建了一个项目，完全用代码书写了一个视图结构，创建数据模型和管理类，并使用函数式编程将他们连接到一起！</p>

<p>您可以从<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/11/SimpleWeather-Part-2.zip">这里下载</a>该项目的完成版本。</p>

<p>这个App还有很多酷的东西可以去做。一个好的开始是使用<a href="http://www.flickr.com/services/api/">Flickr API</a>来查找基于设备位置的背景图像。</p>

<p>还有，你的应用程序只处理温度和状态;有什么其他的天气信息能融入你的App？</p>
]]></content>
  </entry>
  
</feed>
