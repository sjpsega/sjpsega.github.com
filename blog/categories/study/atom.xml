<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | sjpsega's Blog]]></title>
  <link href="http://sjpsega.com/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://sjpsega.com/"/>
  <updated>2014-10-02T01:28:03+08:00</updated>
  <id>http://sjpsega.com/</id>
  <author>
    <name><![CDATA[sjpsega]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Object-C Method Swizzling]]></title>
    <link href="http://sjpsega.com/blog/2014/09/17/oc-method-swizzling/"/>
    <updated>2014-09-17T22:36:40+08:00</updated>
    <id>http://sjpsega.com/blog/2014/09/17/oc-method-swizzling</id>
    <content type="html"><![CDATA[<p>Objective-C 中的 Method Swizzling 是一种可以在程序运行时，修改方法调用的技术。是 OC 作为动态语言的典型证明。</p>

<h2>例子</h2>

<p>以替换 NSArray 的 lastObject 方法为例：</p>

<ul>
<li>在 NSArray 中添加需要替换 lastObject 的方法 &ndash; xxx_lastObject方法：</li>
</ul>


<p>~~~objc</p>

<h1>import &ldquo;NSArray+Swizzle.h&rdquo;</h1>

<p>@implementation NSArray (Swizzle)</p>

<ul>
<li><p>(id)xxx_lastObject<br/>
{<br/>
  id ret = [self xxx_lastObject];<br/>
  NSLog(@&ldquo;<strong><strong><strong><strong><strong>  myLastObject </strong></strong></strong></strong></strong>*&rdquo;);<br/>
  return ret;<br/>
}<br/>
@end<br/>
~~~
注意这里的写法，xxx_lastObject 方法的 IMP 中调用了 [self xxx_lastObject]，这样写并不会造成递归，后面会交换 xxx_lastObject 与 lastObject 的 IMP，其实 [self xxx_lastObject] 将会执行 [self lastObject] 。</p></li>
<li><p>调换 IMP</p></li>
</ul>


<p>```objc</p>

<h1>import &lt;objc/runtime.h></h1>

<h1>import &ldquo;NSArray+Swizzle.h&rdquo;</h1>

<p>Method ori_Method =  class_getInstanceMethod([NSArray class], @selector(lastObject));<br/>
Method my_Method = class_getInstanceMethod([NSArray class], @selector(xxx_lastObject));<br/>
method_exchangeImplementations(ori_Method, my_Method);<br/>
<code>``
注意这里需要引入</code>&lt;objc/runtime.h>`，否则会报错，因为使用了 runtime 中的 method_exchangeImplementations 方法。</p>

<p>使用 <code>method_exchangeImplementations</code> 交换了 xxx_lastObject 与 lastObject 的 IMP。后面会讲解更深层次的原理。</p>

<ul>
<li>尝试调用 lastObject</li>
</ul>


<p>```objc</p>

<h1>import &lt;objc/runtime.h></h1>

<h1>import &ldquo;NSArray+Swizzle.h&rdquo;</h1>

<p>NSArray <em>array = @[@&ldquo;0&rdquo;,@&ldquo;1&rdquo;,@&ldquo;2&rdquo;,@&ldquo;3&rdquo;];<br/>
NSString </em>string = [array lastObject];<br/>
NSLog(@&ldquo;TEST RESULT : %@&rdquo;,string);<br/>
```</p>

<p>输出结果为:</p>

<p><code>objc
**********  myLastObject ***********
TEST RESULT : 3
</code></p>

<p>很明显，这里调用 lastObject 方法，其实是调用了我们添加的 xxx_lastObject 方法。</p>

<h2>常用 API</h2>

<p>相关常用方法，都在<code>&lt;objc/runtime.h&gt;</code>包内：
~~~ojbc
//向类中添加Method
BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</p>

<p>//修改类的Method
IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</p>

<p>//交换2个方法中的IMP
void method_exchangeImplementations(Method m1, Method m2)</p>

<p>//获取类的某个实例方法
Method class_getInstanceMethod(Class aClass, SEL aSelector);
~~~</p>

<h2>底层原理</h2>

<p>在运行时，OC 的方法被称为一种叫 <code>Method</code> 的结构体，这种 <code>objc_method</code> 类型的结构体定义为：</p>

<p><code>objc
struct objc_method
   SEL method_name         OBJC2_UNAVAILABLE;
   char *method_types      OBJC2_UNAVAILABLE;
   IMP method_imp          OBJC2_UNAVAILABLE;
}
</code>
* method_name 是方法的 selector，可以理解为运行时的方法名；
* *method_types 是一个参数和返回值类型<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">编码</a>的字符串；
* method_imp 是指向方法实现的指针。</p>

<p><code>Method Swizzling 的实质是在运行时，访问对象的方法结构体，并改变它的底层实现。</code></p>

<p>我们以上节修改 NSArray 的 lastObject 为例做说明。</p>

<ul>
<li>初始时，lastObject 与 xxx_lastObject 方法的 Method 结构体：</li>
</ul>


<p>```objc
Method lastObject {</p>

<pre><code>  SEL method_name = @selector(lastObject)
  char *method_types = “v@:“ //返回值void, 参数id(self)，selector(_cmd)
  IMP method_imp = 0x000FFFF //指向([NSArray lastObject])
</code></pre>

<p>}</p>

<p>Method xxx_lastObject {</p>

<pre><code>   SEL method_name = @selector(swizzle_originalMethodName)
   char *method_types = “v@:”
   IMP method_imp = 0x1234AABA //指向([NSArray xxx_lastObject])
</code></pre>

<p>}
```</p>

<ul>
<li>调用 <code>void method_exchangeImplementations(Method m1, Method m2)</code> ,交换两者的实现：</li>
</ul>


<p><code>objc
Method ori_Method =  class_getInstanceMethod([NSArray class], @selector(lastObject));  
Method my_Method = class_getInstanceMethod([NSArray class], @selector(xxx_lastObject));  
method_exchangeImplementations(ori_Method, my_Method);
</code></p>

<ul>
<li>调换后的 Method 结构体：</li>
</ul>


<p>```objc
Method lastObject {</p>

<pre><code>  SEL method_name = @selector(lastObject)
  char *method_types = “@@:“ //返回值id, 参数id(self)，selector(_cmd)
  IMP method_imp = 0x1234AABA //指向([NSArray xxx_lastObject])
</code></pre>

<p>}</p>

<p>Method xxx_lastObject {</p>

<pre><code>   SEL method_name = @selector(swizzle_originalMethodName)
   char *method_types = “@@:”
   IMP method_imp = 0x000FFFF //指向([NSArray lastObject])
</code></pre>

<p>}
```</p>

<p>可以看到使用<code>void method_exchangeImplementations(Method m1, Method m2)</code>的实质是交换了xxx_lastObject 与 lastObject 的 IMP，实现了在运行时做方法的替换。使得当执行 [array lastObject] 的时候，实际会去执行 [array xxx_lastObject] 的方法实现。</p>

<h2>用处</h2>

<p>Method Swizzling 非常强大，主要作用有
* 修改 iOS 系统类库的方法
* 动态添加、修改方法，修复线上 bug（如果 Apple 官方允许的话）</p>

<h2>其他提示</h2>

<h3>+load</h3>

<p>Swizzling 的处理，在类的 <code>+load</code> 方法中完成。</p>

<p>因为 <code>+load</code> 方法会在类被添加到 OC 运行时执行，保证了 Swizzling 方法的及时处理。</p>

<h3>dispatch_once</h3>

<p>Swizzling 的处理，<code>dispatch_once</code> 中完成。保证只执行一次。</p>

<h3>prefix</h3>

<p>Swizzling 方法添加前缀，避免方法名称冲突。</p>

<h2>参考资料</h2>

<p><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">Objective-C的hook方案（一）:  Method Swizzling</a></p>

<p><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></p>

<p><a href="http://stackoverflow.com/questions/3267506/how-to-swizzle-a-class-method-on-ios">How to swizzle a class method on iOS?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS H5的那些坑]]></title>
    <link href="http://sjpsega.com/blog/2014/08/06/ios-h5-trap/"/>
    <updated>2014-08-06T17:47:30+08:00</updated>
    <id>http://sjpsega.com/blog/2014/08/06/ios-h5-trap</id>
    <content type="html"><![CDATA[<p>最近做 iOS H5 项目，需要针对 iOS 的 webView 做适配，发现几个非常恶心的 bug。</p>

<p>因为现在据统计 iOS7 的占比超过80%，所以适配主要针对 iOS7，但是 iOS7 不同版本缺有不同的 bug，真是让人蛋疼。</p>

<h2>iOS 7.0 input 元素聚焦问题</h2>

<h3>bug 演示</h3>

<p><img src="/images/2014-08-06-ios-h5-trap/ios7.0bug.gif" alt="ios7.0bug.gif" /></p>

<h3>bug 分析</h3>

<p>点击屏幕下方的input元素，且该元素在键盘弹起的区域内；当键盘弹起时，input 元素未获得焦点，且 input 元素不在可视范围内，没有进行自动定位调整。</p>

<p>但 input 元素不在键盘弹起的区域内，当键盘弹起时，一切正常。</p>

<p>该 bug，iOS &lt; 7.1 有问题，>=7.1 无问题。</p>

<h3>解决办法</h3>

<p>办法有点猥琐，要通过 js，去强制 input 元素获得焦点。</p>

<p><code>javascript
element.on("tap", function(e){
  element.focus();
});
</code></p>

<h3>参考资料</h3>

<p><a href="http://stackoverflow.com/questions/16149083/keyboardshrinksview-makes-lose-focus">KeyboardShrinksView makes lose focus</a></p>

<p><a href="https://issues.apache.org/jira/browse/CB-6974">Keyboard causes input focus issue</a></p>

<h2>iOS 7.1 input 元素失焦问题</h2>

<h3>bug 演示</h3>

<p><img src="/images/2014-08-06-ios-h5-trap/ios7.1bug.gif" alt="ios7.1bug.gif" /></p>

<h3>bug 分析</h3>

<p>点击 input 元素（input 元素在不在浮层中不重要），弹出键盘时，当点击 Html 中的元素，致使 input 元素失去焦点，键盘收起，position:fixed 元素（演示中的浮层为 position:fixed）会导致界面错乱。</p>

<p>但若点击键盘右上角的 <code>完成</code> 按钮，键盘收起，一切正常。</p>

<p>也就是说，使用 iOS 系统的方式使得键盘收起，没有问题；使用其他方式，使得键盘收起，position:fixed 元素会导致界面错乱。</p>

<p>该 bug，iOS >= 7.1 有问题，&lt; 7.1 无问题。正好与iOS 7.0 input 元素聚焦 bug 的情况相反。</p>

<p><code>注：iOS 键盘的操作，必须由用户的操作引发，想通过 JSBridge 去让键盘收起的方案是行不通的。</code></p>

<h3>解决办法</h3>

<p>避免使用 position:fixed，换成 position:absolute 替代。</p>

<h3>参考资料</h3>

<p><a href="http://stackoverflow.com/questions/18970865/ios-7-input-elements-moving-fixed-positioned-elements">ios-7-input-elements-moving-fixed-positioned-elements</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《#3 Views》 学习笔记]]></title>
    <link href="http://sjpsega.com/blog/2014/07/06/views-note/"/>
    <updated>2014-07-06T17:15:53+08:00</updated>
    <id>http://sjpsega.com/blog/2014/07/06/views-note</id>
    <content type="html"><![CDATA[<p>文章地址：<a href="http://objccn.io/issue-3/">objc第三章</a></p>

<h2>绘制像素到屏幕上</h2>

<h2>理解 Scroll Views</h2>

<h3>光栅化和组合</h3>

<p>渲染过程的第一部分是众所周知的光栅化(<code>rasterization</code>)，光栅化简单的说就是产生一组绘图指令并且生成一张图片。</p>

<p>每个视图都有一个 <code>bounds</code> 和 <code>frame</code>。当布局一个界面时，我们需要处理视图的 frame。这允许我们放置并设置视图的大小。视图的 frame 和 bounds 的大小总是一样的，但是他们的 origin 有可能不同。</p>

<p><img src="/images/2014-07-06-views-note/scrollview_1.png" alt="scrollview_1" /></p>

<p>视图图片的左上角会根据它 frame 的 origin 进行偏移，并绘制到父视图的图片上：</p>

<p>```objc
CompositedPosition.x = View.frame.origin.x &ndash; Superview.bounds.origin.x;</p>

<p>CompositedPosition.y = View.frame.origin.y &ndash; Superview.bounds.origin.y;
```</p>

<p>正如之前所说的，如果一个视图 bounds 的 origin 是 {0,0}。那么，我们得到这个公式：</p>

<p>```objc
CompositedPosition.x = View.frame.origin.x;</p>

<p>CompositedPosition.y = View.frame.origin.y;
```</p>

<h3>Scroll View的Content Offset</h3>

<p>```objc
CompositedPosition.x = View.frame.origin.x &ndash; Superview.bounds.origin.x;</p>

<p>CompositedPosition.y = View.frame.origin.y &ndash; Superview.bounds.origin.y;
```</p>

<p>我们减少 <code>Superview.bounds.origin</code> 的值(因为他们总是0)。但是如果他们不为0呢？我们用和前一个图例相同的 frames，但是我们改变了紫色视图 bounds 的 origin 为 {-30, -30}。得到下图：</p>

<p><img src="/images/2014-07-06-views-note/scrollview_4.png" alt="scrollview_4" /></p>

<p>现在，巧妙的是通过改变这个紫色视图的 bounds，它每一个单独的子视图都被移动了。事实上，这正是 scroll view 工作的原理。当你设置它的 contentOffset 属性时它改变 scroll view.bounds 的 origin。事实上，contentOffset 甚至不是实际存在的。代码看起来像这样：</p>

<p>```objc
&ndash; (void)setContentOffset:(CGPoint)offset
{</p>

<pre><code>CGRect bounds = [self bounds];
bounds.origin = offset;
[self setBounds:bounds];
</code></pre>

<p>}
```</p>

<h3>Content Size</h3>

<p>content size 定义了可滚动区域。</p>

<p>当 content size 设置为比 bounds 大的时候，用户就可以滚动视图了。</p>

<p><img src="/images/2014-07-06-views-note/scrollview_5.png" alt="scrollview_5" /></p>

<h3>用Content Insets对窗口稍作调整</h3>

<p>contentInset 属性可以改变 content offset 的最大和最小值，这样便可以滚动出可滚动区域。</p>

<p>实际使用：</p>

<ul>
<li>下拉刷新的实现</li>
</ul>


<p><img src="/images/2014-07-06-views-note/scrollview_6.png" alt="scrollview_6" /></p>

<ul>
<li>键盘出现，不遮挡可视区域</li>
</ul>


<p>当键盘出现在屏幕上时，设置 content inset 的底部等于键盘的高度。</p>

<p><img src="/images/2014-07-06-views-note/scrollview_7.png" alt="scrollview_7" /></p>

<h2>自定义 Collection View 布局</h2>

<h3>布局对象 (Layout Objects)</h3>

<p>UITableView 和 UICollectionView 都是 data-source 和 delegate 驱动的。</p>

<p>布局继承自 UICollectionViewLayout 抽象基类。</p>

<h3>Cells 和其他 Views</h3>

<p>Collection view 的 cell 必须是 UICollectionViewCell 的子类。除了 cell，collection view 额外管理着两种视图：supplementary views 和 decoration views。</p>

<p><code>Supplementary views</code> 相当于 table view 的 section header 和 footer views。像 cells 一样，他们的内容都由数据源对象驱动。然而和 table view 中用法不一样，supplementary view 并不一定会作为 header 或 footer view；他们的数量和放置的位置完全由布局控制。</p>

<p><code>Decoration views</code> 纯粹为一个装饰品。他们完全属于布局对象，并被布局对象管理，他们并不从 data source 获取的 contents。当布局对象指定需要一个 decoration view 的时候，collection view 会自动创建，并将布局对象提供的布局参数应用到上面去。并不需要为自定义视图准备任何内容。</p>

<p>Supplementary views 和 decoration views 必须是 <code>UICollectionResuableView</code> 的子类。</p>

<h3>自定义布局</h3>

<p>一般有两种类型的 collection view 布局：</p>

<ul>
<li>独立于内容的布局计算</li>
<li>基于内容的布局计算</li>
</ul>


<h4>collectionViewContentSize</h4>

<p>布局首先要提供的信息就是滚动区域大小，这样 collection view 才能正确的管理滚动。布局对象必须在此时计算它内容的总大小，包括 supplementary views 和 decoration views。</p>

<h4>layoutAttributesForElementsInRect:</h4>

<p>具体实现必须返回一个包含 <code>UICollectionViewLayoutAttributes</code> 对象的数组，为每一个 cell 包含一个这样的对象，supplementary view 或 decoration view 在矩形区域内是可见的。UICollectionViewLayoutAttributes 类包含了 collection view 内 item 的所有相关布局属性。默认情况下，这个类包含 frame，center，size，transform3D，alpha，zIndex 和 hidden属性。</p>

<p>这个方法涉及到所有类型的视图，也就是 cell，supplementary views 和 decoration views。</p>

<p>实现需要做这几步：</p>

<ol>
<li><p>创建一个空的可变数组来存放所有的布局属性。</p></li>
<li><p>确定 index paths 中哪些 cells 的 frame 完全或部分位于矩形中。这个计算需要你从 collection view 的数据源中取出你需要显示的数据。然后在循环中调用你实现的 <code>layoutAttributesForItemAtIndexPath:</code> 方法为每个 index path 创建并配置一个合适的布局属性对象，并将每个对象添加到数组中。</p></li>
<li><p>如果你的布局包含 supplementary views，计算矩形内可见 supplementary view 的 index paths。在循环中调用你实现的 <code>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</code> ，并且将这些对象加到数组中。通过为 kind 参数传递你选择的不同字符，你可以区分出不同种类的supplementary views（比如headers和footers）。当需要创建视图时，collection view 会将 kind 字符传回到你的数据源。记住 supplementary 和 decoration views 的数量和种类完全由布局控制。你不会受到 headers 和 footers 的限制。</p></li>
<li><p>如果布局包含 decoration views，计算矩形内可见 decoration views 的 index paths。在循环中调用你实现的 layoutAttributesForDecorationViewOfKind:atIndexPath: ，并且将这些对象加到数组中。</p></li>
<li><p>返回数组。</p></li>
</ol>


<h4>layoutAttributesFor…IndexPath</h4>

<table>
<thead>
<tr>
<th>方法</th>
<th>创建布局对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>layoutAttributesForItemAtIndexPath:</td>
<td>[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]</td>
</tr>
<tr>
<td>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</td>
<td>[UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind:withIndexPath:]</td>
</tr>
<tr>
<td>layoutAttributesForDecorationViewOfKind:atIndexPath:</td>
<td>[UICollectionViewLayoutAttributes layoutAttributesForDecorationViewOfKind:withIndexPath:]</td>
</tr>
</tbody>
</table>


<h4>shouldInvalidateLayoutForBoundsChange</h4>

<p>当 collection view 的 bounds 改变时，布局需要告诉 collection view 是否需要重新计算布局。</p>

<h3>动画</h3>

<h4>插入和删除</h4>

<p>对应实现的方法：</p>

<ul>
<li>initialLayoutAttributesForAppearingItemAtIndexPath:</li>
<li>initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath:</li>
<li>initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath:</li>
<li>finalLayoutAttributesForDisappearingItemAtIndexPath:</li>
<li>finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath:</li>
<li>finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:</li>
</ul>


<h4>布局间切换</h4>

<p>可以通过调用 <code>setCollectionViewLayout:animated:</code> 将一个 collection view 布局动态的切换到另外一个布局。</p>

<h2>自定义控件</h2>

<h3>视图层次概览</h3>

<h4>UIResponder</h4>

<p>UIResponder 是 <code>UIView</code> 的父类。responder 能够处理触摸、手势、远程控制等事件。</p>

<p>UIResponder 的子类有 <code>UIView</code>、<code>UIApplication</code>、<code>UIViewController</code>。</p>

<p>通过重写 UIResponder 的方法，可以决定一个类是否可以成为第一响应者 (first responder)，例如当前输入焦点元素。</p>

<p>UIResponder 允许自定义输入方法，使用 inputAccessoryView 向键盘添加辅助视图；使用 inputView 提供一个完全自定义的键盘。</p>

<h4>UIView</h4>

<p>UIView 子类处理所有跟内容绘制有关的事情以及触摸时间。</p>

<p>一个普遍错误的概念：视图的区域是由它的 frame 定义的。实际上 <code>frame</code> 是一个<code>派生属性</code>，是由 <code>center</code> 和 <code>bounds</code> 合成而来。</p>

<h4>UIControl</h4>

<p>UIControl 建立在视图上，增加了更多的交互支持。</p>

<p>最重要的是，它增加了 target / action 模式。</p>

<h3>渲染</h3>

<p>尽量避免 <code>drawRect:</code>，使用现有的视图构建自定义视图。</p>

<p>通常最快速的渲染方法是使用图片视图。</p>

<p>把可拉伸的图片和图片视图一起使用也可以极大的提高效率。可拉伸图片是这些技术中最快的。原因是可拉伸图片在 CPU 和 GPU 之间的数据转移量最小，并且这些图片的绘制是经过高度优化的。(<code>-[UIImage resizableImageWithCapInsets:resizingMode:]</code>)</p>

<h4>自定义绘制</h4>

<p>技术选择：</p>

<p>图片 > Core Animation > Core Graphics > GLKit 和原生 OpenGL</p>

<p>若重写 <code>drawRect:</code>，确保检查内容模式。默认的模式是将内容缩放以填充视图的范围，这在当视图的 frame 改变时并不会重新绘制。</p>

<h3>自定义交互</h3>

<p>创建自定义控件时所面对的一个普遍的设计问题是向拥有它们的类中回传返回值。可选择的方式有 target action 模式，代理，block 或者 KVO，甚至通知。</p>

<h4>使用 Target-Action</h4>

<p>最方便的做法是使用 target-action。</p>

<p>自定义视图中：
<code>objc
[self sendActionsForControlEvents:UIControlEventValueChanged];
</code></p>

<p>视图控制器中：
```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>[self.pieChart addTarget:self
              action:@selector(updateSelection:)
    forControlEvents:UIControlEventValueChanged];
</code></pre>

<p>}</p>

<ul>
<li>(void)updateSelection:(id)sender
{
  NSLog(@&ldquo;%@&rdquo;, self.pieChart.selectedSector);
}
```
这么做的好处是在自定义视图子类中需要做的事情很少，并且自动获得多目标支持。</li>
</ul>


<h4>使用代理</h4>

<p>如果你需要更多的控制从视图发送到视图控制器的消息，通常使用代理模式。</p>

<p>自定义视图中：
<code>objc
[self.delegate pieChart:self didSelectSector:self.selectedSector];
</code></p>

<p>视图控制器中:
```objc
@interface MyViewController <PieChartDelegate></p>

<p> &hellip;</p>

<ul>
<li><p>(void)setupPieChart
{
  self.pieChart.delegate = self;
}</p></li>
<li><p>(void)pieChart:(PieChart<em>)pieChart didSelectSector:(PieChartSector</em>)sector
{
  // 处理区块
}
```
当你想要做更多复杂的工作而不仅仅是通知所有者值发生了变化时，这么做显然更合适。</p></li>
</ul>


<h4>使用 Block</h4>

<p>自定义视图中：</p>

<p>```objc
@interface PieChart : UIControl</p>

<p>@property (nonatomic,copy) void(^selectionHandler)(PieChartSection* selectedSection);</p>

<p>@end
```</p>

<p><code>Block</code> 的好处是可以把相关的代码整合在视图控制器中:</p>

<p>```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>self.pieChart.selectionHandler = ^(PieChartSection* section) {
    // 处理区块
}
</code></pre>

<p>}
```</p>

<p>一旦 block 中的代码要失去控制 (比如 block 中要处理的事情太多，导致 block 中的代码过多)，你还应该将它们抽离成独立的方法，这种情况的话可能用代理会更好一些。</p>

<h4>使用 KVO</h4>

<p>编写代码:</p>

<p><code>objc
self.selectedSegment = theNewSelectedSegment;
</code></p>

<p>当使用合成属性，KVO 会拦截到该变化并发出通知。在视图控制器中，编写类似的代码:
```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>[self.pieChart addObserver:self forKeyPath:@"selectedSegment" options:0 context:NULL];
</code></pre>

<p>}</p>

<ul>
<li>(void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary </em>)change context:(void *)context
{
  if(object == self.pieChart &amp;&amp; [keyPath isEqualToString:@&ldquo;selectedSegment&rdquo;]) {
      // 处理改变
  }
}
```</li>
</ul>


<h4>使用通知</h4>

<p>视图头文件中：
<code>objc
extern NSString* const SelectedSegmentChangedNotification;
</code></p>

<p>在实现文件中：
```objc
NSString* const SelectedSegmentChangedNotification = @&ldquo;selectedSegmentChangedNotification&rdquo;;</p>

<p>&hellip;</p>

<ul>
<li>(void)notifyAboutChanges
{
  [[NSNotificationCenter defaultCenter] postNotificationName:SelectedSegmentChangedNotification object:self];
}
```</li>
</ul>


<p>现在订阅通知，在视图控制器中：
```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self
                                   selector:@selector(segmentChanged:)
                                       name:SelectedSegmentChangedNotification
                                      object:self.pieChart];
</code></pre>

<p>}</p>

<p>&hellip;</p>

<ul>
<li>(void)segmentChanged:(NSNotification*)note
{
}
```</li>
</ul>


<h3>辅助功能 (Accessibility)</h3>

<p>苹果官方提供的标准 iOS 控件均有辅助功能。这也是推荐用标准控件创建自定义控件的另一个原因。</p>

<h3>本地化</h3>

<p>使用 NSLocalizedString 本地化字符串。</p>

<h3>测试</h3>

<p>使用 <code>UIAutomation</code> 做视图测试。</p>

<h2>先进的自动布局工具箱</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC学习笔记]]></title>
    <link href="http://sjpsega.com/blog/2014/06/25/arc-note/"/>
    <updated>2014-06-25T00:50:28+08:00</updated>
    <id>http://sjpsega.com/blog/2014/06/25/arc-note</id>
    <content type="html"><![CDATA[<h2>ARC执行新规则</h2>

<ul>
<li>开发者不能显示调用 <code>dealloc</code>；不能实现和调用 retain、release、retainCount 和 autorelease。</li>
<li>不能使用 NSAllocateObject 或者 NSDeallocateObject 。开发者创建对象使用alloc，运行时环境负责销毁对象。</li>
<li>在 C 数据结构中，不能使用对象指针。可以使用 OC 类来代替 C 的 struct。</li>
<li>id 和 void * 没有自动转换。</li>
<li>开发者不能使用 NSAutoreleasePool 对象。ARC 下使用 @autoreleasepool，它比 NSAtuoreleasePool 更有效率。</li>
<li>开发者不能使用内存zones。不用再使用 NSZone 了。</li>
</ul>


<p>为了配合手动引用计数，ARC 的方法命名有限制：
* 访问器方法不能以 new 开头，开发者不能声明一个以 new 开头的属性，除非你给你指定一个getter：</p>

<p>```objc
// Won&rsquo;t work:
@property NSString *newTitle;</p>

<p>// Works:
@property (getter=theNewTitle) NSString *newTitle;
```</p>

<h2>ARC引入新的生命周期修饰符</h2>

<h3>变量修饰符</h3>

<ul>
<li><code>__strong</code> 是默认的，只要对象还有强引用，他就一直存在。</li>
<li><code>__weak</code> 指向一个不会保持被引用对象一直存在的引用。当没有强引用指向它，弱引用将被设置为 nil。</li>
<li><code>__unsafe_unretained</code> 指向一个不会保持被引用对象一直存在的引用，它<code>不会</code>被设置为 nil，当没有强引用指向它。如果它引用的对象被释放，指针会变成野指针。</li>
<li><code>__autoreleasing</code> 用于标识id *的引用参数，并且在返回的时候自动释放。</li>
</ul>


<h3>使用生命周期修饰符，避免循环引用</h3>

<p>在MRC下，<code>__block id x;</code>这样的写法，不会对x进行retain。</p>

<p>在ARC下，<code>__block id x;</code>默认retain x（就像其他变量一样）。</p>

<p>如果想在ARC模式下，得到手动引用计数的效果，开发者可以使用<code>__unsafe_unretained __block id x;</code>。顾名思义，<code>__unsafe_unretained是危险的</code>(因为他可能导致野指针)，因此也不建议使用。<code>好的解决方案是：使用__weak或者将__block的值设置为nil，来打断retain循环</code>。</p>

<ul>
<li><p>使用 <code>__block</code> ，然后设置为 <code>nil</code>：
<code>objc
MyViewController * __block myController = [[MyViewController alloc] init…];
// ...
myController.completionHandler =  ^(NSInteger result) {
  [myController dismissViewControllerAnimated:YES completion:nil];
  myController = nil;
};
</code></p></li>
<li><p>使用 <code>__weak</code> 修饰符 ：
<code>objc
MyViewController *myController = [[MyViewController alloc] init…];
// ...
MyViewController * __weak weakMyViewController = myController;
myController.completionHandler =  ^(NSInteger result) {
  [weakMyViewController dismissViewControllerAnimated:YES completion:nil];
};
</code></p></li>
<li><p>对于复杂场景：
<code>objc
MyViewController *myController = [[MyViewController alloc] init…];
// ...
MyViewController * __weak weakMyController = myController;
myController.completionHandler =  ^(NSInteger result) {
  MyViewController *strongMyController = weakMyController;
  if (strongMyController) {
      // ...
      [strongMyController dismissViewControllerAnimated:YES completion:nil];
      // ...
  }
  else {
      // Probably nothing...
  }
};
</code></p></li>
</ul>


<h2>相关资料</h2>

<p><a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC Release Notes</a></p>

<p><a href="http://www.cocoachina.com/applenews/devnews/2013/1209/7497.html">转向ARC的说明</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《#2 并发编程》 学习笔记]]></title>
    <link href="http://sjpsega.com/blog/2014/06/12/concurrent-programming-note/"/>
    <updated>2014-06-12T12:49:46+08:00</updated>
    <id>http://sjpsega.com/blog/2014/06/12/concurrent-programming-note</id>
    <content type="html"><![CDATA[<p>文章地址：<a href="http://objccn.io/issue-2/">objc第二章</a></p>

<h2>并发编程：API 及挑战</h2>

<h3>OS X 和 iOS 中的并发编程</h3>

<h4>Grand Central Dispatch(GCD)</h4>

<p>GCD 在后端管理着一个线程池，可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。在日常开发中，最好使用 GCD 来做线程方面的工作。</p>

<p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）</p>

<p>使用不同优先级的若干个队列乍听起来非常直接，不过，我们强烈建议，<code>在绝大多数情况下使用默认的优先级队列就可以了</code>。</p>

<p><img src="http://img.objccn.io/issue-2/gcd-queues.png" alt="http://img.objccn.io/issue-2/gcd-queues.png" /></p>

<h4>Operation Queues</h4>

<p>操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。GCD 提供了更加底层的控制，而操作队列则在 GCD 之上实现了一些方便的功能，这些功能对于 app 的开发者来说通常是最好最安全的选择。</p>

<p><code>NSOperationQueue</code> 有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 <code>NSOperation</code> 的子类来表述。</p>

<h4>Run Loops</h4>

<p>Run loop并不像 GCD 或者操作队列那样是一种并发机制，因为它并不能并行执行任务。不过在主 dispatch/operation 队列中， run loop 将直接配合任务的执行，它提供了一种异步执行代码的机制。</p>

<p>Run loop 比起操作队列或者 GCD 来说容易使用得多，因为通过 run loop ，你不必处理并发中的复杂情况，就能异步地执行任务。</p>

<h3>并发编程中面临的挑战</h3>

<h4>资源共享</h4>

<p>并发编程中许多问题的根源就是在多线程中访问共享资源。</p>

<p>在多线程中任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计以防止这种冲突的发生。</p>

<p>为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。</p>

<h4>互斥锁</h4>

<p>互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。</p>

<p>从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。</p>

<h4>死锁</h4>

<p>互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。</p>

<h4>资源饥饿（Starvation）</h4>

<p>大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致资源饥饿的发生。</p>

<h4>优先级反转</h4>

<p>优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。</p>

<p>解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。<code>当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）</code>。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。</p>

<h3>总结</h3>

<p>建议采纳的安全模式：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。</p>

<h2>常见的后台实践</h2>

<h3>操作队列 (Operation Queues) 还是 GCD ?</h3>

<p><code>GCD 是基于 C 的底层的 API ，而操作队列则是 GCD 实现的 Objective-C API。</code></p>

<p><code>操作队列可以取消在任务处理队列中的任务</code>，而在 GCD 中不容易实现。</p>

<h4>后台的 Core Data</h4>

<p><code>Core Data</code>不熟悉</p>

<h3>后台 UI 代码</h3>

<p><code>UIKit 只能在主线程上运行。</code>而那部分不与 UIKit 直接相关，却会消耗大量时间的 UI 代码可以被移动到后台去处理。</p>

<h3>异步网络请求处理</h3>

<ul>
<li>所有网络请求都应该采取异步的方式完成。</li>
<li>可以使用 <code>NSURLConnection</code> 的异步方法，并且把所有操作转化为 operation 来执行。通过这种方法，我们可以从操作队列的强大功能和便利中获益良多：我们能轻易地控制并发操作的数量，添加依赖，以及取消操作。</li>
<li>使用像 <a href="http://afnetworking.com/">AFNetworking</a> 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。但是并不推荐你自己去实现这些事情。</li>
</ul>


<h3>进阶：后台文件 I/O</h3>

<p>大体上逐行读取一个文件的模式是这样的：</p>

<ol>
<li>建立一个中间缓冲层以提供，当没有找到换行符号的时候可以向其中添加数据</li>
<li>从 stream 中读取一块数据</li>
<li>对于这块数据中发现的每一个换行符，取中间缓冲层，向其中添加数据，直到（并包括）这个换行符，并将其输出</li>
<li>将剩余的字节添加到中间缓冲层去</li>
<li>回到 2，直到 stream 关闭</li>
</ol>


<h3>总结</h3>

<p>在主队列中接收事件或者数据，然后用后台操作队列来执行实际操作，然后回到主队列去传递结果，遵循这样的原则来编写尽量简单的并行代码，将是保证高效正确的不二法则。</p>

<h2>底层并发 API</h2>

<h3>dispatch_once</h3>

<p>```objc
+ (UIColor *)boringColor;
{</p>

<pre><code>static UIColor *color;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f];
});
return color;
</code></pre>

<p>}
<code>``
上面的 block 只会运行一次。并且在连续的调用中，这种检查是很高效的。你能使用它来初始化全局数据比如单例。要注意的是，使用</code>dispatch_once_t` 会使得测试变得非常困难（单例和测试不是很好配合）。</p>

<p><code>要确保 onceToken 被声明为 static ，或者有全局作用域。任何其他的情况都会导致无法预知的行为。</code></p>

<h3>dispatch_after</h3>

<p>它使工作延后执行。它是很强大的，但是要注意：你很容易就陷入到一堆麻烦中。
```objc
&ndash; (void)foo
{</p>

<pre><code>double delayInSeconds = 2.0;
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));
dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
    [self bar];
});
</code></pre>

<p>}
<code>``
这里存在一些缺点。我们</code>不能（直接）取消我们已经提交到 dispatch_after 的代码，它将会运行`。</p>

<p>如果你需要一些事情在某个特定的时刻运行，那么 <code>dispatch_after</code> 或许会是个好的选择。确保同时考虑了 <code>NSTimer</code>，这个API虽然有点笨重，但是它<code>允许你取消定时器的触发</code>。</p>

<h3>队列</h3>

<p>GCD 中一个基本的代码块就是队列。</p>

<p>```objc
&ndash; (id)init
{</p>

<pre><code>self = [super init];
if (self != nil) {
    NSString *label = [NSString stringWithFormat:@"%@.isolation.%p", [self class], self];
    self.isolationQueue = dispatch_queue_create([label UTF8String], 0);

    label = [NSString stringWithFormat:@"%@.work.%p", [self class], self];
    self.workQueue = dispatch_queue_create([label UTF8String], 0);
}
return self;
</code></pre>

<p>}
```</p>

<p>队列可以是并行也可以是串行的，也可以是并行的。默认情况下，是串行的。</p>

<p>GCD 队列的内部使用的是线程。</p>

<h4>目标队列</h4>

<p>你能够为你创建的任何一个队列设置一个目标队列。</p>

<p>为一个类创建它自己的队列而不是使用全局的队列被普遍认为是一种好的风格。这种方式下，你可以设置队列的名字，这让调试变得轻松许多—— Xcode 可以让你在 Debug Navigator 中看到所有的队列名字，如果你直接使用 lldb。(lldb) thread list 命令将会在控制台打印出所有队列的名字。一旦你使用大量的异步内容，这会是非常有用的帮助。</p>

<h3>隔离</h3>

<h4>资源保护</h4>

<p>多线程编程中，最常见的情形是你有一个资源，每次只有一个线程被允许访问这个资源。</p>

<h4>全都使用异步分发</h4>

<h4>如何写出好的异步 API</h4>

<p>如果你的方法或函数有一个返回值，异步地将其传递给一个回调处理程序。这个 API 应该是这样的，你的方法或函数同时持有一个结果 block 和一个将结果传递过去的队列。
```objc
&ndash; (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;
{</p>

<pre><code>dispatch_async(self.isolationQueue, ^(void){
    // do actual processing here
    dispatch_async(self.resultQueue, ^(void){
        handler(YES);
    });
});
</code></pre>

<p>}
```</p>

<h3>迭代执行</h3>

<p>dispatch_apply
```objc
for (size_t y = 0; y &lt; height; ++y) {</p>

<pre><code>for (size_t x = 0; x &lt; width; ++x) {
    // Do something with x and y here
}
</code></pre>

<p>}
```</p>

<p>小小的改动或许就可以让它运行的更快：
```objc
dispatch_apply(height, dispatch_get_global_queue(0, 0), ^(size_t y) {</p>

<pre><code>for (size_t x = 0; x &lt; width; x += 2) {
    // Do something with x and y here
}
</code></pre>

<p>});
```</p>

<h3>组</h3>

<p>```objc
dispatch_group_t group = dispatch_group_create();</p>

<p>dispatch_queue_t queue = dispatch_get_global_queue(0, 0);
dispatch_group_async(group, queue, ^(){</p>

<pre><code>// Do something that takes a while
[self doSomeFoo];
dispatch_group_async(group, dispatch_get_main_queue(), ^(){
    self.foo = 42;
});
</code></pre>

<p>});
dispatch_group_async(group, queue, ^(){</p>

<pre><code>// Do something else that takes a while
[self doSomeBar];
dispatch_group_async(group, dispatch_get_main_queue(), ^(){
    self.bar = 1;
});
</code></pre>

<p>});</p>

<p>// This block will run once everything above is done:
dispatch_group_notify(group, dispatch_get_main_queue(), ^(){</p>

<pre><code>NSLog(@"foo: %d", self.foo);
NSLog(@"bar: %d", self.bar);
</code></pre>

<p>});
```</p>

<h4>对现有API使用 dispatch_group_t</h4>

<p>```objc
+ (void)withGroup:(dispatch_group_t)group</p>

<pre><code>    sendAsynchronousRequest:(NSURLRequest *)request 
    queue:(NSOperationQueue *)queue 
    completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler
</code></pre>

<p>{</p>

<pre><code>if (group == NULL) {
    [self sendAsynchronousRequest:request 
                            queue:queue 
                completionHandler:handler];
} else {
    dispatch_group_enter(group);
    [self sendAsynchronousRequest:request 
                            queue:queue 
                completionHandler:^(NSURLResponse *response, NSData *data, NSError *error){
        handler(response, data, error);
        dispatch_group_leave(group);
    }];
}
</code></pre>

<p>}
```
为了能正常工作，你需要确保:
* dispatch_group_enter() 必须要在 dispatch_group_leave()之前运行。
* dispatch_group_enter() 和 dispatch_group_leave() 一直是成对出现的。</p>

<h3>事件源</h3>

<p>GCD 有一个较少人知道的特性：事件源 <code>dispatch_source_t</code>。</p>

<p>当你需要用到它时，它会变得极其有用。它的一些使用是秘传招数，我们将会接触到一部分的使用。但是大部分事件源在 iOS 平台不是很有用，因为在 iOS 平台有诸多限制，你无法启动进程（因此就没有必要监视进程），也不能在你的 app bundle 之外写数据（因此也就没有必要去监视文件）等等。</p>

<p>GCD 事件源是以极其资源高效的方式实现的。</p>

<h4>监视进程</h4>

<h4>监视文件</h4>

<h4>定时器</h4>

<h4>取消</h4>

<h3>输入输出</h3>

<p>写出能够在繁重的 I/O 处理情况下运行良好的代码是一件非常棘手的事情。</p>

<h4>GCD 和缓冲区</h4>

<p>最直接了当的方法是使用数据缓冲区。GCD 有一个 <code>dispatch_data_t</code> 类型，在某种程度上和 Objective-C 的 NSData 类型很相似。但是它能做别的事情，而且更通用。</p>

<h4>读和写</h4>

<p>在 GCD 的核心里，调度 I/O（译注：原文为 Dispatch I/O） 与所谓的通道有关。调度 I/O 通道提供了一种与从文件描述符中读写不同的方式。</p>

<h3>基准测试</h3>

<p>能够测量给定的代码执行的平均的纳秒数。
<code>objc
uint64_t dispatch_benchmark(size_t count, void (^block)(void));
</code></p>

<h3>原子操作</h3>

<p>头文件 <code>libkern/OSAtomic.h</code> 里有许多强大的函数，专门用来底层多线程编程。尽管它是内核头文件的一部分，它也能够在内核之外来帮助编程。</p>

<h4>计数器</h4>

<h4>原子队列</h4>

<h4>自旋锁</h4>

<p>OSAtomic.h 头文件定义了使用自旋锁的函数：OSSpinLock。</p>

<h2>线程安全类的设计</h2>

<h3>线程安全</h3>

<h4>Apple 的框架</h4>

<p>一般来说除非特别声明，大多数的类默认都<code>不是</code>线程安全的。</p>

<p>Apple没有把 UIKit 设计为线程安全的类是有意为之的，将其打造为线程安全的话会使很多操作变慢。而事实上 UIKit 是和主线程绑定的，这一特点使得编写并发程序以及使用 UIKit 十分容易的，你唯一需要确保的就是对于 UIKit 的调用总是在主线程中来进行。</p>

<h4>为什么 UIKit 不是线程安全的？</h4>

<p>对于一个像 UIKit 这样的大型框架，确保它的线程安全将会带来巨大的工作量和成本。</p>

<h4>内存回收 (deallocation) 问题</h4>

<p>另一个在后台使用 UIKit 对象的的危险之处在于“内存回收问题”。</p>

<h4>Collection 类</h4>

<p>总的来说，比如 <code>NSArry 这样不可变类是线程安全的</code>。然而它们的可变版本，比如 <code>NSMutableArray 是线程不安全的</code>。</p>

<p>一个好习惯是写类似于 <code>return [array copy]</code> 这样的代码来确保返回的对象事实上是不可变对象。</p>

<h4>原子属性 (Atomic Properties)</h4>

<h5>为何不用 @synchronized ？</h5>

<p><code>@synchonized(self)</code> 更适合使用在你需要确保在发生错误时代码不会死锁，而是抛出异常的时候。</p>

<h4>你自己的类</h4>

<p>单独使用原子属性并不会使你的类变成线程安全。它不能保护你应用的逻辑，只能保护你免于在 setter 中遭遇到竞态条件的困扰。</p>

<p>一个简单的解决办法是使用 <code>@synchronize</code>。其他的方式都非常非常可能使你误入歧途，已经有太多聪明人在这种尝试上一次又一次地以失败告终。</p>

<h5>可行的线程安全设计</h5>

<p>对于那些肯定应该线程安全的代码（一个好例子是负责缓存的类）来说，一个不错的设计是使用并发的 dispatch_queue 作为读/写锁，并且确保只锁着那些真的需要被锁住的部分，以此来最大化性能。</p>

<h3>GCD 的陷阱</h3>

<p>对于大多数上锁的需求来说，GCD 就足够好了。它简单迅速，并且基于 block 的 API 使得粗心大意造成非平衡锁操作的概率下降了不少。</p>

<h4>将 GCD 当作递归锁使用</h4>

<p>GCD 是一个对共享资源的访问进行串行化的队列。这个特性可以被当作锁来使用，但实际上它和 @synchronized 有很大区别。</p>

<h4>用 dispatch_async 修复时序问题</h4>

<h4>在性能关键的代码中混用 dispatchsync 和 dispatchasync</h4>

<h4>使用 dispatch_async 来派发内存敏感的操作</h4>

<h2>测试并发程序</h2>

<p>以 SenTestingKit 为例子，在XCode5中已经不再使用。</p>

<p><a href="http://www.cnblogs.com/yjg2014/p/yjg.html">http://www.cnblogs.com/yjg2014/p/yjg.html</a></p>

<p><a href="http://m.blog.csdn.net/blog/againbike/11870459">http://m.blog.csdn.net/blog/againbike/11870459</a></p>
]]></content>
  </entry>
  
</feed>
