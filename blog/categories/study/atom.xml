<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | sjpsega's Blog]]></title>
  <link href="http://sjpsega.me/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://sjpsega.me/"/>
  <updated>2016-02-15T00:40:13+08:00</updated>
  <id>http://sjpsega.me/</id>
  <author>
    <name><![CDATA[sjpsega]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cordova WKWebView 学习笔记（二）]]></title>
    <link href="http://sjpsega.me/blog/2016/02/15/cordova-wkwebview-study-2/"/>
    <updated>2016-02-15T00:11:47+08:00</updated>
    <id>http://sjpsega.me/blog/2016/02/15/cordova-wkwebview-study-2</id>
    <content type="html"><![CDATA[<p>这篇主要是代码学习。</p>

<p>官方代码地址：<a href="https://github.com/apache/cordova-plugin-wkwebview-engine">cordova-plugin-wkwebview-engine</a></p>

<p>我的测试代码：<a href="https://github.com/sjpsega/CordovaWKWebViewTest">CordovaWKWebViewTest</a>，融合了一个 Device JSBridge 的例子，该例子参考自<a href="https://crosswalk-project.org/documentation/ios/cordova_plugin_support.html">CrossWalk - Cordova Plugin Support</a></p>

<h3>WKWebView JSBridge 事件传递</h3>

<p>在 WKWebView 中，开始原生支持 web 向 Native 发送消息，是通过 messageHandler 实现的。</p>

<p>在 UIWebView 时代，实现 web 向 app 发送消息，通常是通过 iframe 发起一个特殊请求，UIWebView 通过在拦截方法中，拦截这个特殊请求，使用这种类似 hack 的方式曲线救国的。</p>

<h4>实现步骤</h4>

<ul>
<li>Native 端添加 messageHandler
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="n">WKUserContentController</span><span class="o">*</span> <span class="n">userContentController</span> <span class="o">=</span> <span class="p">[[</span><span class="n">WKUserContentController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 关键代码，添加 messageHandler，名字为 cordova</span>
</span><span class='line'><span class="p">[</span><span class="n">userContentController</span> <span class="nl">addScriptMessageHandler</span><span class="p">:</span><span class="nb">self</span> <span class="nl">name</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">cordova</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">WKWebViewConfiguration</span><span class="o">*</span> <span class="n">configuration</span> <span class="o">=</span> <span class="p">[[</span><span class="n">WKWebViewConfiguration</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">configuration</span><span class="p">.</span><span class="n">userContentController</span> <span class="o">=</span> <span class="n">userContentController</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">WKWebView</span><span class="o">*</span> <span class="n">wkWebView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">WKWebView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">frame</span> <span class="nl">configuration</span><span class="p">:</span><span class="n">configuration</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li><p>JS 端调用
<code>javascript
//调用名为 cordova 的 messageHandler，与 Native 端进行通信
window.webkit.messageHandlers.cordova.postMessage(command);
</code></p></li>
<li><p>Native 接收
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="c1">//实现 WKScriptMessageHandler 接口&lt;/p&gt;&lt;/li&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">userContentController</span><span class="p">:(</span><span class="n">WKUserContentController</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">userContentController</span> <span class="nl">didReceiveScriptMessage</span><span class="p">:(</span><span class="n">WKScriptMessage</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">message</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">%</span><span class="p">@</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span><span class="n">message</span><span class="p">.</span><span class="n">name</span><span class="p">);</span> <span class="c1">//cordova</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">%</span><span class="p">@</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span><span class="n">message</span><span class="p">.</span><span class="n">body</span><span class="p">);</span> <span class="c1">//JSBridge 内容体</span>
</span><span class='line'>  <span class="o">&amp;</span><span class="n">hellip</span><span class="p">;</span> <span class="c1">//实现调用 Native 代码</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></li>
</ul>


<p>一个 messageHandler 一个通道，Cordova 统一使用 cordova 这个通道来通信。</p>

<h3>新增一个插件的实现步骤</h3>

<p>目录结构（列出关键目录与文件）：
<code>
|wkwvtest
    |Staging
        config.xml
        |www
            cordova_plugins.js
            |plugins //JS Plugihns
    |Plugins // Native Plugins
</code></p>

<p>已实现一个 Device 插件为例：</p>

<ul>
<li><p>在 Staging/www/plugins 目录下，新增一个 device.js 文件，添加 JS 代码
<code>javascript
cordova.define("org.apache.cordova.device.device", function(require, exports, module) {
  function Device() {
  //...
  }
  //...
  Device.prototype.getInfo = function(successCallback, errorCallback) {
      //调用 JSBridge，调用名为 Device 的 Native 类 getDeviceInfo 方法
      exec(successCallback, errorCallback, "Device", "getDeviceInfo", []);
  };
  module.exports = new Device();
});
</code></p></li>
<li><p>在 Staging/www/cordova_plugins.js 文件中注册 device.js
<code>javascript
cordova.define('cordova/plugin_list', function(require, exports, module) {
  module.exports = [
      {
          "file": "plugins/device.js",//写明相对 cordova_plugins.js 的文件路径
          "id": "org.apache.cordova.device.device",
          "clobbers": [
               "device" //全局命名空间，会注册为 window.device
          ]
      }
  ];
  module.exports.metadata =
  {
      "org.apache.cordova.device": "0.3.0"
  }
});
</code></p></li>
<li><p>添加在 plugins 目录下，新增 CDVDevice 类，继承于 CDVPlugin
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">@interface</span> <span class="nc">CDVDevice</span> : <span class="nc">CDVPlugin</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">getDeviceInfo</span><span class="p">:(</span><span class="n">CDVInvokedUrlCommand</span><span class="o">*</span><span class="p">)</span><span class="n">command</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></p></li>
<li><p>在 Staging/config.xml 中注册 CDVDevice
<code>xml
&lt;widget id="my.project.wkwvtest" version="0.0.1" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0"&gt;
  &lt;feature name="Device"&gt;
      &lt;param name="ios-package" value="CDVDevice" /&gt;
  &lt;/feature&gt;
&lt;/widget&gt;
</code></p></li>
</ul>


<p>完成这步骤，便可以通过 web 端，调用 <code>exec(successCallback, errorCallback, "Device", "getDeviceInfo", []);</code>，调用 Device 这个 Native 类的 getDeviceInfo 方法</p>

<p>详见：<a href="https://github.com/sjpsega/CordovaWKWebViewTest">CordovaWKWebViewTest</a></p>

<h3>&ldquo;同步&rdquo; JSBridge 代码执行</h3>

<p>这里的"同步"需要打引号，虽然 WKWebView 提供了原生 web 向 Native 发送消息的方案，但是注意，这里是发送消息，还不是同步回调。</p>

<p>Cordova 新版本的插件机制，通过多重事件机制的方式，使得一种类型的 JSBridge 同步成为可能 - webView 打开页面后，需要调用 Native 端获取环境变量的 JSBridge。比如上例的 Device 这个 JSBridge 就是典型。</p>

<p>Cordova 启动的几个重要事件：</p>

<ul>
<li>onNativeReady</li>
<li>onDOMContentLoaded</li>
<li>onPluginsReady</li>
<li>onCordovaReady</li>
<li>onDeviceReady</li>
</ul>


<p>通常是从上往下依次进行，并且 web 开始调用 JSBridge，必须监听 <code>deviceready</code> 事件，所以 onDeviceReady 始终最后执行，代表 Cordova 插件环境完全准备完毕。</p>

<p>所以，这种"同步" JSBridge 就是利用这个特性，做了一些文章。</p>

<p>看关键代码：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">cordova</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ldquo</span><span class="p">;</span><span class="nx">org</span><span class="p">.</span><span class="nx">apache</span><span class="p">.</span><span class="nx">cordova</span><span class="p">.</span><span class="nx">device</span><span class="p">.</span><span class="nx">device</span><span class="o">&amp;</span><span class="nx">rdquo</span><span class="p">;,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">channel</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lsquo</span><span class="p">;</span><span class="nx">cordova</span><span class="o">/</span><span class="nx">channel</span><span class="o">&amp;</span><span class="nx">rsquo</span><span class="p">;),</span>
</span><span class='line'>    <span class="nx">exec</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lsquo</span><span class="p">;</span><span class="nx">cordova</span><span class="o">/</span><span class="nx">exec</span><span class="o">&amp;</span><span class="nx">rsquo</span><span class="p">;),</span>
</span><span class='line'>    <span class="c1">//注册名为 onCordovaInfoReady 的 Sticky 类型的事件</span>
</span><span class='line'>    <span class="nx">channel</span><span class="p">.</span><span class="nx">createSticky</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lsquo</span><span class="p">;</span><span class="nx">onCordovaInfoReady</span><span class="o">&amp;</span><span class="nx">rsquo</span><span class="p">;);</span>
</span><span class='line'>    <span class="c1">//告诉系统，必须等待 CordovaInfoReady 事件发送</span>
</span><span class='line'>    <span class="nx">channel</span><span class="p">.</span><span class="nx">waitForInitialization</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lsquo</span><span class="p">;</span><span class="nx">onCordovaInfoReady</span><span class="o">&amp;</span><span class="nx">rsquo</span><span class="p">;);</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">function</span> <span class="nx">Device</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">me</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//在 onCordovaReady 事件中，注册回调，使得系统初始化便调用该回调，并且 onCordovaReady 在 onPluginsReady 事件后 fire</span>
</span><span class='line'>    <span class="nx">channel</span><span class="p">.</span><span class="nx">onCordovaReady</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//调用 JSBridge</span>
</span><span class='line'>        <span class="nx">me</span><span class="p">.</span><span class="nx">getInfo</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">info</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">//调用 JSBridge 成功回调用，fire onCordovaInfoReady 事件</span>
</span><span class='line'>            <span class="nx">channel</span><span class="p">.</span><span class="nx">onCordovaInfoReady</span><span class="p">.</span><span class="nx">fire</span><span class="p">();</span>
</span><span class='line'>        <span class="p">},</span><span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">Device</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getInfo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">successCallback</span><span class="p">,</span> <span class="nx">errorCallback</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">exec</span><span class="p">(</span><span class="nx">successCallback</span><span class="p">,</span> <span class="nx">errorCallback</span><span class="p">,</span> <span class="s2">&quot;Device&quot;</span><span class="p">,</span> <span class="s2">&quot;getDeviceInfo&quot;</span><span class="p">,</span> <span class="p">[]);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Device</span><span class="p">();</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>web 端调用 Device 的代码：
<code>javascript
document.addEventListener("deviceready", onDeviceReady, false);
function onDeviceReady() {
    console.log(device.uuid);
}
</code>
可以看到，deviceready 的时候，便可以直接调用 device 这个全局变量。
这是因为之前在 cordova_plugins.js 这个文件中，做了申明，会把 device 变为全局变量
<code>javascript
"clobbers": [
    "device" //全局命名空间，会注册为 window.device
]
</code></p>

<p>这种设计非常巧妙，但是以我的经验，这种形式的 JSBridge 使用比较局限，主要缺点有：</p>

<ul>
<li>只能对整个 App 周期，固定不变的值使用。如果使用中，这个值会变化则无法使用，如地理位置信息就不行</li>
<li>只能针对属性使用，不能对方法使用</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cordova WKWebView 学习笔记（一）]]></title>
    <link href="http://sjpsega.me/blog/2016/02/06/cordova-wkwebview-study-1/"/>
    <updated>2016-02-06T13:43:47+08:00</updated>
    <id>http://sjpsega.me/blog/2016/02/06/cordova-wkwebview-study-1</id>
    <content type="html"><![CDATA[<h2>WKWebView</h2>

<p>Apple 从 iOS 8 开始，引入了新的 WebView 类 <code>WKWebView</code>，试图替换已经老迈的 UIWebView。</p>

<h3>优点</h3>

<p>通过官方的描述，和自己实际测试，WKWebView功能相当强大，对比 UIWebView 的优点很多：</p>

<ul>
<li>更少的内存使用，渲染相同页面，占用内存基本只有 UIWebView 的 1/3 ~ 1/4，并且大大减少了内存泄露的情况</li>
<li>使用与 Safari 一样的性能强大的 Nirtro JS 引擎</li>
<li>异常强大的 app 与 web 的内容传递

<ul>
<li>可以使用 <code>WKUserContentController</code> 在 Native 端注入用户自定义脚本 JS</li>
<li>web 端可以使用 <code>window.webkit.messageHandlers.{NAME}.postMessage()</code>，直接向 Native 端发送消息。UIWebView 只能使用 iframe 等方案 hack</li>
</ul>
</li>
</ul>


<h3>限制</h3>

<p>官方的描述基本是溢美之词，他不会告诉你 WKWebView 的一些问题，但是这些问题，在做 Hybrid 应用的时候，影响很大，纯 wap 无影响。
估计是切换底层实现的关系，这些问题在 UIWebView 上不存在：</p>

<ul>
<li>无能加载本地文件，只能通过内建一个 WebServer 实现功能。（直到 iOS 9 才新开了一个loadFileURL:allowingReadAccessToURL: 接口，原生实现该功能）</li>
<li>不能注册自定义 NSURLProtocol，导致大量 URL 拦截功能难以实现，比如页面展示本地图片</li>
<li>不能使用 NSHTTPCookieStorage 设置 WebView 的 Cookie</li>
<li>必须 iOS8 及以上版本，Cordova 只支持 iOS9 及以上</li>
</ul>


<p>还有其他在实际开发中，可能爆出的 bug。</p>

<h2>Cordova WKWebview 现状</h2>

<p>Cordova 开发了<a href="https://github.com/apache/cordova-plugin-wkwebview-engine">一个插件</a>来支持 WKWebview，用户可以自行在 WKWebview 与 UIWebView 中选择。</p>

<p>但因为 WKWebView 存在的种种问题，WKWebView 还不是 Cordova 的默认选择。</p>

<p><a href="https://shazronatadobe.wordpress.com/2015/03/03/wkwebview-and-apache-cordova/">cordova 关于 WKWebView 的一些说明</a></p>

<h2>结论</h2>

<ul>
<li>纯 wap 页面，WKWebView 毫无问题，会有很好的表现</li>
<li>Hybrid 应用，因为现在存在的一些问题，以及会导致实现 Camera、PhotoList 等 JSBridge 的功能上会有较大限制，选择 WKWebView 需要慎重</li>
</ul>


<h2>相关代码</h2>

<p><a href="https://github.com/apache/cordova-plugin-wkwebview-engine">cordova-plugin-wkwebview-engine</a></p>

<p><a href="https://github.com/crosswalk-project/ios-extensions-crosswalk">CrossWalk Cordova Plugin Support</a></p>

<h2>相关资料</h2>

<p><a href="http://nshipster.cn/wkwebkit/">WKWeb​View</a></p>

<p><a href="http://docs.telerik.com/platform/appbuilder/cordova/configuring-your-app/configure-web-views">Telerik Platform Documentation - Configure the Web Views</a></p>

<p><a href="http://plugins.telerik.com/cordova/plugin/wkwebview">Cordova Plugins - WKWebView</a></p>

<p><a href="https://crosswalk-project.org/documentation/ios/cordova_plugin_support.html">CrossWalk - Cordova Plugin Support</a></p>

<p><a href="http://stackoverflow.com/questions/29268433/is-there-support-in-cordova-to-wkwebview">Is there support in Cordova to WKWebView?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[isEqual 与 Hash]]></title>
    <link href="http://sjpsega.me/blog/2016/01/14/isequalandhash/"/>
    <updated>2016-01-14T01:17:56+08:00</updated>
    <id>http://sjpsega.me/blog/2016/01/14/isequalandhash</id>
    <content type="html"><![CDATA[<h2>最佳实践</h2>

<ul>
<li>实现 <code>isEqualTo__ClassName__</code></li>
<li>重写 isEqual 方法，同时重写 hash 方法。</li>
</ul>


<h2>关系</h2>

<ul>
<li>两个对象 isEqual 相等，hash 必须也相等</li>
<li>两个对象 hash 相同，isEqual 则不一定相等</li>
</ul>


<h2>碰撞</h2>

<p>当对象存入集合对象时（Array，Set，HashTable等），内部会使用对象的 hash 值来作为 key 来存入。
当两个不相等的对象，有相同的 hash 值，存入集合对象，就会发生<code>碰撞</code>现象。
发生碰撞现象，对使得存取数据变慢，所以需要尽量避免这个现象，但不可能完全避免。</p>

<h2>作为集合对象 key 的注意点</h2>

<ul>
<li>实现 isEqual 和 hash 方法，遵守两者关系，尽量避免 hash 碰撞的情况发生</li>
<li>实现 NSCopying 协议，接口：<code>- (void)setObject:(ObjectType)anObject forKey:(KeyType &lt;NSCopying&gt;)aKey;</code></li>
</ul>


<h2>测试 Demo</h2>

<p><a href="https://github.com/sjpsega/EqualAndHashTest">测试 Demo</a></p>

<h2>参考资料</h2>

<p><a href="http://nshipster.com/equality/">Equality</a></p>

<p><a href="https://mikeash.com/pyblog/friday-qa-2010-06-18-implementing-equality-and-hashing.html">Implementing Equality and Hashing</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD 学习]]></title>
    <link href="http://sjpsega.me/blog/2015/08/31/gcd-study/"/>
    <updated>2015-08-31T00:08:49+08:00</updated>
    <id>http://sjpsega.me/blog/2015/08/31/gcd-study</id>
    <content type="html"><![CDATA[<p>Grand Central Dispatch （GCD）是 Apple 开发的一个多核编程的解决方法。</p>

<p>底层、轻量，是 iOS 上常用的多线程解决方案。</p>

<h2>基本操作</h2>

<h3>sync、async</h3>

<p>dispatch_sync （同步）添加任务到一个队列并等待，直到任务完成，再执行原有队列上的任务。</p>

<p>dispatch_async （异步）添加任务到一个队列，但继续执行原有队列上的任务，在队列中按照 FIFO 的规则执行。</p>

<pre><code class="objc">dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"log 1");
    });
NSLog(@"log 2");
/* 输出:
 * log 1
 * log 2
 * /
</code></pre>

<pre><code class="objc">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"log 1");
    });
NSLog(@"log 2");
/* 输出绝大多数情况为:
 * log 2
 * log 1
 * /
</code></pre>

<p><code>注：不能在串行（主线程是一种串行队列）线程队列的任务中，再使用 dispatch_sync 添加任务到同一个串行队列中，否则必定发生死锁。</code></p>

<pre><code class="objc">dispatch_async(dispatch_get_main_queue(), ^{
    //必定发生死锁
    dispatch_sync(dispatch_get_main_queue(), ^{
    });
});
</code></pre>

<h3>dispatch_once</h3>

<p>dispatch_once 线程安全的方式执行任务且仅执行其代码块一次。</p>

<p>在单例模式中普遍使用。</p>

<pre><code class="objc">static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    NSLog(@"log 1");
});
dispatch_once(&amp;onceToken, ^{
    NSLog(@"log 2");
});
/* 输出:
 * log 1
 * /
</code></pre>

<h3>dispatch_after</h3>

<p>dispatch_after 延后一定时间，异步执行任务</p>

<pre><code class="objc">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"log 1");
    });
NSLog(@"log 2");
/* 输出:
 * log 2
 * log 1
 * /
</code></pre>

<h2>group</h2>

<p>通常使用分组来关联一组相关的任务，任务全部完成后，再做相关操作。</p>

<h3>group_enter、group_leave</h3>

<p>使用 dispatch_group_enter、dispatch_group_leave 来手动设置一个组任务的开始和结束，用来控制复杂情况下的任务完成情况。</p>

<p>必须保证 dispatch_group_enter 和 dispatch_group_leave <code>成对出现</code>，否则会遇到崩溃问题。</p>

<p>实例：</p>

<p>a）不使用 dispatch_group_enter、dispatch_group_leave 的情况
<code>objc
- (void)testGCDWithGroup{
    __block int count = 0;
    __block BOOL isDone = NO;
    // 1
    dispatch_group_t group = dispatch_group_create();
    // 2
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"CGD 1 .");
        // 3
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSLog(@"CGD 1 after.");
            count++;
        });
    });
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"done !!!");
        // 4
        isDone = YES;
        expect(count).to.equal(1);
    });
    // 5
    expect(isDone).will.beTruthy();
}
</code>
该测试用例执行步骤为:</p>

<ol>
<li>生成一个自定义组</li>
<li>在自定义组上，添加任务到子线程上执行</li>
<li>子线程上的任务为执行一个延时任务，使得 count + 1</li>
<li>当一个组内的任务全部完成，设置 isDone 为 YES，并期望 count 为 1</li>
<li>异步执行，期望 isDone 为 YES</li>
</ol>


<p>期望4、5处的测试均能通过，但测试结果为：</p>

<ol>
<li>5 的测试 case 为通过</li>
<li>4 的测试 case <code>不通过</code>，count 不为 1</li>
</ol>


<p>因为在这个例子中，执行完毕 dispatch_group_async 中的任务，就算任务完成了；而不是等到 dispatch_group_async 中的 dispatch_after 任务完成，才算任务完成。</p>

<p>b）使用 dispatch_group_enter、dispatch_group_leave 的情况
<code>objc
- (void)testGCDWithGroupEnterAndLeave{
    __block int count = 0;
    __block BOOL isDone = NO;
    dispatch_group_t group = dispatch_group_create();
    dispatch_group_enter(group);
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"CGD 1 .");
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSLog(@"CGD 1 after.");
            dispatch_group_leave(group);
            count++;
        });
    });
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"done !!!");
        isDone = YES;
        expect(count).to.equal(1);
    });
    expect(isDone).will.beTruthy();
}
</code>
这个测试用例的全部通过，使用手动控制组任务的开始和结束，完美解决了例子 a 中碰到的问题。</p>

<p>使用 dispatch_group_enter、dispatch_group_leave，用来处理复杂的异步任务非常有效。</p>

<h2>queue</h2>

<h3>串行、并发</h3>

<p>串行队列每次只有一个任务被执行，并发队列在同一时间可以有多个任务被执行。</p>

<p>主线程是系统提供的一个特殊的队列，是一个<code>串行</code>队列，是唯一可用与更新 UI 的线程。</p>

<p>除了主线程，其他均为子线程，通常用来执行与 UI 无关的操作。
实际编码中，通常使用 <code>dispatch_get_global_queue(long identifier, unsigned long flags)</code> 来获取子线程队列。通过该方法获取的是<code>并发</code>的全局调度队列，并且可以设置四个不同优先级的队列：high、default、low、background，若没有特殊原因，只使用 default 级别的队列。</p>

<p>用户还可以使用 <code>dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)</code> 来创建自定义的串行或并发队列。
主线程是系统提供的<code>串行</code>队列。</p>

<pre><code class="objc">//创建自定义并发队列
dispatch_queue_t concurrentQueue = dispatch_queue_create("com.sjpsega", DISPATCH_QUEUE_CONCURRENT);
//创建自定义创兴队列
dispatch_queue_t serialQueue = dispatch_queue_create("com.sjpsega", DISPATCH_QUEUE_SERIAL);
</code></pre>

<h2>dispatch_barrier</h2>

<p>barrier 意为“障碍”。dispatch_barrier 在并发队列上工作时扮演一个串行式的瓶颈。当提交的任务开始执行时，该 API 保障这个时刻队列里只执行当前任务，不会执行其他任务。</p>

<p><img src="/images/2015-08-31-gcd-study/dispatch_barrier.png" alt="dispatch_barrier" /></p>

<p>使用 dispatch_barrier API 最佳的方式是使用<code>自定义并发队列</code>执行。</p>

<p>下面以使用 dispatch_barrier 保证类类变量线程安全为例：</p>

<pre><code class="objc">- (void)addStudents:(Student *)student{
    dispatch_barrier_async(_concurrentQueue, ^{
        [_students addObject:student];
    });
}

- (NSArray *)students{
    __block NSArray *copyObj;
    dispatch_sync(_concurrentQueue, ^{
        copyObj =  [_students copy];
    });
    return copyObj;
}
</code></pre>

<p>但是，通常保证类变量线程安全，若不是高并发的情况下，比较简单的方式是使用 <code>synchronized</code> 关键字：</p>

<pre><code class="objc">- (void)addStudents:(Student *)student{
    @synchronized(_students){
        [_students addObject:student];
    }
}

- (NSArray *)students{
    @synchronized(_students){
        return [_students copy];
    }
}
</code></pre>

<h2>测试 Demo</h2>

<p><a href="https://github.com/sjpsega/GCDTest">测试 Demo</a></p>

<h2>参考资料</h2>

<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">GCD 深入理解：第一部分</a></p>

<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md">GCD 深入理解：第二部分</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UIWebView 自定义协议文件加载缓存问题]]></title>
    <link href="http://sjpsega.me/blog/2015/06/15/uiwebview-cache-bug-by-custom-protocol/"/>
    <updated>2015-06-15T22:56:31+08:00</updated>
    <id>http://sjpsega.me/blog/2015/06/15/uiwebview-cache-bug-by-custom-protocol</id>
    <content type="html"><![CDATA[<h2>起因</h2>

<p>一个简单的需求：为了减少网络请求，一些前端资源会做本地缓存；使用 WebView 访问页面的时候，拦截特定请求，使得特定请求直接加载本地资源。</p>

<p>但是做的过程中发现，当请求的资源为自定义协议的时候，比如加载的 url 为 <code>abc://xxx.com/xx.js</code> 的时候，系统会强制对该资源做缓存，并且调用系统提供的清除缓存接口，如 <code>[[NSURLCache sharedURLCache] removeAllCachedResponses]</code>， 都无法清除该缓存，除非重启 App。</p>

<p>这就导致该资源内容发生变化的时候，无法立即生效，这在业务中，显然是不能接受的。</p>

<p><code>注</code>：该方案主要针对 <code>UIWebView</code> 有效；<code>WKWebView</code> 因为不能使用自定义 NSURLProtocol 拦截资源，方法二就不起作用。</p>

<h2>解决</h2>

<h3>方法一：html 模板上，资源 url 加上随机字符串</h3>

<p>在 html 页面上修改 url 字符串，如 <code>abc://xxx.com/xx.js</code>，需要改成 <code>abc://xxx.com/xx.js?t=123</code>，这样系统就不会缓存该资源。</p>

<p>该方法简单直接。</p>

<h3>方法二：创建自定义 NSURLProtocol，拦截请求，并且在创建 response 时，修改自定义协议为 http 或 https</h3>

<p>伪代码如下：
<code>objc
//原请求
NSString *requestURLString = @"abc://xxx.com/xx.js";
//根据原请求获得的 data 数据
NSData *abcData = ...
//将原请求的自定义协议改成 http
NSString *changeURLString = @"http://xxx.com/xx.js";
//创建 response
NSURL *url = [NSURL URLWithString:changeURLString];
NSURLResponse* response =
[[NSURLResponse alloc] initWithURL:url
                          MIMEType:@"application/x-javascript"
             expectedContentLength:abcData.length
                  textEncodingName:@"UTF-8"];
[[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
[[self client] URLProtocol:self didLoadData:abcData];
[[self client] URLProtocolDidFinishLoading:self];
</code></p>

<p>本来结合方法一的解决方式，创建 response 的时候，在 url 后加上随机字符串，但是经过试验，该方案<code>无效</code>，缓存始终存在。</p>

<p>使用该解决方法解决缓存问题，据个人猜测是因为，iOS 系统默认缓存数据，但针对 http 或 https 协议会根据 Cache-Control 等字段判断是否缓存。</p>

<p>具体可见 <a href="https://github.com/sjpsega/CustomProtocolCacheTest">测试demo</a>，并注意 log 信息。</p>

<h2>讨论</h2>

<p>解决这个缓存问题，其实我还是有些疑惑，因为试了所有 iOS 给出的数据缓存 API，都不起作用。这些包括：</p>

<ul>
<li>使用 [[NSURLCache sharedURLCache] removeAllCachedResponses] 清理缓存</li>
<li>重写了 NSURLCache 的 - (NSCachedURLResponse <em>)cachedResponseForRequest:(NSURLRequest </em>)request 方法，不返回 response 对象</li>
<li>自定义 NSURLProtocol 中，使用 NSURLConnection 加载数据，实现 NSURLConnectionDelegate 的 - (NSCachedURLResponse <em>)connection:(NSURLConnection </em>)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse 方法，返回 nil，不做对应 url 数据的缓存。</li>
</ul>


<p>然后，方法一与方法二中，我都试验了 url 加随机字符串的方式，但是为什么 html 模板上的资源 url 加上随机字符串有效，创建 response 时候，url 加上随机字符串无效，我也感到无解。</p>

<p>感觉在 webView 资源缓存的问题上，Apple 官方还是有些接口没开放，或者是我不知道&hellip;</p>

<h2>参考资料</h2>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">URL Loading System</a></p>

<p><a href="http://nshipster.cn/nsurlcache/">NSURLCache</a></p>
]]></content>
  </entry>
  
</feed>
