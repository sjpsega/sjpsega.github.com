<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | sjpsega's Blog]]></title>
  <link href="http://sjpsega.me/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://sjpsega.me/"/>
  <updated>2020-07-04T22:22:54+08:00</updated>
  <id>http://sjpsega.me/</id>
  <author>
    <name><![CDATA[sjpsega]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 仿淘宝详情页分页组件]]></title>
    <link href="http://sjpsega.me/blog/2016/09/17/paging/"/>
    <updated>2016-09-17T21:42:08+08:00</updated>
    <id>http://sjpsega.me/blog/2016/09/17/paging</id>
    <content type="html"><![CDATA[<p>本例 <a href="https://github.com/sjpsega/Paging">Demo</a>。</p>

<p>淘宝详情页的分页交互效果是一个经典的实现，隔离了淘宝商品基本属性页和图文详情页，即给用户一个良好的使用体验，也通过分页懒加载图文信息，提高了页面首屏加载速度，也减少了不必要的流量损耗。</p>

<p>下面说说怎么实现这个效果。</p>

<h2>效果预览</h2>

<p><img src="/images/2016-09-17-paging/paging-demo.gif" alt="main-flow" /></p>

<h2>实现</h2>

<p>先想一下实现分页的步骤，其实很简单，就两步:</p>

<ol>
<li>将需要分页的页面添加到分页组件上</li>
<li>页面滚动，当检测到达页面边缘，通过动画滚动到下一页或上一页</li>
</ol>


<h3>利用自带的 ScrollView</h3>

<p>想到滚动和分页，第一时间想到的肯定是自带的 UIScrollView。
因为 UIScrollView 不仅有滚动效果，并且本身已经自带了一些分页的 API，比如 <code>pagingEnabled</code> 等。</p>

<p>但是，想一下，直接使用 <code>pagingEnabled</code> 这个属性，然后添加上需要分页的页面，能实现我们的分页效果么？
答案显然是不能的，因为我们的详情页面的基本属性页和图文详情页本身就是大页面，自身就有滚动效果，如果直接使用 UIScrollView ，两个滚动效果叠加，肯定会出现问题的。</p>

<p>经过实践，我的做法是，使用 <code>UIScrollView</code> 来当做分页的容器，是利用相关的滚动 API，来实现翻页的效果。</p>

<h3>实现中遇到的问题</h3>

<p>主要是两个问题：</p>

<ol>
<li>需要分页的子页面，如何判断滚动到最底部</li>
<li>翻页的效果如何实现</li>
</ol>


<p>问题 1 很好解决，仔细研究下 UIScrollView 的属性就有答案了，就是一个数学问题。</p>

<p>图例：</p>

<p><img src="/images/2016-09-17-paging/UIScrollView-structure.jpg" alt="UIScrollView-structure" /></p>

<p>代码：</p>

<pre><code class="objectivec">- (CGFloat)contentOffsetBottom:(UIScrollView*)scrollView{
    return scrollView.contentOffset.y - (scrollView.contentSize.height - scrollView.frame.size.height + scrollView.contentInset.bottom);
}
</code></pre>

<p>问题 2 也很简单，就是利用了 UIScrollView 自带的一个 API <code>- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;</code> 便可。</p>

<h2>继续优化</h2>

<p>现在我们的代码实现了分页的效果，但是缺少淘宝详情页的那样分页提示文字，要实现这个也不难。</p>

<ul>
<li>需要翻到下一页，可以在该页的最后加上“继续拖动，查看图文详情”的提示 label。</li>
<li>需要返回到上一页，因为页面是 UIScrollView，可以使用 <a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a> 加上一个自定义的 header 加上提示文字便可。</li>
</ul>


<h2>参考资料</h2>

<p><a href="http://tech.glowing.com/cn/practice-in-uiscrollview/">UIScrollView 实践经验</a></p>

<p><a href="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/UIScrollView_pg/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008179-CH1-SW1">About Scroll View Programming</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSPatch 学习]]></title>
    <link href="http://sjpsega.me/blog/2016/04/18/jspatch-study/"/>
    <updated>2016-04-18T00:19:13+08:00</updated>
    <id>http://sjpsega.me/blog/2016/04/18/jspatch-study</id>
    <content type="html"><![CDATA[<h2>主体流程</h2>

<p><img src="/images/2016-04-18-jspatch-study/main-flow.jpg" alt="main-flow" /></p>

<h2>JS 调用 OC 代码</h2>

<p><img src="/images/2016-04-18-jspatch-study/js2oc.jpg" alt="js2oc" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cordova WKWebView 学习笔记（二）]]></title>
    <link href="http://sjpsega.me/blog/2016/02/15/cordova-wkwebview-study-2/"/>
    <updated>2016-02-15T00:11:47+08:00</updated>
    <id>http://sjpsega.me/blog/2016/02/15/cordova-wkwebview-study-2</id>
    <content type="html"><![CDATA[<p>这篇主要是代码学习。</p>

<p>官方代码地址：<a href="https://github.com/apache/cordova-plugin-wkwebview-engine">cordova-plugin-wkwebview-engine</a></p>

<p>我的测试代码：<a href="https://github.com/sjpsega/CordovaWKWebViewTest">CordovaWKWebViewTest</a>，融合了一个 Device JSBridge 的例子，该例子参考自<a href="https://crosswalk-project.org/documentation/ios/cordova_plugin_support.html">CrossWalk - Cordova Plugin Support</a></p>

<h3>WKWebView JSBridge 事件传递</h3>

<p>在 WKWebView 中，开始原生支持 web 向 Native 发送消息，是通过 messageHandler 实现的。</p>

<p>在 UIWebView 时代，实现 web 向 app 发送消息，通常是通过 iframe 发起一个特殊请求，UIWebView 通过在拦截方法中，拦截这个特殊请求，使用这种类似 hack 的方式曲线救国的。</p>

<h4>实现步骤</h4>

<ul>
<li>Native 端添加 messageHandler
```objectivec
WKUserContentController* userContentController = [[WKUserContentController alloc] init];
// 关键代码，添加 messageHandler，名字为 cordova
[userContentController addScriptMessageHandler:self name:@&ldquo;cordova&rdquo;];</li>
</ul>


<p>WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];
configuration.userContentController = userContentController;</p>

<p>WKWebView* wkWebView = [[WKWebView alloc] initWithFrame:frame configuration:configuration];
```</p>

<ul>
<li><p>JS 端调用
<code>javascript
//调用名为 cordova 的 messageHandler，与 Native 端进行通信
window.webkit.messageHandlers.cordova.postMessage(command);
</code></p></li>
<li><p>Native 接收
```objectivec
//实现 WKScriptMessageHandler 接口</p></li>
<li>(void)userContentController:(WKUserContentController<em>)userContentController didReceiveScriptMessage:(WKScriptMessage</em>)message
{
  NSLog(@&ldquo;%@&rdquo;,message.name); //cordova
  NSLog(@&ldquo;%@&rdquo;,message.body); //JSBridge 内容体
  &hellip; //实现调用 Native 代码
}
```</li>
</ul>


<p>一个 messageHandler 一个通道，Cordova 统一使用 cordova 这个通道来通信。</p>

<h3>新增一个插件的实现步骤</h3>

<p>目录结构（列出关键目录与文件）：
<code>
|wkwvtest
    |Staging
        config.xml
        |www
            cordova_plugins.js
            |plugins //JS Plugihns
    |Plugins // Native Plugins
</code></p>

<p>已实现一个 Device 插件为例：</p>

<ul>
<li><p>在 Staging/www/plugins 目录下，新增一个 device.js 文件，添加 JS 代码
<code>javascript
cordova.define("org.apache.cordova.device.device", function(require, exports, module) {
  function Device() {
  //...
  }
  //...
  Device.prototype.getInfo = function(successCallback, errorCallback) {
      //调用 JSBridge，调用名为 Device 的 Native 类 getDeviceInfo 方法
      exec(successCallback, errorCallback, "Device", "getDeviceInfo", []);
  };
  module.exports = new Device();
});
</code></p></li>
<li><p>在 Staging/www/cordova_plugins.js 文件中注册 device.js
<code>javascript
cordova.define('cordova/plugin_list', function(require, exports, module) {
  module.exports = [
      {
          "file": "plugins/device.js",//写明相对 cordova_plugins.js 的文件路径
          "id": "org.apache.cordova.device.device",
          "clobbers": [
               "device" //全局命名空间，会注册为 window.device
          ]
      }
  ];
  module.exports.metadata =
  {
      "org.apache.cordova.device": "0.3.0"
  }
});
</code></p></li>
<li><p>添加在 plugins 目录下，新增 CDVDevice 类，继承于 CDVPlugin
```objectivec
@interface CDVDevice : CDVPlugin</p></li>
<li><p>(void)getDeviceInfo:(CDVInvokedUrlCommand*)command;
@end
```</p></li>
<li><p>在 Staging/config.xml 中注册 CDVDevice
<code>xml
&lt;widget id="my.project.wkwvtest" version="0.0.1" xmlns="http://www.w3.org/ns/widgets" xmlns:cdv="http://cordova.apache.org/ns/1.0"&gt;
  &lt;feature name="Device"&gt;
      &lt;param name="ios-package" value="CDVDevice" /&gt;
  &lt;/feature&gt;
&lt;/widget&gt;
</code></p></li>
</ul>


<p>完成这步骤，便可以通过 web 端，调用 <code>exec(successCallback, errorCallback, "Device", "getDeviceInfo", []);</code>，调用 Device 这个 Native 类的 getDeviceInfo 方法</p>

<p>详见：<a href="https://github.com/sjpsega/CordovaWKWebViewTest">CordovaWKWebViewTest</a></p>

<h3>&ldquo;同步&rdquo; JSBridge 代码执行</h3>

<p>这里的"同步"需要打引号，虽然 WKWebView 提供了原生 web 向 Native 发送消息的方案，但是注意，这里是发送消息，还不是同步回调。</p>

<p>Cordova 新版本的插件机制，通过多重事件机制的方式，使得一种类型的 JSBridge 同步成为可能 - webView 打开页面后，需要调用 Native 端获取环境变量的 JSBridge。比如上例的 Device 这个 JSBridge 就是典型。</p>

<p>Cordova 启动的几个重要事件：</p>

<ul>
<li>onNativeReady</li>
<li>onDOMContentLoaded</li>
<li>onPluginsReady</li>
<li>onCordovaReady</li>
<li>onDeviceReady</li>
</ul>


<p>通常是从上往下依次进行，并且 web 开始调用 JSBridge，必须监听 <code>deviceready</code> 事件，所以 onDeviceReady 始终最后执行，代表 Cordova 插件环境完全准备完毕。</p>

<p>所以，这种"同步" JSBridge 就是利用这个特性，做了一些文章。</p>

<p>看关键代码：
```javascript
cordova.define(&ldquo;org.apache.cordova.device.device&rdquo;, function(require, exports, module) {
    channel = require(&lsquo;cordova/channel&rsquo;),
    exec = require(&lsquo;cordova/exec&rsquo;),
    //注册名为 onCordovaInfoReady 的 Sticky 类型的事件
    channel.createSticky(&lsquo;onCordovaInfoReady&rsquo;);
    //告诉系统，必须等待 CordovaInfoReady 事件发送
    channel.waitForInitialization(&lsquo;onCordovaInfoReady&rsquo;);</p>

<pre><code>function Device() {
    var me = this;
    //在 onCordovaReady 事件中，注册回调，使得系统初始化便调用该回调，并且 onCordovaReady 在 onPluginsReady 事件后 fire
    channel.onCordovaReady.subscribe(function() {
        //调用 JSBridge
        me.getInfo(function(info) {
            //调用 JSBridge 成功回调用，fire onCordovaInfoReady 事件
            channel.onCordovaInfoReady.fire();
        },function(e) {
        });
    });
}

Device.prototype.getInfo = function(successCallback, errorCallback) {
    exec(successCallback, errorCallback, "Device", "getDeviceInfo", []);
};

module.exports = new Device();
</code></pre>

<p>});
```</p>

<p>web 端调用 Device 的代码：
<code>javascript
document.addEventListener("deviceready", onDeviceReady, false);
function onDeviceReady() {
    console.log(device.uuid);
}
</code>
可以看到，deviceready 的时候，便可以直接调用 device 这个全局变量。
这是因为之前在 cordova_plugins.js 这个文件中，做了申明，会把 device 变为全局变量
<code>javascript
"clobbers": [
    "device" //全局命名空间，会注册为 window.device
]
</code></p>

<p>这种设计非常巧妙，但是以我的经验，这种形式的 JSBridge 使用比较局限，主要缺点有：</p>

<ul>
<li>只能对整个 App 周期，固定不变的值使用。如果使用中，这个值会变化则无法使用，如地理位置信息就不行</li>
<li>只能针对属性使用，不能对方法使用</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cordova WKWebView 学习笔记（一）]]></title>
    <link href="http://sjpsega.me/blog/2016/02/06/cordova-wkwebview-study-1/"/>
    <updated>2016-02-06T13:43:47+08:00</updated>
    <id>http://sjpsega.me/blog/2016/02/06/cordova-wkwebview-study-1</id>
    <content type="html"><![CDATA[<h2>WKWebView</h2>

<p>Apple 从 iOS 8 开始，引入了新的 WebView 类 <code>WKWebView</code>，试图替换已经老迈的 UIWebView。</p>

<h3>优点</h3>

<p>通过官方的描述，和自己实际测试，WKWebView功能相当强大，对比 UIWebView 的优点很多：</p>

<ul>
<li>更少的内存使用，渲染相同页面，占用内存基本只有 UIWebView 的 1/3 ~ 1/4，并且大大减少了内存泄露的情况</li>
<li>使用与 Safari 一样的性能强大的 Nirtro JS 引擎</li>
<li>异常强大的 app 与 web 的内容传递

<ul>
<li>可以使用 <code>WKUserContentController</code> 在 Native 端注入用户自定义脚本 JS</li>
<li>web 端可以使用 <code>window.webkit.messageHandlers.{NAME}.postMessage()</code>，直接向 Native 端发送消息。UIWebView 只能使用 iframe 等方案 hack</li>
</ul>
</li>
</ul>


<h3>限制</h3>

<p>官方的描述基本是溢美之词，他不会告诉你 WKWebView 的一些问题，但是这些问题，在做 Hybrid 应用的时候，影响很大，纯 wap 无影响。
估计是切换底层实现的关系，这些问题在 UIWebView 上不存在：</p>

<ul>
<li>无能加载本地文件，只能通过内建一个 WebServer 实现功能。（直到 iOS 9 才新开了一个loadFileURL:allowingReadAccessToURL: 接口，原生实现该功能）</li>
<li>不能注册自定义 NSURLProtocol，导致大量 URL 拦截功能难以实现，比如页面展示本地图片</li>
<li>不能使用 NSHTTPCookieStorage 设置 WebView 的 Cookie</li>
<li>必须 iOS8 及以上版本，Cordova 只支持 iOS9 及以上</li>
</ul>


<p>还有其他在实际开发中，可能爆出的 bug。</p>

<h2>Cordova WKWebview 现状</h2>

<p>Cordova 开发了<a href="https://github.com/apache/cordova-plugin-wkwebview-engine">一个插件</a>来支持 WKWebview，用户可以自行在 WKWebview 与 UIWebView 中选择。</p>

<p>但因为 WKWebView 存在的种种问题，WKWebView 还不是 Cordova 的默认选择。</p>

<p><a href="https://shazronatadobe.wordpress.com/2015/03/03/wkwebview-and-apache-cordova/">cordova 关于 WKWebView 的一些说明</a></p>

<h2>结论</h2>

<ul>
<li>纯 wap 页面，WKWebView 毫无问题，会有很好的表现</li>
<li>Hybrid 应用，因为现在存在的一些问题，以及会导致实现 Camera、PhotoList 等 JSBridge 的功能上会有较大限制，选择 WKWebView 需要慎重</li>
</ul>


<h2>相关代码</h2>

<p><a href="https://github.com/apache/cordova-plugin-wkwebview-engine">cordova-plugin-wkwebview-engine</a></p>

<p><a href="https://github.com/crosswalk-project/ios-extensions-crosswalk">CrossWalk Cordova Plugin Support</a></p>

<h2>相关资料</h2>

<p><a href="http://nshipster.cn/wkwebkit/">WKWeb​View</a></p>

<p><a href="http://docs.telerik.com/platform/appbuilder/cordova/configuring-your-app/configure-web-views">Telerik Platform Documentation - Configure the Web Views</a></p>

<p><a href="http://plugins.telerik.com/cordova/plugin/wkwebview">Cordova Plugins - WKWebView</a></p>

<p><a href="https://crosswalk-project.org/documentation/ios/cordova_plugin_support.html">CrossWalk - Cordova Plugin Support</a></p>

<p><a href="http://stackoverflow.com/questions/29268433/is-there-support-in-cordova-to-wkwebview">Is there support in Cordova to WKWebView?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[isEqual 与 Hash]]></title>
    <link href="http://sjpsega.me/blog/2016/01/14/isequalandhash/"/>
    <updated>2016-01-14T01:17:56+08:00</updated>
    <id>http://sjpsega.me/blog/2016/01/14/isequalandhash</id>
    <content type="html"><![CDATA[<h2>最佳实践</h2>

<ul>
<li>实现 <code>isEqualTo__ClassName__</code></li>
<li>重写 isEqual 方法，同时重写 hash 方法。</li>
</ul>


<h2>关系</h2>

<ul>
<li>两个对象 isEqual 相等，hash 必须也相等</li>
<li>两个对象 hash 相同，isEqual 则不一定相等</li>
</ul>


<h2>碰撞</h2>

<p>当对象存入集合对象时（Array，Set，HashTable等），内部会使用对象的 hash 值来作为 key 来存入。
当两个不相等的对象，有相同的 hash 值，存入集合对象，就会发生<code>碰撞</code>现象。
发生碰撞现象，对使得存取数据变慢，所以需要尽量避免这个现象，但不可能完全避免。</p>

<h2>作为集合对象 key 的注意点</h2>

<ul>
<li>实现 isEqual 和 hash 方法，遵守两者关系，尽量避免 hash 碰撞的情况发生</li>
<li>实现 NSCopying 协议，接口：<code>- (void)setObject:(ObjectType)anObject forKey:(KeyType &lt;NSCopying&gt;)aKey;</code></li>
</ul>


<h2>测试 Demo</h2>

<p><a href="https://github.com/sjpsega/EqualAndHashTest">测试 Demo</a></p>

<h2>参考资料</h2>

<p><a href="http://nshipster.com/equality/">Equality</a></p>

<p><a href="https://mikeash.com/pyblog/friday-qa-2010-06-18-implementing-equality-and-hashing.html">Implementing Equality and Hashing</a></p>
]]></content>
  </entry>
  
</feed>
