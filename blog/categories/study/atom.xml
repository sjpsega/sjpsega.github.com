<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | sjpsega's Blog]]></title>
  <link href="http://sjpsega.me/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://sjpsega.me/"/>
  <updated>2015-08-31T22:29:17+08:00</updated>
  <id>http://sjpsega.me/</id>
  <author>
    <name><![CDATA[sjpsega]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GCD 学习]]></title>
    <link href="http://sjpsega.me/blog/2015/08/31/gcd-study/"/>
    <updated>2015-08-31T00:08:49+08:00</updated>
    <id>http://sjpsega.me/blog/2015/08/31/gcd-study</id>
    <content type="html"><![CDATA[<p>Grand Central Dispatch （GCD）是 Apple 开发的一个多核编程的解决方法。</p>

<p>底层、轻量，是 iOS 上常用的多线程解决方案。</p>

<h2>基本操作</h2>

<h3>sync、async</h3>

<p>dispatch_sync （同步）添加任务到一个队列并等待，直到任务完成，再执行原有队列上的任务。</p>

<p>dispatch_async （异步）添加任务到一个队列，但继续执行原有队列上的任务，在队列中按照 FIFO 的规则执行。</p>

<pre><code class="objc">dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"log 1");
    });
NSLog(@"log 2");
/* 输出:
 * log 1
 * log 2
 * /
</code></pre>

<pre><code class="objc">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"log 1");
    });
NSLog(@"log 2");
/* 输出绝大多数情况为:
 * log 2
 * log 1
 * /
</code></pre>

<p><code>注：不能在串行（主线程是一种串行队列）线程队列的任务中，再使用 dispatch_sync 添加任务到同一个串行队列中，否则必定发生死锁。</code></p>

<pre><code class="objc">dispatch_async(dispatch_get_main_queue(), ^{
    //必定发生死锁
    dispatch_sync(dispatch_get_main_queue(), ^{
    });
});
</code></pre>

<h3>dispatch_once</h3>

<p>dispatch_once 线程安全的方式执行任务且仅执行其代码块一次。</p>

<p>在单例模式中普遍使用。</p>

<pre><code class="objc">static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    NSLog(@"log 1");
});
dispatch_once(&amp;onceToken, ^{
    NSLog(@"log 2");
});
/* 输出:
 * log 1
 * /
</code></pre>

<h3>dispatch_after</h3>

<p>dispatch_after 延后一定时间，异步执行任务</p>

<pre><code class="objc">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@"log 1");
    });
NSLog(@"log 2");
/* 输出:
 * log 2
 * log 1
 * /
</code></pre>

<h2>group</h2>

<p>通常使用分组来关联一组相关的任务，任务全部完成后，再做相关操作。</p>

<h3>group_enter、group_leave</h3>

<p>使用 dispatch_group_enter、dispatch_group_leave 来手动设置一个组任务的开始和结束，用来控制复杂情况下的任务完成情况。</p>

<p>必须保证 dispatch_group_enter 和 dispatch_group_leave <code>成对出现</code>，否则会遇到崩溃问题。</p>

<p>实例：</p>

<p>a）不使用 dispatch_group_enter、dispatch_group_leave 的情况
<code>objc
- (void)testGCDWithGroup{
    __block int count = 0;
    __block BOOL isDone = NO;
    // 1
    dispatch_group_t group = dispatch_group_create();
    // 2
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"CGD 1 .");
        // 3
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSLog(@"CGD 1 after.");
            count++;
        });
    });
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"done !!!");
        // 4
        isDone = YES;
        expect(count).to.equal(1);
    });
    // 5
    expect(isDone).will.beTruthy();
}
</code>
该测试用例执行步骤为:</p>

<ol>
<li>生成一个自定义组</li>
<li>在自定义组上，添加任务到子线程上执行</li>
<li>子线程上的任务为执行一个延时任务，使得 count + 1</li>
<li>当一个组内的任务全部完成，设置 isDone 为 YES，并期望 count 为 1</li>
<li>异步执行，期望 isDone 为 YES</li>
</ol>


<p>期望4、5处的测试均能通过，但测试结果为：</p>

<ol>
<li>5 的测试 case 为通过</li>
<li>4 的测试 case <code>不通过</code>，count 不为 1</li>
</ol>


<p>因为在这个例子中，执行完毕 dispatch_group_async 中的任务，就算任务完成了；而不是等到 dispatch_group_async 中的 dispatch_after 任务完成，才算任务完成。</p>

<p>b）使用 dispatch_group_enter、dispatch_group_leave 的情况
<code>objc
- (void)testGCDWithGroupEnterAndLeave{
    __block int count = 0;
    __block BOOL isDone = NO;
    dispatch_group_t group = dispatch_group_create();
    dispatch_group_enter(group);
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"CGD 1 .");
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSLog(@"CGD 1 after.");
            dispatch_group_leave(group);
            count++;
        });
    });
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"done !!!");
        isDone = YES;
        expect(count).to.equal(1);
    });
    expect(isDone).will.beTruthy();
}
</code>
这个测试用例的全部通过，使用手动控制组任务的开始和结束，完美解决了例子 a 中碰到的问题。</p>

<p>使用 dispatch_group_enter、dispatch_group_leave，用来处理复杂的异步任务非常有效。</p>

<h2>queue</h2>

<h3>串行、并发</h3>

<p>串行队列每次只有一个任务被执行，并发队列在同一时间可以有多个任务被执行。</p>

<p>主线程是系统提供的一个特殊的队列，是一个<code>串行</code>队列，是唯一可用与更新 UI 的线程。</p>

<p>除了主线程，其他均为子线程，通常用来执行与 UI 无关的操作。
实际编码中，通常使用 <code>dispatch_get_global_queue(long identifier, unsigned long flags)</code> 来获取子线程队列。通过该方法获取的是<code>并发</code>的全局调度队列，并且可以设置四个不同优先级的队列：high、default、low、background，若没有特殊原因，只使用 default 级别的队列。</p>

<p>用户还可以使用 <code>dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)</code> 来创建自定义的串行或并发队列。
主线程是系统提供的<code>串行</code>队列。</p>

<pre><code class="objc">//创建自定义并发队列
dispatch_queue_t concurrentQueue = dispatch_queue_create("com.sjpsega", DISPATCH_QUEUE_CONCURRENT);
//创建自定义创兴队列
dispatch_queue_t serialQueue = dispatch_queue_create("com.sjpsega", DISPATCH_QUEUE_SERIAL);
</code></pre>

<h2>dispatch_barrier</h2>

<p>barrier 意为“障碍”。dispatch_barrier 在并发队列上工作时扮演一个串行式的瓶颈。当提交的任务开始执行时，该 API 保障这个时刻队列里只执行当前任务，不会执行其他任务。</p>

<p><img src="/images/2015-08-31-gcd-study/dispatch_barrier.png" alt="dispatch_barrier" /></p>

<p>使用 dispatch_barrier API 最佳的方式是使用<code>自定义并发队列</code>执行。</p>

<p>下面以使用 dispatch_barrier 保证类类变量线程安全为例：</p>

<pre><code class="objc">- (void)addStudents:(Student *)student{
    dispatch_barrier_async(_concurrentQueue, ^{
        [_students addObject:student];
    });
}

- (NSArray *)students{
    __block NSArray *copyObj;
    dispatch_sync(_concurrentQueue, ^{
        copyObj =  [_students copy];
    });
    return copyObj;
}
</code></pre>

<p>但是，通常保证类变量线程安全，若不是高并发的情况下，比较简单的方式是使用 <code>synchronized</code> 关键字：</p>

<pre><code class="objc">- (void)addStudents:(Student *)student{
    @synchronized(_students){
        [_students addObject:student];
    }
}

- (NSArray *)students{
    @synchronized(_students){
        return [_students copy];
    }
}
</code></pre>

<h2>测试 Demo</h2>

<p><a href="https://github.com/sjpsega/GCDTest">测试 Demo</a></p>

<h2>参考资料</h2>

<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">GCD 深入理解：第一部分</a></p>

<p><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md">GCD 深入理解：第二部分</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UIWebView 自定义协议文件加载缓存问题]]></title>
    <link href="http://sjpsega.me/blog/2015/06/15/uiwebview-cache-bug-by-custom-protocol/"/>
    <updated>2015-06-15T22:56:31+08:00</updated>
    <id>http://sjpsega.me/blog/2015/06/15/uiwebview-cache-bug-by-custom-protocol</id>
    <content type="html"><![CDATA[<h2>起因</h2>

<p>一个简单的需求：为了减少网络请求，一些前端资源会做本地缓存；使用 WebView 访问页面的时候，拦截特定请求，使得特定请求直接加载本地资源。</p>

<p>但是做的过程中发现，当请求的资源为自定义协议的时候，比如加载的 url 为 <code>abc://xxx.com/xx.js</code> 的时候，系统会强制对该资源做缓存，并且调用系统提供的清除缓存接口，如 <code>[[NSURLCache sharedURLCache] removeAllCachedResponses]</code>， 都无法清除该缓存，除非重启 App。</p>

<p>这就导致该资源内容发生变化的时候，无法立即生效，这在业务中，显然是不能接受的。</p>

<p><code>注</code>：该方案主要针对 <code>UIWebView</code> 有效；<code>WKWebView</code> 因为不能使用自定义 NSURLProtocol 拦截资源，方法二就不起作用。</p>

<h2>解决</h2>

<h3>方法一：html 模板上，资源 url 加上随机字符串</h3>

<p>在 html 页面上修改 url 字符串，如 <code>abc://xxx.com/xx.js</code>，需要改成 <code>abc://xxx.com/xx.js?t=123</code>，这样系统就不会缓存该资源。</p>

<p>该方法简单直接。</p>

<h3>方法二：创建自定义 NSURLProtocol，拦截请求，并且在创建 response 时，修改自定义协议为 http 或 https</h3>

<p>伪代码如下：
<code>objc
//原请求
NSString *requestURLString = @"abc://xxx.com/xx.js";
//根据原请求获得的 data 数据
NSData *abcData = ...
//将原请求的自定义协议改成 http
NSString *changeURLString = @"http://xxx.com/xx.js";
//创建 response
NSURL *url = [NSURL URLWithString:changeURLString];
NSURLResponse* response =
[[NSURLResponse alloc] initWithURL:url
                          MIMEType:@"application/x-javascript"
             expectedContentLength:abcData.length
                  textEncodingName:@"UTF-8"];
[[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
[[self client] URLProtocol:self didLoadData:abcData];
[[self client] URLProtocolDidFinishLoading:self];
</code></p>

<p>本来结合方法一的解决方式，创建 response 的时候，在 url 后加上随机字符串，但是经过试验，该方案<code>无效</code>，缓存始终存在。</p>

<p>使用该解决方法解决缓存问题，据个人猜测是因为，iOS 系统默认缓存数据，但针对 http 或 https 协议会根据 Cache-Control 等字段判断是否缓存。</p>

<p>具体可见 <a href="https://github.com/sjpsega/CustomProtocolCacheTest">测试demo</a>，并注意 log 信息。</p>

<h2>讨论</h2>

<p>解决这个缓存问题，其实我还是有些疑惑，因为试了所有 iOS 给出的数据缓存 API，都不起作用。这些包括：</p>

<ul>
<li>使用 [[NSURLCache sharedURLCache] removeAllCachedResponses] 清理缓存</li>
<li>重写了 NSURLCache 的 - (NSCachedURLResponse <em>)cachedResponseForRequest:(NSURLRequest </em>)request 方法，不返回 response 对象</li>
<li>自定义 NSURLProtocol 中，使用 NSURLConnection 加载数据，实现 NSURLConnectionDelegate 的 - (NSCachedURLResponse <em>)connection:(NSURLConnection </em>)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse 方法，返回 nil，不做对应 url 数据的缓存。</li>
</ul>


<p>然后，方法一与方法二中，我都试验了 url 加随机字符串的方式，但是为什么 html 模板上的资源 url 加上随机字符串有效，创建 response 时候，url 加上随机字符串无效，我也感到无解。</p>

<p>感觉在 webView 资源缓存的问题上，Apple 官方还是有些接口没开放，或者是我不知道&hellip;</p>

<h2>参考资料</h2>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">URL Loading System</a></p>

<p><a href="http://nshipster.cn/nsurlcache/">NSURLCache</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重置 iOS UIWebView 的缩放]]></title>
    <link href="http://sjpsega.me/blog/2015/03/25/reset-webview-zoom-with-ios/"/>
    <updated>2015-03-25T14:01:19+08:00</updated>
    <id>http://sjpsega.me/blog/2015/03/25/reset-webview-zoom-with-ios</id>
    <content type="html"><![CDATA[<h2>需求</h2>

<p>遇到一个需求，iOS webView设置了可缩放，用户缩放webView后，做某个操作，需要将webView的缩放重置。</p>

<h2>经过</h2>

<p>在网上找了下，看到很多很多解决方案，不论是国内的，还是国外的解决方案，但是实际使用都没有效果……</p>

<h2>解决</h2>

<p>经过不断尝试，发现以下方式是有效果的：</p>

<pre><code class="objc">//重置 webView 的 html viewport 属性，变成不可缩放，并且缩放比例为1.0，并执行javaScript
#define QUOTE(...) #__VA_ARGS__
const char *webViewHeightJSString = QUOTE(
var viewportmeta = document.querySelector('meta[name="viewport"]');
if (viewportmeta) {
viewportmeta.content = 'width=device-width, initial-scale=1.0,      minimum-scale=1.0, maximum-scale=1.0, user-scalable=no';
}
);
#undef QUOTE
[webView stringByEvaluatingJavaScriptFromString:[NSString stringWithUTF8String:webViewHeightJSString]];
//设置 webView zoomScale 为 1.0，且必须设置animated为YES
[webView.scrollView setZoomScale:1.0 animated:YES];
</code></pre>

<p>此方法在iOS7、8上的 UIWebView 上测试通过，WKWebView 没有测试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Method Swizzling]]></title>
    <link href="http://sjpsega.me/blog/2014/09/17/oc-method-swizzling/"/>
    <updated>2014-09-17T22:36:40+08:00</updated>
    <id>http://sjpsega.me/blog/2014/09/17/oc-method-swizzling</id>
    <content type="html"><![CDATA[<p>Objective-C 中的 Method Swizzling 是一种可以在程序运行时，修改方法调用的技术。是 OC 作为动态语言的典型证明。</p>

<p>Method Swizzling 是 OC <code>&lt;objc/runtime.h&gt;</code> 类库提供的“黑魔法”之一。</p>

<h2>例子</h2>

<p>以替换 NSArray 的 lastObject 方法为例：</p>

<ul>
<li>在 NSArray 中添加需要替换 lastObject 的方法 - xxx_lastObject方法：</li>
</ul>


<pre><code class="objc">#import "NSArray+Swizzle.h"  

@implementation NSArray (Swizzle)  

- (id)xxx_lastObject  
{  
    id ret = [self xxx_lastObject];  
    NSLog(@"**********  myLastObject ***********");  
    return ret;  
}  
@end  
</code></pre>

<p>注意这里的写法，xxx_lastObject 方法的方法体中调用了 [self xxx_lastObject]，这样写并不会造成递归，后面会交换 xxx_lastObject 与 lastObject 的 IMP，其实 [self xxx_lastObject] 将会执行 [self lastObject] 。</p>

<ul>
<li>调换 IMP</li>
</ul>


<pre><code class="objc">#import &lt;objc/runtime.h&gt;  
#import "NSArray+Swizzle.h"

Method ori_Method =  class_getInstanceMethod([NSArray class], @selector(lastObject));  
Method my_Method = class_getInstanceMethod([NSArray class], @selector(xxx_lastObject));  
method_exchangeImplementations(ori_Method, my_Method);  
</code></pre>

<p>注意这里需要引入 <code>&lt;objc/runtime.h&gt;</code>，否则会报错，因为使用了 runtime 中的 method_exchangeImplementations 方法。</p>

<p>使用 <code>method_exchangeImplementations</code> 交换了 xxx_lastObject 与 lastObject 的 IMP。后面会讲解更深层次的原理。</p>

<ul>
<li>尝试调用 lastObject</li>
</ul>


<pre><code class="objc">#import &lt;objc/runtime.h&gt;
#import "NSArray+Swizzle.h"

NSArray *array = @[@"0",@"1",@"2",@"3"];  
NSString *string = [array lastObject];  
NSLog(@"TEST RESULT : %@",string);  
</code></pre>

<p>输出结果为:</p>

<pre><code class="objc">**********  myLastObject ***********
TEST RESULT : 3
</code></pre>

<p>很明显，这里调用 lastObject 方法，其实是调用了我们添加的 xxx_lastObject 方法。</p>

<h2>用处</h2>

<p>Method Swizzling 非常强大，主要作用有：</p>

<ul>
<li>在不修改 iOS 系统类库或第三方类库的源码基础上，修改原有调用逻辑</li>
<li>动态添加、修改方法，修复线上 bug（如果 Apple 官方允许的话）</li>
</ul>


<h2>常用 API</h2>

<p>相关常用方法，都在<code>&lt;objc/runtime.h&gt;</code>包内：</p>

<pre><code class="objc">//向类中添加Method
BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)

//修改类的Method
IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)

//交换2个方法中的IMP
void method_exchangeImplementations(Method m1, Method m2)

//获取类的某个实例方法
Method class_getInstanceMethod(Class aClass, SEL aSelector);
</code></pre>

<h2>底层原理</h2>

<p>在运行时，OC 的方法是一种叫 <code>Method</code> 的结构体，这种 <code>objc_method</code> 类型的结构体定义为：</p>

<pre><code class="objc">struct objc_method
   SEL method_name         OBJC2_UNAVAILABLE;
   char *method_types      OBJC2_UNAVAILABLE;
   IMP method_imp          OBJC2_UNAVAILABLE;
}
</code></pre>

<ul>
<li>method_name 是方法的 selector，可以理解为运行时的方法名；</li>
<li>*method_types 是一个参数和返回值类型<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">编码</a>的字符串；</li>
<li>method_imp 是指向方法实现的指针。</li>
</ul>


<p><code>Method Swizzling 的实质是在运行时，访问对象的方法结构体，并改变它的底层实现。</code></p>

<p>我们以上节修改 NSArray 的 lastObject 为例做说明。</p>

<ul>
<li>初始时，lastObject 与 xxx_lastObject 方法的 Method 结构体：</li>
</ul>


<pre><code class="objc">Method lastObject {
      SEL method_name = @selector(lastObject)
      char *method_types = “v@:“ //返回值void, 参数id(self)，selector(_cmd)
      IMP method_imp = 0x000FFFF //指向([NSArray lastObject])
}

Method xxx_lastObject {
       SEL method_name = @selector(swizzle_originalMethodName)
       char *method_types = “v@:”
       IMP method_imp = 0x1234AABA //指向([NSArray xxx_lastObject])
}
</code></pre>

<ul>
<li>调用 <code>void method_exchangeImplementations(Method m1, Method m2)</code> ,交换两者的实现：</li>
</ul>


<pre><code class="objc">Method ori_Method =  class_getInstanceMethod([NSArray class], @selector(lastObject));  
Method my_Method = class_getInstanceMethod([NSArray class], @selector(xxx_lastObject));  
method_exchangeImplementations(ori_Method, my_Method);
</code></pre>

<ul>
<li>调换后的 Method 结构体：</li>
</ul>


<pre><code class="objc">Method lastObject {
      SEL method_name = @selector(lastObject)
      char *method_types = “@@:“ //返回值id, 参数id(self)，selector(_cmd)
      IMP method_imp = 0x1234AABA //指向([NSArray xxx_lastObject])
}

Method xxx_lastObject {
       SEL method_name = @selector(swizzle_originalMethodName)
       char *method_types = “@@:”
       IMP method_imp = 0x000FFFF //指向([NSArray lastObject])
}
</code></pre>

<p>可以看到使用<code>void method_exchangeImplementations(Method m1, Method m2)</code>的实质是交换了xxx_lastObject 与 lastObject 的 IMP，实现了在运行时做方法的替换。使得当执行 [array lastObject] 的时候，实际会去执行 [array xxx_lastObject] 的方法实现。</p>

<h2>其他提示</h2>

<h3>+load</h3>

<p>Swizzling 的处理，在类的 <code>+load</code> 方法中完成。</p>

<p>因为 <code>+load</code> 方法会在类被添加到 OC 运行时执行，且只会被调用一次，保证了 Swizzling 方法的及时处理。</p>

<h3>dispatch_once</h3>

<p>Swizzling 的处理，<code>dispatch_once</code> 中完成。保证只执行一次。</p>

<h3>prefix</h3>

<p>Swizzling 方法添加前缀，避免方法名称冲突。</p>

<h2>代码示例</h2>

<p><a href="https://github.com/sjpsega/SwizzleTest">代码示例</a></p>

<h2>参考资料</h2>

<p><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></p>

<p><a href="http://stackoverflow.com/questions/3267506/how-to-swizzle-a-class-method-on-ios">How to swizzle a class method on iOS?</a></p>

<p><a href="http://www.friday.com/bbum/2011/03/17/ios-4-3-imp_implementationwithblock/">iOS 4.3: imp_implementationWithBlock()</a></p>

<p><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">Objective-C的hook方案（一）:  Method Swizzling</a></p>

<p><a href="http://blog.jobbole.com/45963/">Objective-C 的动态提示和技巧</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS H5的那些坑]]></title>
    <link href="http://sjpsega.me/blog/2014/08/06/ios-h5-trap/"/>
    <updated>2014-08-06T17:47:30+08:00</updated>
    <id>http://sjpsega.me/blog/2014/08/06/ios-h5-trap</id>
    <content type="html"><![CDATA[<p>最近做 iOS H5 项目，需要针对 iOS 的 webView 做适配，发现几个非常恶心的 bug。</p>

<p>因为现在据统计 iOS7 的占比超过80%，所以适配主要针对 iOS7，但是 iOS7 不同版本缺有不同的 bug，真是让人蛋疼。</p>

<h2>iOS 7.0 input 元素聚焦问题</h2>

<h3>bug 演示</h3>

<p><img src="/images/2014-08-06-ios-h5-trap/ios7.0bug.gif" alt="ios7.0bug.gif" /></p>

<h3>bug 分析</h3>

<p>点击屏幕下方的input元素，且该元素在键盘弹起的区域内；当键盘弹起时，input 元素未获得焦点，且 input 元素不在可视范围内，没有进行自动定位调整。</p>

<p>但 input 元素不在键盘弹起的区域内，当键盘弹起时，一切正常。</p>

<p>该 bug，iOS &lt; 7.1 有问题，>=7.1 无问题。</p>

<h3>解决办法</h3>

<p>办法有点猥琐，要通过 js，去强制 input 元素获得焦点。</p>

<pre><code class="javascript">element.on("tap", function(e){
  element.focus();
});
</code></pre>

<h3>参考资料</h3>

<p><a href="http://stackoverflow.com/questions/16149083/keyboardshrinksview-makes-lose-focus">KeyboardShrinksView makes lose focus</a></p>

<p><a href="https://issues.apache.org/jira/browse/CB-6974">Keyboard causes input focus issue</a></p>

<h2>iOS 7.1 input 元素失焦问题</h2>

<h3>bug 演示</h3>

<p><img src="/images/2014-08-06-ios-h5-trap/ios7.1bug.gif" alt="ios7.1bug.gif" /></p>

<h3>bug 分析</h3>

<p>点击 input 元素（input 元素在不在浮层中不重要），弹出键盘时，当点击 Html 中的元素，致使 input 元素失去焦点，键盘收起，position:fixed 元素（演示中的浮层为 position:fixed）会导致界面错乱。</p>

<p>但若点击键盘右上角的 <code>完成</code> 按钮，键盘收起，一切正常。</p>

<p>也就是说，使用 iOS 系统的方式使得键盘收起，没有问题；使用其他方式，使得键盘收起，position:fixed 元素会导致界面错乱。</p>

<p>该 bug，iOS >= 7.1 有问题，&lt; 7.1 无问题。正好与iOS 7.0 input 元素聚焦 bug 的情况相反。</p>

<p><code>注：iOS 键盘的操作，必须由用户的操作引发，想通过 JSBridge 去让键盘收起的方案是行不通的。</code></p>

<h3>解决办法</h3>

<p>避免使用 position:fixed，换成 position:absolute 替代。</p>

<h3>参考资料</h3>

<p><a href="http://stackoverflow.com/questions/18970865/ios-7-input-elements-moving-fixed-positioned-elements">ios-7-input-elements-moving-fixed-positioned-elements</a></p>
]]></content>
  </entry>
  
</feed>
