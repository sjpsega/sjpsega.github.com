<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Study | sjpsega's Blog]]></title>
  <link href="http://sjpsega.com/blog/categories/study/atom.xml" rel="self"/>
  <link href="http://sjpsega.com/"/>
  <updated>2014-05-25T20:46:53+08:00</updated>
  <id>http://sjpsega.com/</id>
  <author>
    <name><![CDATA[sjpsega]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS中的单例模式]]></title>
    <link href="http://sjpsega.com/blog/2014/05/25/singleton-in-ios/"/>
    <updated>2014-05-25T12:25:10+08:00</updated>
    <id>http://sjpsega.com/blog/2014/05/25/singleton-in-ios</id>
    <content type="html"><![CDATA[<p>单例模式是指在一个系统中，类有且只有一个实例对象，可以通过全局的一个入口对这个实例对象进行访问。</p>

<p>在iOS开发中，单例模式是非常常用的一种设计模式。</p>

<h2>ARC下的实现</h2>

<p>iOS5.0以后就开始可以使用ARC（Automatic Reference Counting：自动引用计数）来代替之前的MRC（Manual Reference Counting：人工引用计数）。</p>

<p>使用ARC会减少很多代码和忘了释放对象的苦恼。</p>

<p>慢慢ARC会成为主流，我入门iOS也是学ARC的，所以这里只写ARC的单例实现。</p>

<p><code>Singleton.h:</code>
```objc
//
//  Singleton.h
//  Singleton</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface Singleton : NSObject</p>

<ul>
<li>(Singleton *)sharedInstance;</li>
</ul>


<p>@end</p>

<p>```</p>

<p><code>Singleton.m:</code>
```objc</p>

<p>//
//  Singleton.m
//  Singleton</p>

<h1>import &ldquo;Singleton.h&rdquo;</h1>

<p>@implementation Singleton</p>

<ul>
<li>(Singleton <em>)sharedInstance{
  static Singleton </em>singleton;
  static dispatch_once_t token;
  dispatch_once(&amp;token,^{
      singleton = [[Singleton alloc]init];
  });
  return singleton;
}</li>
</ul>


<p>&ndash;(id)init{</p>

<pre><code>self = [super init];
if(self){
    //在这里可以进行类的初始化工作
}
return self;
</code></pre>

<p>}</p>

<p>@end</p>

<p>```</p>

<p>在这个实现中，核心是使用了GCD（Grand Central Dispatch）的<code>dispatch_once</code>方法，该方法可以保证Singleton只被实例化一次，并且该方法<code>线程安全</code>。</p>

<h2>纰漏</h2>

<p>以上实现有一个纰漏，Singleton继承与<code>NSObject</code>，<code>NSObject</code>有一个公开的初始化方法<code>-(id)init</code>，所以若使用者不小心，他完全可以使用<code>[[Singleton alloc]init]</code>来创建多个实例对象，这样轻易就破坏了单例的实现。</p>

<p>例如：
<code>objc
Singleton *single1 = [[Singleton alloc]init];
Singleton *single2 = [[Singleton alloc]init];
//结果为0，即NO，两者不是同一个实例
NSLog(@"%d",single1 == single2);
</code></p>

<h2>更好的实现</h2>

<p>其实是要对<code>Singleton.m</code>做一点改变，就能封住这个纰漏：</p>

<p>```objc
//
//  Singleton.m
//  Singleton</p>

<h1>import &ldquo;Singleton.h&rdquo;</h1>

<p>@implementation Singleton</p>

<ul>
<li>(Singleton <em>)sharedInstance{
  static Singleton </em>singleton;
  static dispatch_once_t token;
  dispatch_once(&amp;token,^{
      //这里调用私有的initSingle方法
      singleton = [[Singleton alloc]initSingle];
  });
  return singleton;
}</li>
</ul>


<p>//只是把原来在init方法中的代码，全都搬到initSingle
&ndash;(id)initSingle{</p>

<pre><code>self = [super init];
if(self){
    //在这里可以进行类的初始化工作
}
return self;
</code></pre>

<p>}</p>

<p>&ndash;(id)init{</p>

<pre><code>//改为调用[Singleton sharedInstance]
return [Singleton sharedInstance];
</code></pre>

<p>}</p>

<p>@end
```</p>

<ul>
<li>新建initSingle方法，将原来init中的实现，全部搬入</li>
<li>sharedInstance中的初始化，调用initSingle方法</li>
<li>init方法中，调用[Singleton sharedInstance]</li>
</ul>


<p>该实现，我是自己在实践中，觉得更好的单例实现，如有问题，请及时反馈。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Category添加实例变量的故事]]></title>
    <link href="http://sjpsega.com/blog/2014/04/07/category-with-instance-variables/"/>
    <updated>2014-04-07T20:55:16+08:00</updated>
    <id>http://sjpsega.com/blog/2014/04/07/category-with-instance-variables</id>
    <content type="html"><![CDATA[<h2>起因</h2>

<p>有一个需求，针对 url 字符串，需要根据传入的key获取对应参数键值对的value。例如：</p>

<p><code>objc
NSString *urlString = @"http://www.1688.com?key1=val1&amp;key2=val2";
NSURL *url = [NSURL URLWithString:urlString];
NSString *val = [url paramWithKey:@"key1"];
</code></p>

<p>NSURL 类虽然自带方法很多，但是却没有这个有用的方法。故需要做类扩展（Category）。</p>

<p>实现的时候，需要一个 NSDictionary 类型的实例变量来存储 url 字符串的参数键值对，便于多次调用 -paramWithKey 的时候，提高性能。</p>

<h2>经过</h2>

<p>写的时候，闹了几个笑话，走了弯路，记录下来。</p>

<h3>在头文件中添加变量</h3>

<p><code>objc
@interface NSURL (WingQueryDictionary)
@property (nonatomic, copy) NSDictionary *queryDictionary;
@end
</code></p>

<p>结果：编译不报错，但是实际执行中，实例中，找不到 self.queryDictionary 这个变量。</p>

<h3>直接在 Category 中添加实例变量</h3>

<p>```objc
@implementation NSURL (QueryDictionary){</p>

<pre><code>NSDictionary *queryDictionary;
</code></pre>

<p>}
@end
```</p>

<p>结果：编译直接报错，因为<code>Category不允许为已有的类添加新的属性或者实例变量，只能添加新方法</code>。</p>

<h3>在匿名 Category 中添加实例变量</h3>

<p>```objc
@interface NSURL(){</p>

<pre><code>NSDictionary *queryDictionary;
</code></pre>

<p>}
@end</p>

<p>@implementation NSURL (QueryDictionary){</p>

<pre><code>NSDictionary *queryDictionary;
</code></pre>

<p>}</p>

<ul>
<li>(NSString <em>)paramWithKey:(NSString </em>)key{
  return self.queryDictionary[key];
}
@end
```</li>
</ul>


<p>结果：编译直接报错，原因同上。</p>

<h3>添加一个类变量</h3>

<p>```objc
static NSDictionary *queryDictionary;</p>

<p>@implementation NSURL (WingQueryDictionary)
@end
```</p>

<p>结果：能够完成需求，但是若新建多个 NSURL 并调用 -paramWithKey 方法，参数获取会有bug。</p>

<h3>利用 runtime.h 来实现添加实例变量</h3>

<p>最后，实在没辙了，只能 google 找方法。</p>

<p>发现可以<code>利用 runtime.h 中 objc_getAssociatedObject / objc_setAssociatedObject 方法来模拟生成实例变量</code>。</p>

<p>关键代码：
```objc</p>

<h1>import &lt;objc/runtime.h></h1>

<p>static const char *varKey = &ldquo;queryDictionary&rdquo;;</p>

<ul>
<li><p>(NSDictionary <em>)queryDictionary {
  return (NSDictionary </em>)objc_getAssociatedObject(self, &amp;varKey);
}</p></li>
<li><p>(void)setQueryDictionary:(NSDictionary *)queryDictionary {
  objc_setAssociatedObject(self, &amp;varKey, queryDictionary, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
```</p></li>
</ul>


<h3>API 解析</h3>

<p>设置实例对象：
<code>objc
void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)
</code>
用该方法来完成实例变量的 setter 实现。</p>

<ul>
<li>参数 id：设置实例对象相关的实例，通常为self</li>
<li>参数 key：设置实例对象的key，即name</li>
<li>参数 value：设置实例对象的值</li>
<li>参数 policy：设置实例对象的内存对策，可选值如下：

<ul>
<li>(weak) / (assign) OBJC_ASSOCIATION_ASSIGN</li>
<li>(strong) / (retain) OBJC_ASSOCIATION_RETAIN</li>
<li>(copy) OBJC_ASSOCIATION_COPY</li>
<li>(nonatomic,strong) OBJC_ASSOCIATION_RETAIN_NONATOMIC</li>
<li>(nonatomic,copy) OBJC_ASSOCIATION_COPY_NONATOMIC</li>
</ul>
</li>
</ul>


<p>获得实例对象：
<code>objc
id objc_getAssociatedObject(id object, void *key)
</code>
完成实例变量的 getter实现。看了 setter 实现，这个方法的参数就很容易理解了。</p>

<h2>参考资料</h2>

<p><a href="http://www.cnblogs.com/wupher/archive/2013/01/05/2845338.html">让Category支持添加属性与成员变量</a></p>

<p><a href="http://kaspermunck.github.io/2012/11/adding-properties-to-objective-c-categories/">Adding Properties to Objective-C Categories</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Js与native相互通信]]></title>
    <link href="http://sjpsega.com/blog/2014/03/08/js-communicate-with-native-in-iOS/"/>
    <updated>2014-03-08T21:53:16+08:00</updated>
    <id>http://sjpsega.com/blog/2014/03/08/js-communicate-with-native-in-iOS</id>
    <content type="html"><![CDATA[<h2>js与navive相互通信的机制</h2>

<h3>js &ndash;> native</h3>

<p>目前，截止至iOS7，iOS原生并没有提供js直接调用native的方式，只能通过UIWebView相关的UIWebViewDelegate协议的</p>

<p><code>objc
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
</code></p>

<p>方法来做拦截，并在这个方法中，根据url的协议或特征字符串来做调用方法或触发事件等工作，如</p>

<p>```objc
&ndash; (BOOL)webView:(UIWebView <em>)webView shouldStartLoadWithRequest:(NSURLRequest </em>)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<pre><code>NSURL *url = [request URL];
if ([[url scheme] isEqualToString:@"callFunction") {
    //调用原生方法

    return NO;
} else if (([[url scheme] isEqualToString:@"sendEvent") {    
    //触发事件

    return NO;
} else {
    return YES;
}
</code></pre>

<p>}
<code>``
虽然通过这个方式，js调用native是</code>异步`的，但是效率还是很高，我通过在js调用端，把time传入navive然后相减的方式计算，平均只有5ms的时间间隔。</p>

<h4>如何触发这个方法拦截</h4>

<p>最最简单且实用的方法莫过于用js创建一个隐藏的iframe设置src了，代码：</p>

<p>```js
function js2native(){</p>

<pre><code>var iframe = document.createElement("iframe");
iframe.src="callFunction://";
iframe.style.display = 'none';
document.body.appendChild(iframe);
iframe.parentNode.removeChild(iFrame);
iframe = null;
</code></pre>

<p>}
```</p>

<p>通过查看phoneGap源码的iOSExec方法，还有使用XMLHttpRequest或修改hash的方式来触发方法拦截，但是因为有bug或其他原因，不推荐。</p>

<h3>native &ndash;> js</h3>

<p>native调用js非常简洁方便，只需要</p>

<p><code>objc
[webView stringByEvaluatingJavaScriptFromString:@"alert('hello world!')"];
</code>
并且该方法是<code>同步</code>的。</p>

<h2>调试</h2>

<p><del>虽然现在能直接用Safari的开发模式直接查看模拟器中的webView页面，但是经过亲自尝试，最想要的也是最重要的js调试，还是不支持，不能进行js断点调试，还是要依赖console来弄……当然css样式调试支持的不错。</del></p>

<p>2014-04-09 update: 昨天发现Safari是可以对模拟器中的webView页面进行js断点调试的，之前是因为我没有设置<code>启用所有断点</code>……</p>

<p>可以在模拟器进入webView页面后，打开Safari，然后在 开发->iPhone simulator 菜单下进行页面选择，进入调试。</p>

<h3>相关资料</h3>

<p><a href="http://blog.devtang.com/blog/2012/03/24/talk-about-uiwebview-and-phonegap/">唐巧-关于UIWebView和PhoneGap的总结</a></p>

<p><a href="https://github.com/marcuswestin/WebViewJavascriptBridge">Github上的WebViewJavascriptBridge项目</a></p>

<p><a href="http://phonegap.com/">大名鼎鼎的phonegap</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]iOS7最佳实践：一个天气App案例(二)]]></title>
    <link href="http://sjpsega.com/blog/2014/02/15/yi--ios-7-best-practices-part-2/"/>
    <updated>2014-02-15T16:46:02+08:00</updated>
    <id>http://sjpsega.com/blog/2014/02/15/yi--ios-7-best-practices-part-2</id>
    <content type="html"><![CDATA[<p>注：本文译自：<a href="http://www.raywenderlich.com/55385/ios-7-best-practices-part-2">raywenderlich ios-7-best-practices-part-2</a>，去除了跟主题无关的寒暄部分。
欢迎转载，保持署名</p>

<h2>开始</h2>

<p>你有两个选择开始本教程：您可以使用在本教程的第1部分你已完成的项目，或者你可以在这里下载<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/SimpleWeather-Part-1.zip">第1部分已完成的项目</a>。</p>

<p>在前面的教程中你创建了你的App的天气模型 &ndash; 现在你需要使用OpenWeatherMap API为你的App来获取一些数据。你将使用两个类抽象数据抓取、分析、存储：<code>WXClient</code>和<code>WXManager</code>。</p>

<p><code>WXClient</code>的唯一责任是创建API请求，并解析它们；别人可以不用担心用数据做什么以及如何存储它。划分类的不同工作职责的设计模式被称为关注点分离。这使你的代码更容易理解，扩展和维护。</p>

<h2>与ReactiveCocoa工作</h2>

<p>确保你使用<code>SimpleWeather.xcworkspace</code>,打开<code>WXClient.h</code>并增加imports</p>

<p>```objc
@import CoreLocation;</p>

<h1>import &lt;ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h></h1>

<p>```</p>

<p><code>
注意：您可能之前没有见过的@import指令，它在Xcode5中被引入，是由苹果公司看作是一个现代的，更高效的替代 #import。有一个非常好的教程，涵盖了最新的Objective-C特性-[What’s New in Objective-C and Foundation in iOS 7](http://www.raywenderlich.com/49850/whats-new-in-objective-c-and-foundation-in-ios-7)。
</code></p>

<p>在<code>WXClient.h</code>中添加下列四个方法到接口申明：</p>

<p><code>objc
@import Foundation;
- (RACSignal *)fetchJSONFromURL:(NSURL *)url;
- (RACSignal *)fetchCurrentConditionsForLocation:(CLLocationCoordinate2D)coordinate;
- (RACSignal *)fetchHourlyForecastForLocation:(CLLocationCoordinate2D)coordinate;
- (RACSignal *)fetchDailyForecastForLocation:(CLLocationCoordinate2D)coordinate;
</code></p>

<p>现在，似乎是一个很好的机会来介绍<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>！</p>

<p>ReactiveCocoa（RAC）是一个Objective-C的框架，用于函数式反应型编程，它提供了组合和转化数据流的API。代替专注于编写串行的代码 &ndash; 执行有序的代码队列 &ndash; 可以响应非确定性事件。</p>

<p>Github上提供的<a href="https://github.com/blog/1107-reactivecocoa-for-a-better-world">a great overview of the benefits</a>：</p>

<ul>
<li>对未来数据的进行组合操作的能力。</li>
<li>减少状态和可变性。</li>
<li>用声明的形式来定义行为和属性之间的关系。</li>
<li>为异步操作带来一个统一的，高层次的接口。</li>
<li>在KVO的基础上建立一个优雅的API。</li>
</ul>


<p>例如，你可以监听<code>username</code>属性的变化，用这样的代码:</p>

<p>```objc
[RACAble(self.username) subscribeNext:^(NSString *newName) {</p>

<pre><code>NSLog(@"%@", newName);
</code></pre>

<p>}];
```</p>

<p><code>subscribeNext</code>这个block会在<code>self.username</code>属性变化的时候执行。新的值会传递给这个block。</p>

<p>您还可以合并信号并组合数据到一个组合数据中。下面的示例取自于ReactiveCocoa的Github页面：</p>

<p>```objc
[[RACSignal</p>

<pre><code>combineLatest:@[ RACAble(self.password), RACAble(self.passwordConfirmation) ] 
       reduce:^(NSString *currentPassword, NSString *currentConfirmPassword) {
           return [NSNumber numberWithBool:[currentConfirmPassword isEqualToString:currentPassword]];
       }] 
subscribeNext:^(NSNumber *passwordsMatch) {
    self.createEnabled = [passwordsMatch boolValue];
}];
</code></pre>

<p>```</p>

<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACSignal.h">RACSignal</a>对象捕捉当前和未来的值。信号可以被观察者链接，组合和反应。信号实际上不会执行，直到它被订阅。</p>

<p>这意味着调用<code>[mySignal fetchCurrentConditionsForLocation：someLocation];</code>不会做什么，但创建并返回一个信号。你将看到之后如何订阅和反应。</p>

<p>打开<code>WXClient.m</code>加入以下imports:</p>

<p>```objc</p>

<h1>import &ldquo;WXCondition.h&rdquo;</h1>

<h1>import &ldquo;WXDailyForecast.h&rdquo;</h1>

<p>```</p>

<p>在imports下，添加私有接口：</p>

<p>```objc
@interface WXClient ()</p>

<p>@property (nonatomic, strong) NSURLSession *session;</p>

<p>@end
```</p>

<p>这个接口用这个属性来管理API请求的URL session。</p>

<p>添加以下<code>init</code>放到到<code>@implementation</code>和<code>@end</code>之间：</p>

<p>```objc
&ndash; (id)init {</p>

<pre><code>if (self = [super init]) {
    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];
    _session = [NSURLSession sessionWithConfiguration:config];
}
return self;
</code></pre>

<p>}
```</p>

<p>使用<code>defaultSessionConfiguration</code>为您创建session。</p>

<p><code>
注意：如果你以前没有了解过NSURLSession，看看我们的[NSURLSession教程](http://www.raywenderlich.com/51127/nsurlsession-tutorial)，了解更多信息。
</code></p>

<h2>构建信号</h2>

<p>你需要一个主方法来建立一个信号从URL中取数据。你已经知道，需要三种方法来获取当前状况，逐时预报及每日预报。</p>

<p>不是写三个独立的方法，你可以遵守<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>（Don’t Repeat Yourself）的软件设计理念，使您的代码容易维护。</p>

<p>第一次看，以下的一些ReactiveCocoa部分可能看起来相当陌生。别担心，你会一块一块理解他。</p>

<p>增加下列方法到<code>WXClient.m</code>:</p>

<p>```objc
&ndash; (RACSignal <em>)fetchJSONFromURL:(NSURL </em>)url {</p>

<pre><code>NSLog(@"Fetching: %@",url.absoluteString);

// 1
return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    // 2
    NSURLSessionDataTask *dataTask = [self.session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        // TODO: Handle retrieved data
    }];

    // 3
    [dataTask resume];

    // 4
    return [RACDisposable disposableWithBlock:^{
        [dataTask cancel];
    }];
}] doError:^(NSError *error) {
    // 5
    NSLog(@"%@",error);
}];
</code></pre>

<p>}
```</p>

<p>通过一个一个注释，你会看到代码执行以下操作：</p>

<ol>
<li>返回信号。请记住，这将不会执行，直到这个信号被订阅。 <code>- fetchJSONFromURL：</code>创建一个对象给其他方法和对象使用；这种行为有时也被称为<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassFactoryMethods/ClassFactoryMethods.html">工厂模式</a>。</li>
<li>创建一个<a href="https://developer.apple.com/library/IOS/documentation/Foundation/Reference/NSURLSessionDataTask_class/Reference/Reference.html">NSURLSessionDataTask</a>（在iOS7中加入）从URL取数据。你会在以后添加的数据解析。</li>
<li>一旦订阅了信号，启动网络请求。</li>
<li>创建并返回<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACDisposable.h">RACDisposable</a>对象，它处理当信号摧毁时的清理工作。</li>
<li>增加了一个“side effect”，以记录发生的任何错误。side effect不订阅信号，相反，他们返回被连接到方法链的信号。你只需添加一个side effect来记录错误。</li>
</ol>


<p><code>
如果你觉得需要更多一些背景知识，看看由Ash Furrow编写的[这篇文章](http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/)，以便更好地了解ReactiveCocoa的核心概念。
</code></p>

<p>在<code>-fetchJSONFromURL:</code>中找到<code>// TODO: Handle retrieved data</code> ，替换为:</p>

<p>```objc
if (! error) {</p>

<pre><code>NSError *jsonError = nil;
id json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;jsonError];
if (! jsonError) {
    // 1
    [subscriber sendNext:json];
}
else {
    // 2
    [subscriber sendError:jsonError];
}
</code></pre>

<p>}
else {</p>

<pre><code>// 2
[subscriber sendError:error];
</code></pre>

<p>}</p>

<p>// 3
[subscriber sendCompleted];
```</p>

<ol>
<li>当JSON数据存在并且没有错误，发送给订阅者序列化后的JSON数组或字典。</li>
<li>在任一情况下如果有一个错误，通知订阅者。</li>
<li>无论该请求成功还是失败，通知订阅者请求已经完成。</li>
</ol>


<p><code>-fetchJSONFromURL：</code>方法有点长，但它使你的特定的API请求方法变得很简单。</p>

<h2>获取当前状况</h2>

<p>还在<code>WXClient.m</code>中，添加如下方法：</p>

<p>```objc
&ndash; (RACSignal *)fetchCurrentConditionsForLocation:(CLLocationCoordinate2D)coordinate {</p>

<pre><code>// 1
NSString *urlString = [NSString stringWithFormat:@"http://api.openweathermap.org/data/2.5/weather?lat=%f&amp;lon=%f&amp;units=imperial",coordinate.latitude, coordinate.longitude];
NSURL *url = [NSURL URLWithString:urlString];

// 2
return [[self fetchJSONFromURL:url] map:^(NSDictionary *json) {
    // 3
    return [MTLJSONAdapter modelOfClass:[WXCondition class] fromJSONDictionary:json error:nil];
}];
</code></pre>

<p>}
```</p>

<ol>
<li>使用<code>CLLocationCoordinate2D</code>对象的经纬度数据来格式化URL。</li>
<li>用你刚刚建立的创建信号的方法。由于返回值是一个信号，你可以调用其他ReactiveCocoa的方法。 在这里，您将返回值映射到一个不同的值 &ndash; 一个NSDictionary实例。</li>
<li>使用<code>MTLJSONAdapter</code>来转换JSON到<code>WXCondition</code>对象 &ndash; 使用<code>MTLJSONSerializing</code>协议创建的<code>WXCondition</code>。</li>
</ol>


<h2>获取逐时预报</h2>

<p>现在添加根据坐标获取逐时预报的方法到<code>WXClient.m</code>:</p>

<p>```objc
&ndash; (RACSignal *)fetchHourlyForecastForLocation:(CLLocationCoordinate2D)coordinate {</p>

<pre><code>NSString *urlString = [NSString stringWithFormat:@"http://api.openweathermap.org/data/2.5/forecast?lat=%f&amp;lon=%f&amp;units=imperial&amp;cnt=12",coordinate.latitude, coordinate.longitude];
NSURL *url = [NSURL URLWithString:urlString];

// 1
return [[self fetchJSONFromURL:url] map:^(NSDictionary *json) {
    // 2
    RACSequence *list = [json[@"list"] rac_sequence];

    // 3
    return [[list map:^(NSDictionary *item) {
        // 4
        return [MTLJSONAdapter modelOfClass:[WXCondition class] fromJSONDictionary:item error:nil];
    // 5
    }] array];
}];
</code></pre>

<p>}
```</p>

<ol>
<li>再次使用<code>-fetchJSONFromUR</code>方法，映射JSON。注意：重复使用该方法节省了多少代码！</li>
<li>使用JSON的"list"key创建<code>RACSequence</code>。 <code>RACSequences</code>让你对列表进行ReactiveCocoa操作。</li>
<li>映射新的对象列表。调用<code>-map：</code>方法，针对列表中的每个对象，返回新对象的列表。</li>
<li>再次使用<code>MTLJSONAdapter</code>来转换JSON到<code>WXCondition</code>对象。</li>
<li>使用<code>RACSequence</code>的<code>-map</code>方法，返回另一个<code>RACSequence</code>，所以用这个简便的方法来获得一个<code>NSArray</code>数据。</li>
</ol>


<h2>获取每日预报</h2>

<p>最后，添加如下方法到<code>WXClient.m</code>:</p>

<p>```objc
&ndash; (RACSignal *)fetchDailyForecastForLocation:(CLLocationCoordinate2D)coordinate {</p>

<pre><code>NSString *urlString = [NSString stringWithFormat:@"http://api.openweathermap.org/data/2.5/forecast/daily?lat=%f&amp;lon=%f&amp;units=imperial&amp;cnt=7",coordinate.latitude, coordinate.longitude];
NSURL *url = [NSURL URLWithString:urlString];

// Use the generic fetch method and map results to convert into an array of Mantle objects
return [[self fetchJSONFromURL:url] map:^(NSDictionary *json) {
    // Build a sequence from the list of raw JSON
    RACSequence *list = [json[@"list"] rac_sequence];

    // Use a function to map results from JSON to Mantle objects
    return [[list map:^(NSDictionary *item) {
        return [MTLJSONAdapter modelOfClass:[WXDailyForecast class] fromJSONDictionary:item error:nil];
    }] array];
}];
</code></pre>

<p>}
```</p>

<p>是不是看起来很熟悉？是的，这个方法与<code>-fetchHourlyForecastForLocation:</code>方法非常像。除了它使用<code>WXDailyForecast</code>代替<code>WXCondition</code>，并获取每日预报。</p>

<p>构建并运行您的App，现在你不会看到任何新的东西，但这是一个很好机会松一口气，并确保没有任何错误或警告。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/built-layout.jpg" width="320" alt="Labels and Views" /></p>

<h2>管理并存储你的数据</h2>

<p>现在是时间来充实<code>WXManager</code>，这个类会把所有东西结合到一起。这个类实现您App的一些关键功能：</p>

<ul>
<li>它使用<a href="http://www.raywenderlich.com/46988/ios-design-patterns">单例设计模式</a>。</li>
<li>它试图找到设备的位置。</li>
<li>找到位置后，它获取相应的气象数据。</li>
</ul>


<p>打开<code>WXManager.h</code>使用以下代码来替换其内容：</p>

<p>```objc
@import Foundation;
@import CoreLocation;</p>

<h1>import &lt;ReactiveCocoa/ReactiveCocoa/ReactiveCocoa.h></h1>

<p>// 1</p>

<h1>import &ldquo;WXCondition.h&rdquo;</h1>

<p>@interface WXManager : NSObject
<CLLocationManagerDelegate></p>

<p>// 2
+ (instancetype)sharedManager;</p>

<p>// 3
@property (nonatomic, strong, readonly) CLLocation <em>currentLocation;
@property (nonatomic, strong, readonly) WXCondition </em>currentCondition;
@property (nonatomic, strong, readonly) NSArray <em>hourlyForecast;
@property (nonatomic, strong, readonly) NSArray </em>dailyForecast;</p>

<p>// 4
&ndash; (void)findCurrentLocation;</p>

<p>@end
```</p>

<ol>
<li>请注意，你没有引入<code>WXDailyForecast.h</code>，你会始终使用<code>WXCondition</code>作为预报的类。 <code>WXDailyForecast</code>的存在是为了帮助Mantle转换JSON到Objective-C。</li>
<li>使用<code>instancetype</code>而不是<code>WXManager</code>，子类将返回适当的类型。</li>
<li>这些属性将存储您的数据。由于<code>WXManager</code>是一个单例，这些属性可以任意访问。设置公共属性为只读，因为只有管理者能更改这些值。</li>
<li>这个方法启动或刷新整个位置和天气的查找过程。</li>
</ol>


<p>现在打开<code>WXManager.m</code>并添加如下imports到文件顶部：</p>

<pre><code>#import "WXClient.h"
#import &lt;TSMessages/TSMessage.h&gt;
</code></pre>

<p>在imports下方，粘贴如下私有接口：</p>

<p>```objc
@interface WXManager ()</p>

<p>// 1
@property (nonatomic, strong, readwrite) WXCondition <em>currentCondition;
@property (nonatomic, strong, readwrite) CLLocation </em>currentLocation;
@property (nonatomic, strong, readwrite) NSArray <em>hourlyForecast;
@property (nonatomic, strong, readwrite) NSArray </em>dailyForecast;</p>

<p>// 2
@property (nonatomic, strong) CLLocationManager <em>locationManager;
@property (nonatomic, assign) BOOL isFirstUpdate;
@property (nonatomic, strong) WXClient </em>client;</p>

<p>@end
```</p>

<ol>
<li>声明你在公共接口中添加的相同的属性，但是这一次把他们定义为<code>可读写</code>，因此您可以在后台更改他们。</li>
<li>为查找定位和数据抓取声明一些私有变量。</li>
</ol>


<p>添加如下通用的单例构造器到<code>@implementation</code>与<code>@end</code>å中间：</p>

<p>```objc
+ (instancetype)sharedManager {</p>

<pre><code>static id _sharedManager = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    _sharedManager = [[self alloc] init];
});

return _sharedManager;
</code></pre>

<p>}
```</p>

<p>然后，你需要设置你的属性和观察者。</p>

<p>添加如下方法到<code>WXManager.m</code>:</p>

<p>```objc
&ndash; (id)init {</p>

<pre><code>if (self = [super init]) {
    // 1
    _locationManager = [[CLLocationManager alloc] init];
    _locationManager.delegate = self;

    // 2
    _client = [[WXClient alloc] init];

    // 3
    [[[[RACObserve(self, currentLocation)
        // 4
        ignore:nil]
        // 5
       // Flatten and subscribe to all 3 signals when currentLocation updates
       flattenMap:^(CLLocation *newLocation) {
           return [RACSignal merge:@[
                                     [self updateCurrentConditions],
                                     [self updateDailyForecast],
                                     [self updateHourlyForecast]
                                     ]];
        // 6
       }] deliverOn:RACScheduler.mainThreadScheduler]
       // 7
     subscribeError:^(NSError *error) {
         [TSMessage showNotificationWithTitle:@"Error" 
                                     subtitle:@"There was a problem fetching the latest weather."
                                         type:TSMessageNotificationTypeError];
     }];
}
return self;
</code></pre>

<p>}
```</p>

<p>你正使用更多的ReactiveCocoa方法来观察和反应数值的变化。上面这些你做了：</p>

<ol>
<li>创建一个位置管理器，并设置它的delegate为<code>self</code>。</li>
<li>为管理器创建<code>WXClient</code>对象。这里处理所有的网络请求和数据分析，这是关注点分离的最佳实践。</li>
<li>管理器使用一个返回信号的ReactiveCocoa脚本来观察自身的<code>currentLocation</code>。这与<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">KVO</a>类似，但更为强大。</li>
<li>为了继续执行方法链，<code>currentLocation</code>必须不为<code>nil</code>。</li>
<li><code>- flattenMap：</code>非常类似于<code>-map：</code>，但不是映射每一个值，它把数据变得扁平，并返回包含三个信号中的一个对象。通过这种方式，你可以考虑将三个进程作为单个工作单元。</li>
<li>将信号传递给主线程上的观察者。</li>
<li>这不是很好的做法，在你的模型中进行UI交互，但出于演示的目的，每当发生错误时，会显示一个banner。</li>
</ol>


<p>接下来，为了显示准确的天气预报，我们需要确定设备的位置。</p>

<h2>查找你的位置</h2>

<p>下一步，你要添加当位置查找到，触发抓取天气数据的代码。</p>

<p>添加如下代码到<code>WXManager.m</code>的实现块中:</p>

<p>```objc
&ndash; (void)findCurrentLocation {</p>

<pre><code>self.isFirstUpdate = YES;
[self.locationManager startUpdatingLocation];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations {
  // 1
  if (self.isFirstUpdate) {
      self.isFirstUpdate = NO;
      return;
  }</p>

<p>  CLLocation *location = [locations lastObject];</p>

<p>  // 2
  if (location.horizontalAccuracy > 0) {
      // 3
      self.currentLocation = location;
      [self.locationManager stopUpdatingLocation];
  }
}
```</p></li>
<li><p>忽略第一个位置更新，因为它一般是缓存值。</p></li>
<li>一旦你获得一定精度的位置，停止进一步的更新。</li>
<li>设置<code>currentLocation</code>，将触发您之前在init中设置的RACObservable。</li>
</ul>


<h2>获取气象数据</h2>

<p>最后，是时候添加在客户端上调用并保存数据的三个获取方法。将三个方法捆绑起来，被之前在<code>init</code>方法中添加的RACObservable订阅。您将返回客户端返回的，能被订阅的，相同的信号。</p>

<p>所有的属性设置发生在<code>-doNext:</code>中。</p>

<p>添加如下代码到<code>WXManager.m</code>:</p>

<p>```objc
&ndash; (RACSignal *)updateCurrentConditions {</p>

<pre><code>return [[self.client fetchCurrentConditionsForLocation:self.currentLocation.coordinate] doNext:^(WXCondition *condition) {
    self.currentCondition = condition;
}];
</code></pre>

<p>}</p>

<ul>
<li><p>(RACSignal <em>)updateHourlyForecast {
  return [[self.client fetchHourlyForecastForLocation:self.currentLocation.coordinate] doNext:^(NSArray </em>conditions) {
      self.hourlyForecast = conditions;
  }];
}</p></li>
<li><p>(RACSignal <em>)updateDailyForecast {
  return [[self.client fetchDailyForecastForLocation:self.currentLocation.coordinate] doNext:^(NSArray </em>conditions) {
      self.dailyForecast = conditions;
  }];
}
```</p></li>
</ul>


<p>它看起来像将一切都连接起来，并蓄势待发。别急！这App实际上并没有告诉管理者做任何事情。
打开<code>WXController.m</code>并导入这管理者到文件的顶部，如下所示：</p>

<p>```objc</p>

<h1>import &ldquo;WXManager.h&rdquo;</h1>

<p>```</p>

<p>添加如下代码到<code>-viewDidLoad:</code>的最后:</p>

<p><code>objc
[[WXManager sharedManager] findCurrentLocation];
</code></p>

<p>这告诉管理类，开始寻找设备的当前位置。</p>

<p>构建并运行您的App，系统会提示您是否允许使用位置服务。你仍然不会看到任何UI的更新，但检查控制台日志，你会看到类似以下内容：</p>

<p><code>
2013-11-05 08:38:48.886 WeatherTutorial[17097:70b] Fetching: http://api.openweathermap.org/data/2.5/weather?lat=37.785834&amp;lon=-122.406417&amp;units=imperial
2013-11-05 08:38:48.886 WeatherTutorial[17097:70b] Fetching: http://api.openweathermap.org/data/2.5/forecast/daily?lat=37.785834&amp;lon=-122.406417&amp;units=imperial&amp;cnt=7
2013-11-05 08:38:48.886 WeatherTutorial[17097:70b] Fetching: http://api.openweathermap.org/data/2.5/forecast?lat=37.785834&amp;lon=-122.406417&amp;units=imperial&amp;cnt=12
</code></p>

<p>这些输出代表你的代码工作正常，网络请求正常执行。</p>

<h2>连接接口</h2>

<p>这是最后一次展示所有获取，映射和存储的数据。您将使用ReactiveCocoa来观察<code>WXManager</code>单例的变化和当新数据到达时更新界面。</p>

<p>还在<code>WXController.m</code>，到<code>- viewDidLoad</code>的底部，并添加下面的代码到<code>[[WXManager sharedManager] findCurrentLocation];</code>之前：</p>

<p>```objc
// 1
[[RACObserve([WXManager sharedManager], currentCondition)
  // 2
  deliverOn:RACScheduler.mainThreadScheduler]
 subscribeNext:^(WXCondition *newCondition) {</p>

<pre><code> // 3
 temperatureLabel.text = [NSString stringWithFormat:@"%.0f°",newCondition.temperature.floatValue];
 conditionsLabel.text = [newCondition.condition capitalizedString];
 cityLabel.text = [newCondition.locationName capitalizedString];

 // 4
 iconView.image = [UIImage imageNamed:[newCondition imageName]];
</code></pre>

<p> }];
```</p>

<ol>
<li>观察<code>WXManager</code>单例的currentCondition。</li>
<li>传递在主线程上的任何变化，因为你正在更新UI。</li>
<li>使用气象数据更新文本标签；你为文本标签使用<code>newCondition</code>的数据，而不是单例。订阅者的参数保证是最新值。</li>
<li>使用映射的图像文件名来创建一个图像，并将其设置为视图的图标。</li>
</ol>


<p>构建并运行您的App，你会看到当前温度，当前状况和表示当前状况的图标。所有的数据都是实时的。但是，如果你的位置是旧金山，它似乎总是约65度。Lucky San Franciscans! :]</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/11/ui-wiring.jpg" width="320" alt="Wiring up the UI" /></p>

<h2>ReactiveCocoa的绑定</h2>

<p>ReactiveCocoa为iOS带来了自己的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CocoaBindings/CocoaBindings.html">Cocoa绑定</a>的形式。</p>

<p>不知道是什么绑定？简而言之，他们是一种提供了保持模型和视图的数据同步而无需编写大量"胶水代码"的手段，它们允许你建立一个视图和数据块之间的连接， “结合”它们，使得一方的变化反映到另一个中的技术。</p>

<p>这是一个非常强大的概念，不是吗？</p>

<p><code>
注意：要获得更多的绑定实例代码，请查看[ReactiveCocoa Readme](https://github.com/ReactiveCocoa/ReactiveCocoa)。
</code></p>

<p>添加如下代码到你上一步添加的代码后面：</p>

<p>```objc
// 1
RAC(hiloLabel, text) = [[RACSignal combineLatest:@[</p>

<pre><code>                    // 2
                    RACObserve([WXManager sharedManager], currentCondition.tempHigh),
                    RACObserve([WXManager sharedManager], currentCondition.tempLow)]
                    // 3
                    reduce:^(NSNumber *hi, NSNumber *low) {
                        return [NSString  stringWithFormat:@"%.0f° / %.0f°",hi.floatValue,low.floatValue];
                    }]
                    // 4
                    deliverOn:RACScheduler.mainThreadScheduler];
</code></pre>

<p>```</p>

<p>上面的代码结合高温、低温的值到hiloLabel的text属性。看看你完成了什么：</p>

<ol>
<li>RAC（&hellip;）宏有助于保持语法整洁。从该信号的返回值将被分配给<code>hiloLabel</code>对象的<code>text</code>。</li>
<li>观察<code>currentCondition</code>的高温和低温。合并信号，并使用两者最新的值。当任一数据变化时，信号就会触发。</li>
<li>从合并的信号中，减少数值，转换成一个单一的数据，注意参数的顺序与信号的顺序相匹配。</li>
<li>同样，因为你正在处理UI界面，所以把所有东西都传递到主线程。</li>
</ol>


<p>构建并运行你的App。你应该看到在左下方的高/低温度label更新了：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/11/ui-wiring-hilo.jpg" width="320" alt="UI Wiring with Bindings" /></p>

<h2>在Table View中显示数据</h2>

<p>现在，你已经获取所有的数据，你可以在table view中整齐地显示出来。你会在分页的table view中显示最近6小时的每时播报和每日预报。该App会显示三个页面：一个是当前状况，一个是逐时预报，以及一个每日预报。</p>

<p>之前，你可以添加单元格到table view，你需要初始化和配置一些日期格式化。</p>

<p>到<code>WXController.m</code>最顶端的私有接口处，添加下列两个属性</p>

<p><code>objc
@property (nonatomic, strong) NSDateFormatter *hourlyFormatter;
@property (nonatomic, strong) NSDateFormatter *dailyFormatter;
</code></p>

<p>由于创建日期格式化非常昂贵，我们将在init方法中实例化他们，并使用这些变量去存储他们的引用。</p>

<p>还在<code>WXController.m</code>中，添加如下代码到<code>@implementation</code>中：</p>

<p>```objc
&ndash; (id)init {</p>

<pre><code>if (self = [super init]) {
    _hourlyFormatter = [[NSDateFormatter alloc] init];
    _hourlyFormatter.dateFormat = @"h a";

    _dailyFormatter = [[NSDateFormatter alloc] init];
    _dailyFormatter.dateFormat = @"EEEE";
}
return self;
</code></pre>

<p>}
```</p>

<p>你可能想知道为什么在<code>-init</code>中初始化这些日期格式化，而不是在<code>-viewDidLoad</code>中初始化他们。好问题！</p>

<p>实际上<code>-viewDidLoad</code>可以在一个视图控制器的生命周期中多次调用。 <a href="http://www.rsaunders.co.uk/2012/02/nsdateformatter-are-expensive.html">NSDateFormatter对象的初始化是昂贵的</a>，而将它们放置在你的<code>-init</code>，会确保被你的视图控制器初始化一次。</p>

<p>在<code>WXController.m</code>中，寻找<code>tableView:numberOfRowsInSection：</code>,并用如下代码更换<code>TODO</code>到<code>return</code>：</p>

<p>```objc
// 1
if (section == 0) {</p>

<pre><code>return MIN([[WXManager sharedManager].hourlyForecast count], 6) + 1;
</code></pre>

<p>}
// 2
return MIN([[WXManager sharedManager].dailyForecast count], 6) + 1;
```</p>

<ol>
<li>第一部分是对的逐时预报。使用最近6小时的预预报，并添加了一个作为页眉的单元格。</li>
<li>接下来的部分是每日预报。使用最近6天的每日预报，并添加了一个作为页眉的单元格。</li>
</ol>


<p><code>
注意：您使用表格单元格作为标题，而不是内置的、具有粘性的滚动行为的标题。这个table view设置了分页，粘性滚动行为看起来会很奇怪。
</code></p>

<p>在<code>WXController.m</code>找到<code>tableView:cellForRowAtIndexPath:</code>,并用如下代码更换<code>TODO</code>：</p>

<p>```objc
if (indexPath.section == 0) {</p>

<pre><code>// 1
if (indexPath.row == 0) {
    [self configureHeaderCell:cell title:@"Hourly Forecast"];
}
else {
    // 2
    WXCondition *weather = [WXManager sharedManager].hourlyForecast[indexPath.row - 1];
    [self configureHourlyCell:cell weather:weather];
}
</code></pre>

<p>}
else if (indexPath.section == 1) {</p>

<pre><code>// 1
if (indexPath.row == 0) {
    [self configureHeaderCell:cell title:@"Daily Forecast"];
}
else {
    // 3
    WXCondition *weather = [WXManager sharedManager].dailyForecast[indexPath.row - 1];
    [self configureDailyCell:cell weather:weather];
}
</code></pre>

<p>}
```</p>

<ol>
<li>每个部分的第一行是标题单元格。</li>
<li>获取每小时的天气和使用自定义配置方法配置cell。</li>
<li>获取每天的天气，并使用另一个自定义配置方法配置cell。</li>
</ol>


<p>最后，添加如下代码到<code>WXController.m</code>:</p>

<p>```objc
// 1
&ndash; (void)configureHeaderCell:(UITableViewCell <em>)cell title:(NSString </em>)title {</p>

<pre><code>cell.textLabel.font = [UIFont fontWithName:@"HelveticaNeue-Medium" size:18];
cell.textLabel.text = title;
cell.detailTextLabel.text = @"";
cell.imageView.image = nil;
</code></pre>

<p>}</p>

<p>// 2
&ndash; (void)configureHourlyCell:(UITableViewCell <em>)cell weather:(WXCondition </em>)weather {</p>

<pre><code>cell.textLabel.font = [UIFont fontWithName:@"HelveticaNeue-Light" size:18];
cell.detailTextLabel.font = [UIFont fontWithName:@"HelveticaNeue-Medium" size:18];
cell.textLabel.text = [self.hourlyFormatter stringFromDate:weather.date];
cell.detailTextLabel.text = [NSString stringWithFormat:@"%.0f°",weather.temperature.floatValue];
cell.imageView.image = [UIImage imageNamed:[weather imageName]];
cell.imageView.contentMode = UIViewContentModeScaleAspectFit;
</code></pre>

<p>}</p>

<p>// 3
&ndash; (void)configureDailyCell:(UITableViewCell <em>)cell weather:(WXCondition </em>)weather {</p>

<pre><code>cell.textLabel.font = [UIFont fontWithName:@"HelveticaNeue-Light" size:18];
cell.detailTextLabel.font = [UIFont fontWithName:@"HelveticaNeue-Medium" size:18];
cell.textLabel.text = [self.dailyFormatter stringFromDate:weather.date];
cell.detailTextLabel.text = [NSString stringWithFormat:@"%.0f° / %.0f°",
                              weather.tempHigh.floatValue,
                              weather.tempLow.floatValue];
cell.imageView.image = [UIImage imageNamed:[weather imageName]];
cell.imageView.contentMode = UIViewContentModeScaleAspectFit;
</code></pre>

<p>}
```</p>

<ol>
<li>配置和添加文本到作为section页眉单元格。你会重用此为每日每时的预测部分。</li>
<li>格式化逐时预报的单元格。</li>
<li>格式化每日预报的单元格。</li>
</ol>


<p>构建并运行您的App，尝试滚动你的table view，并&hellip;等一下。什么都没显示！怎么办？</p>

<p>如果你已经使用过的<code>UITableView</code>，可能你之前遇到过问题。这个table没有重新加载！</p>

<p>为了解决这个问题，你需要添加另一个针对每时预报和每日预报属性的ReactiveCocoa观察。</p>

<p>在<code>WXController.m</code>的<code>-viewDidLoad</code>中，添加下列代码到其他ReactiveCocoa观察代码中：</p>

<p>```objc
[[RACObserve([WXManager sharedManager], hourlyForecast)</p>

<pre><code>   deliverOn:RACScheduler.mainThreadScheduler]
</code></pre>

<p>   subscribeNext:^(NSArray *newForecast) {</p>

<pre><code>   [self.tableView reloadData];
</code></pre>

<p>   }];</p>

<p>[[RACObserve([WXManager sharedManager], dailyForecast)</p>

<pre><code>   deliverOn:RACScheduler.mainThreadScheduler]
</code></pre>

<p>   subscribeNext:^(NSArray *newForecast) {</p>

<pre><code>   [self.tableView reloadData];
</code></pre>

<p>   }];
```</p>

<p>构建并运行App；滚动table view，你将看到填充的所有预报数据。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/unaligned-heights.jpg" width="320" alt="Forecast with Odd Heights" /></p>

<h2>给你的App添加效果</h2>

<p>本页面为每时和每日预报不会占满整个屏幕。幸运的是，有一个非常简单的修复办法。在本教程前期，您在<code>-viewDidLoad</code>中获得屏幕高度。</p>

<p>在<code>WXController.m</code>中，查找table view的委托方法<code>-tableView:heightForRowAtIndexPath:</code>，并且替换<code>TODO</code>到<code>return</code>的代码:</p>

<p><code>objc
NSInteger cellCount = [self tableView:tableView numberOfRowsInSection:indexPath.section];
return self.screenHeight / (CGFloat)cellCount;
</code></p>

<p>屏幕高度由一定数量的cell所分割，所以所有cell的总高度等于屏幕的高度。</p>

<p>构建并运行你的App；table view填满了整个屏幕，如下所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/11/aligned-heights.jpg" width="320" alt="Forecast with Full Height" /></p>

<p>最后要做的是把我在本教程的第一部分开头提到的模糊效果引入。当你滚动预报页面，模糊效果应该动态显示。</p>

<p>添加下列scroll delegate到<code>WXController.m</code>最底部：</p>

<p>```objc</p>

<h1>pragma mark &ndash; UIScrollViewDelegate</h1>

<ul>
<li><p>(void)scrollViewDidScroll:(UIScrollView *)scrollView {
  // 1
  CGFloat height = scrollView.bounds.size.height;
  CGFloat position = MAX(scrollView.contentOffset.y, 0.0);
  // 2
  CGFloat percent = MIN(position / height, 1.0);
  // 3
  self.blurredImageView.alpha = percent;
}
```</p></li>
<li><p>获取滚动视图的高度和内容偏移量。与0偏移量做比较，因此试图滚动table低于初始位置将不会影响模糊效果。</p></li>
<li>偏移量除以高度，并且最大值为1，所以alpha上限为1。</li>
<li>当你滚动的时候，把结果值赋给模糊图像的alpha属性，来更改模糊图像。</li>
</ul>


<p>构建并运行App，滚动你的table view，并查看这令人惊异的模糊效果：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/11/with-blur.jpg" width="320" alt="Finished Product" /></p>

<h2>何去何从？</h2>

<p>在本教程中你已经完成了很多内容：您使用CocoaPods创建了一个项目，完全用代码书写了一个视图结构，创建数据模型和管理类，并使用函数式编程将他们连接到一起！</p>

<p>您可以从<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/11/SimpleWeather-Part-2.zip">这里下载</a>该项目的完成版本。</p>

<p>这个App还有很多酷的东西可以去做。一个好的开始是使用<a href="http://www.flickr.com/services/api/">Flickr API</a>来查找基于设备位置的背景图像。</p>

<p>还有，你的应用程序只处理温度和状态;有什么其他的天气信息能融入你的App？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]iOS7最佳实践：一个天气App案例(一)]]></title>
    <link href="http://sjpsega.com/blog/2014/02/11/yi--ios-7-best-practices-part-1/"/>
    <updated>2014-02-11T22:21:53+08:00</updated>
    <id>http://sjpsega.com/blog/2014/02/11/yi--ios-7-best-practices-part-1</id>
    <content type="html"><![CDATA[<p>注：本文译自：<a href="http://www.raywenderlich.com/55384/ios-7-best-practices-part-1">raywenderlich ios-7-best-practices-part-1</a>，去除了跟主题无关的寒暄部分。
欢迎转载，保持署名</p>

<p>在这个两部分的系列教程中，您将探索如何使用以下工具和技术来创建自己的App：</p>

<ul>
<li><a href="http://cocoapods.org/">Cocoapods</a></li>
<li>Manual layout in code(纯代码布局)</li>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a></li>
<li><a href="http://openweathermap.org/">OpenWeatherMap</a></li>
</ul>


<p>本教程专为熟悉基本知识的、但还没有接触到太多高级主题的中级开发者而设计。本教程也是想要去探索Objective-C<a href="http://en.wikipedia.org/wiki/Functional_programming">函数编程</a>一个很好的开始。</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/11/weather3.gif" alt="Finished Weather App" /></p>

<h2>开始</h2>

<p>打开Xcode并执行<code>File\New\Project</code>。选择<code>Application\Empty Application</code>。将项目命名为<code>SimpleWeather</code>，单击下一步，选择一个目录去保存你的项目，然后点击Create。
现在，你的基础项目已经完成。下一步是集成你的第三方工具。但首先你要<code>关闭Xcode</code>，确保他不会影响下一步。</p>

<h3>Cocoapods</h3>

<p>你将要下载<a href="http://cocoapods.org/">Cocoapods</a>的代码，在Xcode项目中添加文件来使用，并配置项目需要的设置。</p>

<h3>Mantle</h3>

<p><a href="https://github.com/MantleFramework/Mantle">Mantle</a>是由于Github团队开发的，目的是去除Objective-C把JSON数据转为NSObject子类的所有样板代码。Mantle也能做数据转换，通过一种神奇的方式把JSON原始数据(strings, ints, floats)转换为复杂数据，比如NSDate, NSURL, 甚至是自定义类。</p>

<h3>LBBlurredImage</h3>

<p><a href="https://github.com/lukabernardi/LBBlurredImage">LBBlurredImage</a>是一个继承自UIImageView，轻而易举使图像模糊的项目。你将仅仅用一行代码来创建一个神奇的模糊效果。</p>

<h3>TSMessages</h3>

<p><a href="https://github.com/toursprung/TSMessages">TSMessages</a> 是另一个非常简单的库，用来显示浮层警告和通知。当出现错误信息而不直接影响用户的时候，最好使用浮层来代替模态窗口(例如UIAlertView)，这样你将尽可能减少对用户的影响。</p>

<p>你将只用TSMessages，在网络失去连接或API错误的时候。如果发生错误，你将看到类似这样的一个浮层：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/12/TSMessage.png" alt="TSMessages Error" /></p>

<h3>ReactiveCocoa</h3>

<p>最后，你将使用到<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>，他也来自于GitHub团队。ReactiveCocoa给Objective-C带来了函数编程，类似与.NET的<a href="http://msdn.microsoft.com/en-us/data/gg577609.aspx">Reactive Extensions</a>。你将在第二部分花费大部分时间去实现ReactiveCocoa。</p>

<h2>设置你的Cocoapods</h2>

<p>设置你的Cocoapods，先要确保你已经安装了Cocoapods。为此，打开命令行程序，并输入。</p>

<p><code>
which pod
</code></p>

<p>你将会看到类似这样的输出:</p>

<p><code>
/usr/bin/pod
</code></p>

<p>这决定于你如何管理Ruby gems，例如你使用<a href="http://rbenv.org/">rbenv</a>或<a href="http://rvm.io/">RVM</a>,路径可能有所不同。</p>

<p>如果命令行简单的返回提示，或显示<code>pod not found</code>，表示Cocoapods未安装在你的机器上。可以查看我们的<a href="http://www.raywenderlich.com/12139/introduction-to-cocoapods">Cocoapods教程</a>作为安装说明。这也是一个很好的资源，如果你想更多得了解Cocoapods的话。</p>

<p><code>
sjpsega注:Cocoapods中文安装教程可以看这篇 http://geeklu.com/2013/06/cocoapods-101/
</code></p>

<p><a href="http://guides.cocoapods.org/syntax/podfile.html">Podfiles</a>是用来告诉Cocoapods哪些开源项目需要导入。</p>

<p>要创建你的第一个Cocoapod，首先在命令行中用<code>cd</code>命令导航到你的XCode项目所在的文件夹，在命令行中启动编辑器，输入</p>

<p>```
platform :ios, &lsquo;7.0&rsquo;</p>

<p>pod &lsquo;Mantle&rsquo;
pod &lsquo;LBBlurredImage&rsquo;
pod &lsquo;TSMessages&rsquo;
pod &lsquo;ReactiveCocoa&rsquo;
```</p>

<p>这文件做了两件事情：</p>

<ul>
<li>告诉Cocoapods你的目标平台与版本，这里的你目标是iOS 7.0。</li>
<li>列给Cocoapods一个项目所有需要引入和安装的三方库清单。</li>
</ul>


<p>在命令行中输入<code>pod install</code>进行安装。</p>

<p>这可能需要花一到两分钟的时间去安装各种包。你的命令行应该输出如下所示:</p>

<p>```
$ pod install
Analyzing dependencies</p>

<p>CocoaPods 0.28.0 is available.</p>

<p>Downloading dependencies
Installing HexColors (2.2.1)
Installing LBBlurredImage (0.1.0)
Installing Mantle (1.3.1)</p>

<p>Installing ReactiveCocoa (2.1.7)
Installing TSMessages (0.9.4)
Generating Pods project
Integrating client project</p>

<p>[!] From now on use <code>SimpleWeather.xcworkspace</code>.
```</p>

<p><code>
sjpsega注:若你之前安装过Cocoapods的话，这里安装报错的话，可以看看http://blog.cocoapods.org/Repairing-Our-Broken-Specs-Repository/ 修复问题
</code></p>

<p>Cocoapods会在你的项目目录中创建一堆新文件，但是，只有一个需要你关心，<code>SimpleWeather.xcworkspace</code>。</p>

<p>用Xcode打开<code>SimpleWeather.xcworkspace</code>。看看你的项目设置，现在有一个Pods项目在你的项目工作区，以及在Pods文件夹放着每一个你引入的库，如下所示：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/12/SimpleWeather-Cocoapods.jpg" alt="Cocoapods Project" /></p>

<p>确保你已经选择SimpleWeather项目，如图所示：
<img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/12/SimpleWeather-Project.jpg" alt="Select SimpleWeather Project" /></p>

<p>构建并运行您的App，以确保一切工作正常：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/11/blank-app.jpg" width="320" alt="Blank App" /></p>

<p><code>
提示：您可能会注意到有一些项目生成警告。因为Cocoapods引入的项目，是由不同的开发者开发，并且不同的开发者对生成警告有不同的态度。通常，你应该可以忽略它们。只要确保没有任何编译器错误！
</code></p>

<h2>创建你的主视图控制器</h2>

<p>虽然这个App看起来复杂，但它还会通过一个单一的View Controller完成。现在，你将添加他。</p>

<p>选中<code>SimpleWeather</code>项目，单击<code>File\New\File</code>，并且选择<code>Cocoa Touch\Objective-C class</code>. 命名为<code>WXController</code>，并设置为<code>UIViewController</code>的子类。</p>

<p>确保<code>Targeted for iPad</code>和<code>With XIB for user interface</code>都没有选中，如下图所示：
<img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/11/create-controller.jpg" alt="Create WXController" /></p>

<p>打开<code>WXController.m</code>然后用如下所示替换<code>-viewDidLoad</code>方法：</p>

<p>```objc
&ndash; (void)viewDidLoad {</p>

<pre><code>[super viewDidLoad];

// Remove this later
self.view.backgroundColor = [UIColor redColor];
</code></pre>

<p>}
```</p>

<p>现在打开<code>AppDelegate.m</code>，并且引入如下两个class:</p>

<p>```objc</p>

<pre><code>#import "WXController.h"
#import &lt;TSMessage.h&gt;
</code></pre>

<p>```</p>

<p>眼尖的读者会注意到<code>WXController</code>使用引号引入，<code>TSMessage</code>使用单括号引入。</p>

<p>回头看下当你创建Podfile的时候，你使用Cocoapods引入<code>TSMessage</code>。Cocoapods创建TSMessage项目，并把它加入到工作空间。既然你从工作区的其他项目导入，可以使用尖括号代替引号。</p>

<p>代替<code>-application:didFinishLaunchingWithOptions</code>的内容：</p>

<p>```objc
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions {</p>

<pre><code>self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
// 1
self.window.rootViewController = [[WXController alloc] init];
self.window.backgroundColor = [UIColor whiteColor];
[self.window makeKeyAndVisible];
// 2
[TSMessage setDefaultViewController: self.window.rootViewController];
return YES;
</code></pre>

<p>}
```</p>

<p>标号注释的解释：</p>

<ol>
<li>初始化并设置<code>WXController</code>实例作为App的根视图控制器。通常这个控制器是一个的<code>UINavigationController</code>或<code>UITabBarController</code>，但在当前情况下，你使用<code>WXController</code>的单个实例。</li>
<li>设置默认的视图控制器来显示你的TSMessages。这样做，你将不再需要手动指定要使用的控制器来显示警告。</li>
</ol>


<p>构建并运行，看看你的新视图控制器起作用了。</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/11/wxcontroller-red.jpg" width="320" alt="WXController" /></p>

<p>在红色背景下，状态栏有点不够清晰。幸运的是，有一个简单的方法，使状态栏更清晰易读。</p>

<p>在iOS7，<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/Reference/Reference.html#//apple_ref/occ/instm/UIViewController/preferredStatusBarStyle">UIViewController</a>有一个新的API，用来控制状态栏的外观。打开<code>WXController</code>，直接添加下面的代码到<code>-viewDidLoad:</code>方法下：</p>

<p>```objc
&ndash; (UIStatusBarStyle)preferredStatusBarStyle {</p>

<pre><code>return UIStatusBarStyleLightContent;
</code></pre>

<p>}
```</p>

<p>再次构建并运行，你将看到状态栏如下的变化:</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/11/wxcontroller-red-status.jpg" width="320" alt="Create WXController with Light Status Bar" /></p>

<h2>设置你的App视图</h2>

<p>现在是时候让你的App接近生活。下载这个项目的<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2013/11/Images.zip">图片</a>，并解压缩到一个合适的位置。这个压缩包的背景图片出自Flickr用户<a href="http://www.flickr.com/photos/52547323@N00/5637648252">idleformat</a>之手，天气图片出自Dribbble用户<a href="http://dribbble.com/shots/1247177-Weather-icons?list=users">heeyeun</a>之手。</p>

<p>切换回Xcode，单击<code>File\Add Files to “SimpleWeather”</code>&hellip;.定位到你刚刚解压缩的图片文件夹并选择它。选择<code>Copy items into destination group’s folder (if needed)</code>，然后单击<code>Add</code>。</p>

<p>打开<code>WXController.h</code>, 添加如下委托协议：</p>

<p><code>objc
&lt;UITableViewDataSource, UITableViewDelegate, UIScrollViewDelegate&gt;
</code></p>

<p>现在打开<code>WXController.m</code>。 小提示：你可以使用<code>Control-Command-Up</code>的快捷键来实现<code>.h</code>和<code>.m</code>文件之间的快速切换。</p>

<p>添加如下代码到<code>WXController.m</code>顶部:</p>

<p>```objc</p>

<h1>import &lt;LBBlurredImage/UIImageView+LBBlurredImage.h></h1>

<p>```</p>

<p><code>LBBlurredImage.h</code>包含在Cocoapods引入的<code>LBBlurredImage</code>项目，你会使用这个库来模糊背景图片。</p>

<p>应该有一个空的私有接口样板在<code>WXController</code> imports的下方。它具有以下属性：</p>

<p>```objc
@interface WXController ()</p>

<p>@property (nonatomic, strong) UIImageView <em>backgroundImageView;
@property (nonatomic, strong) UIImageView </em>blurredImageView;
@property (nonatomic, strong) UITableView *tableView;
@property (nonatomic, assign) CGFloat screenHeight;</p>

<p>@end
```</p>

<p>现在，是时候在项目中创建并设置视图。</p>

<p>下面是你App的分解图，记住，table view将是透明的：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/11/screens.jpg" alt="Exploded Screens" /></p>

<p>为了实现动态模糊效果，在你的App中，你会根据App的滚动来改变模糊图像的alpha值。</p>

<p>打开<code>WXController.m</code>，使用如下代码来，替换掉<code>-viewDidLoad</code>中设置背景色的代码：</p>

<p>```objc
// 1
self.screenHeight = [UIScreen mainScreen].bounds.size.height;</p>

<p>UIImage *background = [UIImage imageNamed:@&ldquo;bg&rdquo;];</p>

<p>// 2
self.backgroundImageView = [[UIImageView alloc] initWithImage:background];
self.backgroundImageView.contentMode = UIViewContentModeScaleAspectFill;
[self.view addSubview:self.backgroundImageView];</p>

<p>// 3
self.blurredImageView = [[UIImageView alloc] init];
self.blurredImageView.contentMode = UIViewContentModeScaleAspectFill;
self.blurredImageView.alpha = 0;
[self.blurredImageView setImageToBlur:background blurRadius:10 completionBlock:nil];
[self.view addSubview:self.blurredImageView];</p>

<p>// 4
self.tableView = [[UITableView alloc] init];
self.tableView.backgroundColor = [UIColor clearColor];
self.tableView.delegate = self;
self.tableView.dataSource = self;
self.tableView.separatorColor = [UIColor colorWithWhite:1 alpha:0.2];
self.tableView.pagingEnabled = YES;
[self.view addSubview:self.tableView];
```</p>

<p>这是非常简单的代码：</p>

<ol>
<li>获取并存储屏幕高度。之后，你将在用分页的方式来显示所有天气​​数据时，使用它。</li>
<li>创建一个静态的背景图，并添加到视图上。</li>
<li>使用LBBlurredImage来创建一个模糊的背景图像，并设置alpha为0，使得开始<code>backgroundImageView</code>是可见的。</li>
<li>创建tableview来处理所有的数据呈现。 设置WXController为delegate和dataSource，以及滚动视图的delegate。请注意，设置<code>pagingEnabled</code>为<code>YES</code>。</li>
</ol>


<p>添加如下UITableView的delegate和dataSource的代码到<code>WXController.m</code>的<code>@implementation</code>块中：</p>

<p>```objc
// 1</p>

<h1>pragma mark &ndash; UITableViewDataSource</h1>

<p>// 2
&ndash; (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {</p>

<pre><code>return 2;
</code></pre>

<p>}</p>

<ul>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
  // TODO: Return count of forecast
  return 0;
}</p></li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath {
  static NSString </em>CellIdentifier = @&ldquo;CellIdentifier&rdquo;;
  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</p>

<p>  if (! cell) {
      cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:CellIdentifier];
  }</p>

<p>  // 3
  cell.selectionStyle = UITableViewCellSelectionStyleNone;
  cell.backgroundColor = [UIColor colorWithWhite:0 alpha:0.2];
  cell.textLabel.textColor = [UIColor whiteColor];
  cell.detailTextLabel.textColor = [UIColor whiteColor];</p>

<p>  // TODO: Setup the cell</p>

<p>  return cell;
}</p></li>
</ul>


<h1>pragma mark &ndash; UITableViewDelegate</h1>

<ul>
<li><p>(CGFloat)tableView:(UITableView <em>)tableView heightForRowAtIndexPath:(NSIndexPath </em>)indexPath {
  // TODO: Determine cell height based on screen
  return 44;
}
```</p></li>
<li><p><code>Pragma mark</code>是<a href="http://nshipster.com/pragma/">组织代码</a>的很好的一种方式。</p></li>
<li>你的table view有两个部分，一个是每小时的天气预报，另一个用于每日播报。table view的section数目，设置为2。</li>
<li>天气预报的cell是不可选择的。给他们一个半透明的黑色背景和白色文字。</li>
</ul>


<p><code>
注意：使用格式化的注释 // TODO：可以帮助Xcode找到需要以后完成的代码。你还可以使用 Show Document Items(Control-6)来查看TODO项。
</code></p>

<p>最后，添加如下代码到<code>WXController.m</code>:</p>

<p>```objc
&ndash; (void)viewWillLayoutSubviews {</p>

<pre><code>[super viewWillLayoutSubviews];

CGRect bounds = self.view.bounds;

self.backgroundImageView.frame = bounds;
self.blurredImageView.frame = bounds;
self.tableView.frame = bounds;
</code></pre>

<p>}
```</p>

<p>在<code>WXController.m</code>中，你的视图控制器调用该方法来编排其子视图。</p>

<p>构建并运行你的App，看看你的视图如何堆叠。</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/11/background.jpg" width="320" alt="Image Background" /></p>

<p>仔细看，你会看到所有空的table cell的cell分隔线。</p>

<p>仍然在<code>-viewDidLoad</code>中，添加下面的代码来设置你的布局框架和边距：</p>

<p>```objc
// 1
CGRect headerFrame = [UIScreen mainScreen].bounds;
// 2
CGFloat inset = 20;
// 3
CGFloat temperatureHeight = 110;
CGFloat hiloHeight = 40;
CGFloat iconHeight = 30;
// 4
CGRect hiloFrame = CGRectMake(inset,</p>

<pre><code>                          headerFrame.size.height - hiloHeight,
                          headerFrame.size.width - (2 * inset),
                          hiloHeight);
</code></pre>

<p>CGRect temperatureFrame = CGRectMake(inset,</p>

<pre><code>                                 headerFrame.size.height - (temperatureHeight + hiloHeight),
                                 headerFrame.size.width - (2 * inset),
                                 temperatureHeight);
</code></pre>

<p>CGRect iconFrame = CGRectMake(inset,</p>

<pre><code>                          temperatureFrame.origin.y - iconHeight, 
                          iconHeight, 
                          iconHeight);
</code></pre>

<p>// 5
CGRect conditionsFrame = iconFrame;
conditionsFrame.size.width = self.view.bounds.size.width &ndash; (((2 * inset) + iconHeight) + 10);
conditionsFrame.origin.x = iconFrame.origin.x + (iconHeight + 10);
```</p>

<p>这是相当常规设置代码，但这里是怎么回事：</p>

<ol>
<li>设置table的header大小与屏幕相同。你将利用的UITableView的分页来分隔页面页头和每日每时的天气预报部分。</li>
<li>创建inset（或padding）变量，以便您的所有标签均匀分布并居中。</li>
<li>创建并初始化为各种视图创建的高度变量。设置这些值作为常量，使得可以很容易地在需要的时候，配置和更改您的视图设置。</li>
<li>使用常量和inset变量，为label和view创建框架。</li>
<li>复制图标框，调整它，使文本具有一定的扩展空间，并将其移动到该图标的右侧。当我们把标签添加到视图，你会看到布局的效果。</li>
</ol>


<p>添加如下代码到<code>-viewDidLoad</code>：</p>

<p>```objc
// 1
UIView *header = [[UIView alloc] initWithFrame:headerFrame];
header.backgroundColor = [UIColor clearColor];
self.tableView.tableHeaderView = header;</p>

<p>// 2
// bottom left
UILabel *temperatureLabel = [[UILabel alloc] initWithFrame:temperatureFrame];
temperatureLabel.backgroundColor = [UIColor clearColor];
temperatureLabel.textColor = [UIColor whiteColor];
temperatureLabel.text = @&ldquo;0°&rdquo;;
temperatureLabel.font = [UIFont fontWithName:@&ldquo;HelveticaNeue-UltraLight&rdquo; size:120];
[header addSubview:temperatureLabel];</p>

<p>// bottom left
UILabel *hiloLabel = [[UILabel alloc] initWithFrame:hiloFrame];
hiloLabel.backgroundColor = [UIColor clearColor];
hiloLabel.textColor = [UIColor whiteColor];
hiloLabel.text = @&ldquo;0° / 0°&rdquo;;
hiloLabel.font = [UIFont fontWithName:@&ldquo;HelveticaNeue-Light&rdquo; size:28];
[header addSubview:hiloLabel];</p>

<p>// top
UILabel *cityLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 20, self.view.bounds.size.width, 30)];
cityLabel.backgroundColor = [UIColor clearColor];
cityLabel.textColor = [UIColor whiteColor];
cityLabel.text = @&ldquo;Loading&hellip;&rdquo;;
cityLabel.font = [UIFont fontWithName:@&ldquo;HelveticaNeue-Light&rdquo; size:18];
cityLabel.textAlignment = NSTextAlignmentCenter;
[header addSubview:cityLabel];</p>

<p>UILabel *conditionsLabel = [[UILabel alloc] initWithFrame:conditionsFrame];
conditionsLabel.backgroundColor = [UIColor clearColor];
conditionsLabel.font = [UIFont fontWithName:@&ldquo;HelveticaNeue-Light&rdquo; size:18];
conditionsLabel.textColor = [UIColor whiteColor];
[header addSubview:conditionsLabel];</p>

<p>// 3
// bottom left
UIImageView *iconView = [[UIImageView alloc] initWithFrame:iconFrame];
iconView.contentMode = UIViewContentModeScaleAspectFit;
iconView.backgroundColor = [UIColor clearColor];
[header addSubview:iconView];
```
这是相当长的一块代码，但它真的只是在做设置各种控件的繁重工作。简单的说：</p>

<ol>
<li>设置当前view为你的table header。</li>
<li>构建每一个显示气象数据的标签。</li>
<li>添加一个天气图标的图像视图。</li>
</ol>


<p>构建并运行你的App，你应该可以看到你之前布局的所有所有view。下面的屏幕截图显示了使用手工布局的、所有标签框在视觉上的显示。</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/12/built-layout.jpg" width="500" alt="Labels and Views" /></p>

<p>用手指轻轻推动table，当你滚动它的时候，应该会反弹。</p>

<h2>获取气象数据</h2>

<p>你会注意到，App显示“Loading&hellip;”，但它不是真正地在工作。是时候获取一些真正的天气数据。</p>

<p>你会从<a href="http://openweathermap.org/">OpenWeatherMap</a>的API拉取数据。 OpenWeatherMap是一个非常棒的服务，旨在提供实时，准确，免费的天气数据给任何人。虽然有很多天气API，但他们大多要么使用较旧的数据格式，如XML，或是有偿服务 &ndash; 并且有时还相当昂贵。</p>

<p>你会遵循以下基本步骤，来获你设备的位置的气象数据：</p>

<ol>
<li>找到设备的位置</li>
<li>从<a href="http://api.openweathermap.org/data/2.5/weather?lat=37.785834&amp;lon=-122.406417&amp;units=imperial">API端</a>下载JSON数据</li>
<li>映射JSON到<code>WXConditions</code>和<code>WXDailyForecasts</code></li>
<li>告诉UI有新数据了</li>
</ol>


<p>开始创建你的天气模型和数据管理类。单击<code>File\New\File…</code>并选择<code>Cocoa Touch\Objective-C class</code>。命名为<code>WXClient</code>并使其为<code>NSObject</code>的子类。</p>

<p>这样再做三次创建以下类：</p>

<ul>
<li><code>WXManager</code>作为<code>NSObject</code>的子类</li>
<li><code>WXCondition</code>作为<code>MTLModel</code>的子类</li>
<li><code>WXDailyForecast</code>作为<code>WXCondition</code>的子类</li>
</ul>


<p>全部完成？现在，你可以开始下一节，其中涉及映射和转换您的天气数据。</p>

<h2>创建你的天气模型</h2>

<p>你的模型将使用<a href="https://github.com/github/Mantle">Mantle</a>，这使得数据映射和转型非常简单。</p>

<p>打开<code>WXCondition.h</code>如下列代码，修改接口：</p>

<p>```objc
// 1
@interface WXCondition : MTLModel <MTLJSONSerializing></p>

<p>// 2
@property (nonatomic, strong) NSDate <em>date;
@property (nonatomic, strong) NSNumber </em>humidity;
@property (nonatomic, strong) NSNumber <em>temperature;
@property (nonatomic, strong) NSNumber </em>tempHigh;
@property (nonatomic, strong) NSNumber <em>tempLow;
@property (nonatomic, strong) NSString </em>locationName;
@property (nonatomic, strong) NSDate <em>sunrise;
@property (nonatomic, strong) NSDate </em>sunset;
@property (nonatomic, strong) NSString <em>conditionDescription;
@property (nonatomic, strong) NSString </em>condition;
@property (nonatomic, strong) NSNumber <em>windBearing;
@property (nonatomic, strong) NSNumber </em>windSpeed;
@property (nonatomic, strong) NSString *icon;</p>

<p>// 3
&ndash; (NSString *)imageName;</p>

<p>@end
```</p>

<ol>
<li><code>MTLJSONSerializing</code>协议告诉Mantle序列化该对象如何从JSON映射到Objective-C的属性。</li>
<li>这些都是你的天气数据的属性。你将会使用这些属性的get set方法，但是当你要扩展App，这是一种很好的方法来访问数据。</li>
<li>这是一个简单的辅助方法，从天气状况映射到图像文件。</li>
</ol>


<p>构建并运行App。失败了……</p>

<p>原因是你没有从你的Cocoapods项目中引入<code>Mantle</code>。解决方法是，在<code>WXCondition.h</code>中，你需要把<code>MTLModel.h</code>替换为<code>#import &lt;Mantle.h&gt;</code>。</p>

<p>现在构建并运行App。成功了。你会看到一些新的警告，但你可以忽略他们。</p>

<p>首先，你需要处理未实现的<code>-imageName</code>方法。</p>

<p>打开<code>WXCondition.m</code>，添加如下方法：</p>

<p>```objc
+ (NSDictionary *)imageMap {</p>

<pre><code>// 1
static NSDictionary *_imageMap = nil;
if (! _imageMap) {
    // 2
    _imageMap = @{
                  @"01d" : @"weather-clear",
                  @"02d" : @"weather-few",
                  @"03d" : @"weather-few",
                  @"04d" : @"weather-broken",
                  @"09d" : @"weather-shower",
                  @"10d" : @"weather-rain",
                  @"11d" : @"weather-tstorm",
                  @"13d" : @"weather-snow",
                  @"50d" : @"weather-mist",
                  @"01n" : @"weather-moon",
                  @"02n" : @"weather-few-night",
                  @"03n" : @"weather-few-night",
                  @"04n" : @"weather-broken",
                  @"09n" : @"weather-shower",
                  @"10n" : @"weather-rain-night",
                  @"11n" : @"weather-tstorm",
                  @"13n" : @"weather-snow",
                  @"50n" : @"weather-mist",
                  };
}
return _imageMap;
</code></pre>

<p>}</p>

<p>// 3
&ndash; (NSString *)imageName {</p>

<pre><code>return [WXCondition imageMap][self.icon];
</code></pre>

<p>}
```</p>

<ol>
<li>创建一个静态的NSDictionary，因为WXCondition的每个实例都将使用相同的数据映射。</li>
<li>天气状况与图像文件的关系（例如“01d”代表“weather-clear.png”）。</li>
<li>声明获取图像文件名的公有方法。</li>
</ol>


<p>看一看从OpenWeatherMap返回的JSON响应数据：</p>

<p>```json
{</p>

<pre><code>"dt": 1384279857,
"id": 5391959,
"main": {
    "humidity": 69,
    "pressure": 1025,
    "temp": 62.29,
    "temp_max": 69.01,
    "temp_min": 57.2
},
"name": "San Francisco",
"weather": [
    {
        "description": "haze",
        "icon": "50d",
        "id": 721,
        "main": "Haze"
    }
]
</code></pre>

<p>}
```</p>

<p>你需要把嵌套的JSON值映射到Objective-C的属性。嵌套的JSON值是元素，如温度，即上面看到的<code>main</code>节点。</p>

<p>要做到这一点，你将利用的Objective-C的<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/KeyValueCoding/Articles/BasicPrinciples.html">Key-Value Coding</a>和Mantle<a href="https://github.com/MantleFramework/Mantle/blob/master/Mantle/MTLJSONAdapter.h">的MTLJSONAdapter</a>。</p>

<p>还在<code>WXCondition.m</code>，通过添加<code>+JSONKeyPathsByPropertyKey</code>方法，“JSON到模型属性”的映射，且该方法是<code>MTLJSONSerializing</code>协议的<a href="https://github.com/MantleFramework/Mantle/blob/master/Mantle/MTLJSONAdapter.h#L17-28">require</a>。</p>

<p>```objc
+ (NSDictionary *)JSONKeyPathsByPropertyKey {</p>

<pre><code>return @{
         @"date": @"dt",
         @"locationName": @"name",
         @"humidity": @"main.humidity",
         @"temperature": @"main.temp",
         @"tempHigh": @"main.temp_max",
         @"tempLow": @"main.temp_min",
         @"sunrise": @"sys.sunrise",
         @"sunset": @"sys.sunset",
         @"conditionDescription": @"weather.description",
         @"condition": @"weather.main",
         @"icon": @"weather.icon",
         @"windBearing": @"wind.deg",
         @"windSpeed": @"wind.speed"
         };
</code></pre>

<p>}
```</p>

<p>在这个方法里，dictionary的key是<code>WXCondition</code>的属性名称，而dictionary的value是JSON的路径。</p>

<p>您可能已经注意到，这里有一个从JSON数据映射到Objective-C属性的问题。属性<code>date</code>是<code>NSDate</code>类型的，但JSON有一个Unix时间类型(sjpsega注:即从1970年1月1日0时0分0秒起至现在的总秒数)的NSInteger值。你需要完成两者之间的转换。</p>

<p>Mantle正好有一个功能来为你解决这个问题：<a href="https://github.com/github/Mantle/blob/master/Mantle/MTLValueTransformer.h">MTLValueTransformer</a>。这个类允许你声明一个block，详细说明值的相互转换。</p>

<p>Mantle的转换器语法有点怪。要创建一个为一个特定属性的转换器，，您可以添加一个以属性名开头和<code>JSONTransformer</code>结尾的类方法。
可能看实际代码比试图解释它更容易理解，所以在<code>WXCondition.m</code>中添加以下为NSDate属性设置的转换器。</p>

<p>```objc
+ (NSValueTransformer *)dateJSONTransformer {</p>

<pre><code>// 1
return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *str) {
    return [NSDate dateWithTimeIntervalSince1970:str.floatValue];
} reverseBlock:^(NSDate *date) {
    return [NSString stringWithFormat:@"%f",[date timeIntervalSince1970]];
}];
</code></pre>

<p>}</p>

<p>// 2
+ (NSValueTransformer *)sunriseJSONTransformer {</p>

<pre><code>return [self dateJSONTransformer];
</code></pre>

<p>}</p>

<ul>
<li><p>(NSValueTransformer *)sunsetJSONTransformer {
  return [self dateJSONTransformer];
}
```</p></li>
<li><p>使用blocks做属性的转换的工作，并返回一个MTLValueTransformer返回值。</p></li>
<li>您只需要详细说明Unix时间和NSDate之间进行转换一次，就可以重用<code>-dateJSONTransformer</code>方法为sunrise和sunset属性做转换。</li>
</ul>


<p>下一个值转型有点讨厌，但它只是使用OpenWeatherMap的API，并自己的格式化JSON响应方式的结果。<code>weather</code>键对应的值是一个JSON数组，但你只关注单一的天气状况。</p>

<p>在<code>WXCondition.m</code>中，使用<code>dateJSONTransformer</code>相同的结构，您可以创建一个NSArray和NSString的之间的转换。该解决方案提供如下：</p>

<p>```objc
+ (NSValueTransformer *)conditionDescriptionJSONTransformer {</p>

<pre><code>return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSArray *values) {
    return [values firstObject];
} reverseBlock:^(NSString *str) {
    return @[str];
}];
</code></pre>

<p>}</p>

<ul>
<li><p>(NSValueTransformer *)conditionJSONTransformer {
  return [self conditionDescriptionJSONTransformer];
}</p></li>
<li><p>(NSValueTransformer *)iconJSONTransformer {
  return [self conditionDescriptionJSONTransformer];
}
```</p></li>
</ul>


<p>最后的转换器只是为了格式化。 OpenWeatherAPI使用每秒/米的风速。由于您的App使用英制系统，你需要将其转换为每小时/英里。</p>

<p>在<code>WXCondition.m</code>的实现中添加以下转换器的方法和宏定义。</p>

<p>```objc</p>

<h1>define MPS_TO_MPH 2.23694f</h1>

<ul>
<li>(NSValueTransformer <em>)windSpeedJSONTransformer {
  return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSNumber </em>num) {
      return @(num.floatValue<em>MPS_TO_MPH);
  } reverseBlock:^(NSNumber </em>speed) {
      return @(speed.floatValue/MPS_TO_MPH);
  }];
}
```</li>
</ul>


<p>在OpenWeatherMap的API中有一个小的差异，你必须处理。看一看在位于<a href="http://api.openweathermap.org/data/2.5/weather?lat=37.785834&amp;lon=-122.406417&amp;units=imperial">当前状况的响应</a>和<a href="http://api.openweathermap.org/data/2.5/forecast/daily?lat=37.785834&amp;lon=-122.406417&amp;units=imperial&amp;cnt=7">每日预测反应</a>之间的温度：</p>

<p>```json
// current
&ldquo;main&rdquo;: {</p>

<pre><code>"grnd_level": 1021.87,
"humidity": 64,
"pressure": 1021.87,
"sea_level": 1030.6,
"temp": 58.09,
"temp_max": 58.09,
"temp_min": 58.09
</code></pre>

<p>}</p>

<p>// daily forecast
&ldquo;temp&rdquo;: {</p>

<pre><code>"day": 58.14,
"eve": 58.14,
"max": 58.14,
"min": 57.18,
"morn": 58.14,
"night": 57.18
</code></pre>

<p>}
```</p>

<p><code>current</code>的第一个key是<code>main</code>，最高温度存储在key <code>temp_max</code>中，而<code>daily forecast</code>的第一个key是<code>temp</code>，最高温度存储在key <code>max</code>中。</p>

<p>key Temperature的差异放在一边，其他都一样。所以，你真正需要做的是修改daily forecasts的键映射。</p>

<p>打开<code>WXDailyForecast.m</code>重写<code>+JSONKeyPathsByPropertyKey</code>方法：</p>

<p>```objc
+ (NSDictionary *)JSONKeyPathsByPropertyKey {</p>

<pre><code>// 1
NSMutableDictionary *paths = [[super JSONKeyPathsByPropertyKey] mutableCopy];
// 2
paths[@"tempHigh"] = @"temp.max";
paths[@"tempLow"] = @"temp.min";
// 3
return paths;
</code></pre>

<p>}
```</p>

<ol>
<li>获取<code>WXCondition</code>的映射，并创建它的可变副本。</li>
<li>你需要为daily forecast做的是改变max和min键映射。</li>
<li>返回新的映射。</li>
</ol>


<p>构建并运行您的App，看起来和上次运行没什么改变，但好的一点是，App编译和运行没有任何错误。</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/built-layout.jpg" width="320" alt="Labels and Views" /></p>

<h2>何去何从？</h2>

<p>你可以从<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2013/11/SimpleWeather-Part-1.zip">这里</a>下载完整程序。</p>

<p>在这部分教程中，您使用Cocoapods设置项目，增加视图到控制器，编排视图，并建立模型来反映你抓取的气象数据。该App还没有充分发挥作用，但是你成功用纯代码创建视图，并学习了如何使用Mantle映射和转换JSON数据。</p>

<p>接下来看看<a href="/blog/2014/02/15/yi--ios-7-best-practices-part-2/">教程的第二部分</a>，你将充实你的App，从weather API获取数据，并在UI上显示。您将使用新的iOS7 <a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/Introduction/Introduction.html">NSURLSession</a>去下载数据，以及使用<code>ReactiveCocoa</code>把位置查找，天气数据抓取和UI更新事件绑在一起。</p>
]]></content>
  </entry>
  
</feed>
